"""Zsh completion script generator for wArgs.

Generates zsh completion scripts that can be placed in a directory
in $fpath or sourced directly.
"""

from __future__ import annotations

from textwrap import dedent
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from wargs.completion.generator import CompletionOption, CompletionSpec


def generate_zsh_completion(spec: CompletionSpec) -> str:
    """Generate a Zsh completion script from a CompletionSpec.

    Args:
        spec: The completion specification.

    Returns:
        Zsh completion script as a string.
    """
    prog = spec.prog
    func_name = f"_{prog.replace('-', '_')}"

    script_parts = [
        f"#compdef {prog}",
        f"# Zsh completion script for {prog}",
        "# Generated by wArgs",
        "",
        f"{func_name}() {{",
        "    local context state state_descr line",
        "    typeset -A opt_args",
        "",
    ]

    # Build global options specification
    global_opts = []
    for opt in spec.global_options:
        opt_spec = _build_zsh_option_spec(opt)
        if opt_spec:
            global_opts.append(opt_spec)

    if spec.subcommands:
        # Has subcommands - use _arguments with state handling
        script_parts.append("    _arguments -C \\")
        for opt_spec in global_opts:
            script_parts.append(f"        {opt_spec} \\")
        script_parts.append("        '1:command:->command' \\")
        script_parts.append("        '*::arg:->args'")
        script_parts.append("")

        # Handle states
        script_parts.append('    case "$state" in')
        script_parts.append("        command)")

        # Build subcommand descriptions
        subcmd_specs = []
        for sub in spec.subcommands:
            desc = sub.description.replace("'", "\\'").replace("\n", " ")[:50]
            subcmd_specs.append(f"'{sub.name}:{desc}'")

        script_parts.append("            local -a commands")
        script_parts.append("            commands=(")
        for subcmd_spec in subcmd_specs:
            script_parts.append(f"                {subcmd_spec}")
        script_parts.append("            )")
        script_parts.append('            _describe "command" commands')
        script_parts.append("            ;;")

        script_parts.append("        args)")
        script_parts.append('            case "$words[1]" in')

        for sub in spec.subcommands:
            script_parts.append(f"                {sub.name})")
            sub_opts = []
            for opt in sub.options:
                opt_spec = _build_zsh_option_spec(opt)
                if opt_spec:
                    sub_opts.append(opt_spec)

            if sub_opts:
                script_parts.append("                    _arguments \\")
                for i, opt_spec in enumerate(sub_opts):
                    if i < len(sub_opts) - 1:
                        script_parts.append(f"                        {opt_spec} \\")
                    else:
                        script_parts.append(f"                        {opt_spec}")
            else:
                script_parts.append("                    _arguments")
            script_parts.append("                    ;;")

        script_parts.append("            esac")
        script_parts.append("            ;;")
        script_parts.append("    esac")

    else:
        # No subcommands - simple _arguments
        if global_opts:
            script_parts.append("    _arguments \\")
            for i, opt_spec in enumerate(global_opts):
                if i < len(global_opts) - 1:
                    script_parts.append(f"        {opt_spec} \\")
                else:
                    script_parts.append(f"        {opt_spec}")
        else:
            script_parts.append("    _arguments")

    script_parts.append("}")
    script_parts.append("")
    script_parts.append(f'{func_name} "$@"')
    script_parts.append("")

    return "\n".join(script_parts)


def _build_zsh_option_spec(opt: CompletionOption) -> str:
    """Build a zsh _arguments option specification.

    Args:
        opt: CompletionOption instance.

    Returns:
        Zsh option specification string.
    """
    if not opt.flags:
        return ""

    # Escape description
    desc = opt.description.replace("'", "\\'").replace("[", "\\[").replace("]", "\\]")
    desc = desc.replace("\n", " ")[:60]

    # Build flag part
    if len(opt.flags) == 1:
        flag = opt.flags[0]
        if opt.takes_value:
            if opt.choices:
                choices_str = " ".join(opt.choices)
                return f"'{flag}[{desc}]:value:(({choices_str}))'"
            elif opt.file_completion:
                return f"'{flag}[{desc}]:file:_files'"
            elif opt.directory_completion:
                return f"'{flag}[{desc}]:directory:_directories'"
            else:
                return f"'{flag}[{desc}]:value:'"
        else:
            return f"'{flag}[{desc}]'"
    else:
        # Multiple flags (short and long)
        short = (
            opt.flags[0]
            if opt.flags[0].startswith("-") and not opt.flags[0].startswith("--")
            else None
        )
        long = next((f for f in opt.flags if f.startswith("--")), None)

        if short and long:
            flags_str = f"({short} {long})'{{{short},{long}}}'"
        elif long:
            flags_str = f"'{long}'"
        else:
            flags_str = f"'{opt.flags[0]}'"

        if opt.takes_value:
            if opt.choices:
                choices_str = " ".join(opt.choices)
                return f"{flags_str}'[{desc}]:value:(({choices_str}))'"
            elif opt.file_completion:
                return f"{flags_str}'[{desc}]:file:_files'"
            elif opt.directory_completion:
                return f"{flags_str}'[{desc}]:directory:_directories'"
            else:
                return f"{flags_str}'[{desc}]:value:'"
        else:
            return f"{flags_str}'[{desc}]'"


def get_zsh_completion_install_instructions(prog: str) -> str:
    """Get installation instructions for Zsh completion.

    Args:
        prog: The program name.

    Returns:
        Human-readable installation instructions.
    """
    return dedent(f"""\
        # To enable {prog} zsh completion, choose one of:

        # Option 1: Add to your ~/.zshrc
        eval "$({prog} --completion zsh)"

        # Option 2: Save to a file in your fpath
        {prog} --completion zsh > ~/.zsh/completions/_{prog}
        # Then add to ~/.zshrc: fpath=(~/.zsh/completions $fpath)

        # Option 3: System-wide installation
        {prog} --completion zsh > /usr/local/share/zsh/site-functions/_{prog}
    """)


__all__ = [
    "generate_zsh_completion",
    "get_zsh_completion_install_instructions",
]
