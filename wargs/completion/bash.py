"""Bash completion script generator for wArgs.

Generates bash completion scripts that can be sourced or installed
in /etc/bash_completion.d/ or ~/.bash_completion.
"""

from __future__ import annotations

from textwrap import dedent
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from wargs.completion.generator import CompletionSpec


def generate_bash_completion(spec: CompletionSpec) -> str:
    """Generate a Bash completion script from a CompletionSpec.

    Args:
        spec: The completion specification.

    Returns:
        Bash completion script as a string.
    """
    prog = spec.prog
    func_name = f"_wargs_{prog.replace('-', '_')}_completions"

    # Collect all option flags
    all_opts = []
    for opt in spec.global_options:
        all_opts.extend(opt.flags)

    subcommand_names = [sub.name for sub in spec.subcommands]

    script_parts = [
        f"# Bash completion script for {prog}",
        "# Generated by wArgs",
        "",
        f"{func_name}() {{",
        "    local cur prev words cword",
        "    _init_completion || return",
        "",
        '    local commands="${commands:-}"',
        '    local global_opts="${global_opts:-}"',
        "",
    ]

    # Define commands (subcommands)
    if subcommand_names:
        script_parts.append(f'    commands="{" ".join(subcommand_names)}"')
    else:
        script_parts.append('    commands=""')

    # Define global options
    script_parts.append(f'    global_opts="{" ".join(all_opts)}"')
    script_parts.append("")

    # Handle option value completion
    script_parts.append("    # Handle option arguments")
    script_parts.append('    case "${prev}" in')

    for opt in spec.global_options:
        if opt.choices and opt.takes_value:
            flags = "|".join(opt.flags)
            choices = " ".join(opt.choices)
            script_parts.append(f"        {flags})")
            script_parts.append(
                f'            COMPREPLY=($(compgen -W "{choices}" -- "${{cur}}"))'
            )
            script_parts.append("            return 0")
            script_parts.append("            ;;")
        elif opt.file_completion and opt.takes_value:
            flags = "|".join(opt.flags)
            script_parts.append(f"        {flags})")
            script_parts.append("            _filedir")
            script_parts.append("            return 0")
            script_parts.append("            ;;")
        elif opt.directory_completion and opt.takes_value:
            flags = "|".join(opt.flags)
            script_parts.append(f"        {flags})")
            script_parts.append("            _filedir -d")
            script_parts.append("            return 0")
            script_parts.append("            ;;")

    script_parts.append("    esac")
    script_parts.append("")

    # Handle subcommand completion
    if subcommand_names:
        script_parts.append("    # Find current subcommand")
        script_parts.append('    local cmd=""')
        script_parts.append("    for ((i=1; i < cword; i++)); do")
        script_parts.append('        case "${words[i]}" in')
        for sub in spec.subcommands:
            script_parts.append(f"            {sub.name})")
            script_parts.append(f'                cmd="{sub.name}"')
            script_parts.append("                break")
            script_parts.append("                ;;")
        script_parts.append("        esac")
        script_parts.append("    done")
        script_parts.append("")

        script_parts.append("    # Complete subcommand options")
        script_parts.append('    case "${cmd}" in')

        for sub in spec.subcommands:
            sub_opts = []
            for opt in sub.options:
                sub_opts.extend(opt.flags)
            script_parts.append(f"        {sub.name})")
            script_parts.append(
                f'            COMPREPLY=($(compgen -W "{" ".join(sub_opts)}" -- "${{cur}}"))'
            )
            script_parts.append("            return 0")
            script_parts.append("            ;;")

        script_parts.append("    esac")
        script_parts.append("")

    # Default completion
    script_parts.append("    # Default: complete commands and global options")
    script_parts.append('    if [[ "${cur}" == -* ]]; then')
    script_parts.append(
        '        COMPREPLY=($(compgen -W "${global_opts}" -- "${cur}"))'
    )
    script_parts.append("    else")
    if subcommand_names:
        script_parts.append(
            '        COMPREPLY=($(compgen -W "${commands}" -- "${cur}"))'
        )
    else:
        script_parts.append(
            '        COMPREPLY=($(compgen -W "${global_opts}" -- "${cur}"))'
        )
    script_parts.append("    fi")
    script_parts.append("}")
    script_parts.append("")

    # Register completion
    script_parts.append(f"complete -F {func_name} {prog}")
    script_parts.append("")

    return "\n".join(script_parts)


def get_bash_completion_install_instructions(prog: str) -> str:
    """Get installation instructions for Bash completion.

    Args:
        prog: The program name.

    Returns:
        Human-readable installation instructions.
    """
    return dedent(f"""\
        # To enable {prog} bash completion, choose one of:

        # Option 1: Add to your ~/.bashrc
        eval "$({prog} --completion bash)"

        # Option 2: Save to a file and source it
        {prog} --completion bash > ~/.{prog}-completion.bash
        echo 'source ~/.{prog}-completion.bash' >> ~/.bashrc

        # Option 3: System-wide installation (requires root)
        {prog} --completion bash > /etc/bash_completion.d/{prog}
    """)


__all__ = [
    "generate_bash_completion",
    "get_bash_completion_install_instructions",
]
