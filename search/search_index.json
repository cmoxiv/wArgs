{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"wArgs","text":"<p>Just decorate and you're done.</p> <p>wArgs is a Python decorator library that automatically generates argparse-based CLI interfaces from your function signatures, type hints, and docstrings.</p>"},{"location":"#why-wargs","title":"Why wArgs?","text":"<p>Writing CLI applications with argparse involves a lot of repetition:</p> <pre><code># Traditional argparse approach\nimport argparse\n\ndef greet(name: str, greeting: str = \"Hello\", times: int = 1) -&gt; None:\n    for _ in range(times):\n        print(f\"{greeting}, {name}!\")\n\nparser = argparse.ArgumentParser(description=\"Greet someone.\")\nparser.add_argument(\"--name\", required=True, help=\"The name to greet\")\nparser.add_argument(\"--greeting\", default=\"Hello\", help=\"The greeting to use\")\nparser.add_argument(\"--times\", type=int, default=1, help=\"Number of times to greet\")\n\nif __name__ == \"__main__\":\n    args = parser.parse_args()\n    greet(args.name, args.greeting, args.times)\n</code></pre> <p>With wArgs, the same CLI becomes:</p> <pre><code>from wArgs import wArgs\n\n@wArgs\ndef greet(name: str, greeting: str = \"Hello\", times: int = 1) -&gt; None:\n    \"\"\"Greet someone.\n\n    Args:\n        name: The name to greet\n        greeting: The greeting to use\n        times: Number of times to greet\n    \"\"\"\n    for _ in range(times):\n        print(f\"{greeting}, {name}!\")\n\nif __name__ == \"__main__\":\n    greet()\n</code></pre> <p>That's it. No duplication. No boilerplate. Just your function.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Zero boilerplate - Turn any function into a CLI with a single decorator</li> <li>Type-safe - Automatic argument conversion based on type hints</li> <li>Docstring parsing - Extracts help text from Google, NumPy, and Sphinx docstrings</li> <li>Nested subcommands - Build complex CLI hierarchies with classes</li> <li>Inheritance support - Share options across commands via class inheritance</li> <li>Custom converters - Register converters for custom types</li> <li>Debugging utilities - Inspect generated parsers with <code>explain()</code></li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"Function-based CLIClass-based CLI <pre><code>from wArgs import wArgs\n\n@wArgs\ndef hello(name: str, loud: bool = False) -&gt; None:\n    \"\"\"Say hello to someone.\n\n    Args:\n        name: Person to greet\n        loud: Use uppercase\n    \"\"\"\n    msg = f\"Hello, {name}!\"\n    print(msg.upper() if loud else msg)\n\nif __name__ == \"__main__\":\n    hello()\n</code></pre> <pre><code>$ python hello.py --name World --loud\nHELLO, WORLD!\n</code></pre> <pre><code>from wArgs import wArgs\n\n@wArgs\nclass Calculator:\n    \"\"\"A simple calculator.\"\"\"\n\n    def add(self, a: int, b: int) -&gt; None:\n        \"\"\"Add two numbers.\"\"\"\n        print(a + b)\n\n    def multiply(self, a: int, b: int) -&gt; None:\n        \"\"\"Multiply two numbers.\"\"\"\n        print(a * b)\n\nif __name__ == \"__main__\":\n    Calculator()\n</code></pre> <pre><code>$ python calc.py add --a 2 --b 3\n5\n$ python calc.py multiply --a 4 --b 5\n20\n</code></pre>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install wargs\n</code></pre> <p>See the Installation Guide for more options.</p>"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li>Quick Start - Get up and running in 5 minutes</li> <li>Tutorial - Build a complete CLI application</li> <li>User Guide - Learn all the features</li> <li>API Reference - Detailed API documentation</li> </ul>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to wArgs will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#unreleased","title":"[Unreleased]","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Initial release of wArgs</li> <li><code>@wArgs</code> decorator for functions and classes</li> <li>Automatic argument parsing from type hints</li> <li>Support for Google, NumPy, and Sphinx docstring formats</li> <li><code>Arg</code> metadata class for fine-grained control</li> <li>Class-based subcommand support</li> <li>MRO traversal for inherited parameters</li> <li>Built-in type converters (datetime, UUID, Decimal, etc.)</li> <li>Custom converter registry with <code>@converter</code> decorator</li> <li>Utility functions: <code>explain()</code>, <code>get_parser()</code>, <code>get_config()</code></li> <li><code>WARGS_DEBUG</code> environment variable for debugging</li> <li>Comprehensive documentation and examples</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Nothing yet</li> </ul>"},{"location":"changelog/#deprecated","title":"Deprecated","text":"<ul> <li>Nothing yet</li> </ul>"},{"location":"changelog/#removed","title":"Removed","text":"<ul> <li>Nothing yet</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Nothing yet</li> </ul>"},{"location":"changelog/#security","title":"Security","text":"<ul> <li>Nothing yet</li> </ul>"},{"location":"changelog/#010-unreleased","title":"[0.1.0] - Unreleased","text":"<p>Initial development release.</p>"},{"location":"changelog/#features","title":"Features","text":"<ul> <li>Function decoration with <code>@wArgs</code></li> <li>Class decoration for subcommands</li> <li>Type hint-based argument conversion</li> <li>Docstring parsing for help text</li> <li><code>Arg</code> metadata for customization</li> <li>Inheritance and mixin support</li> <li>Custom type converters</li> <li>Debug utilities</li> </ul>"},{"location":"examples/","title":"Examples Gallery","text":"<p>Browse real-world examples organized by use case and complexity level.</p>"},{"location":"examples/#quick-links","title":"Quick Links","text":"<p>All examples are in the <code>examples/</code> directory. Each example is a complete, runnable script with inline documentation.</p> <pre><code># Run any example from the repository root\npython examples/simple/greet.py --help\npython examples/simple/greet.py --greet-name World\n</code></pre>"},{"location":"examples/#by-complexity","title":"By Complexity","text":""},{"location":"examples/#beginner","title":"Beginner","text":"<p>Simple Function Decoration - <code>simple/greet.py</code> - Basic <code>@wArgs</code> usage with strings and integers - <code>simple/flags.py</code> - Boolean flags and optional parameters</p> <p>Type Hints and Conversion - <code>typed/process.py</code> - <code>Path</code> type handling, file I/O - <code>typed/numbers.py</code> - Integer, float, and numeric validation</p> <p>What you'll learn: - Applying the <code>@wArgs</code> decorator - Using type hints for automatic conversion - Default values and optional parameters - Accessing parsed arguments</p>"},{"location":"examples/#intermediate","title":"Intermediate","text":"<p>Class-Based CLIs - <code>subcommands/git_clone.py</code> - Git-style CLI with multiple subcommands - <code>subcommands/docker.py</code> - Docker-style nested commands</p> <p>Custom Type Converters - <code>advanced/custom_types.py</code> - Registering converters for custom types - <code>advanced/enum_types.py</code> - Using Enum for constrained choices</p> <p>Docstring Integration - <code>docstrings/google_style.py</code> - Google-style docstrings - <code>docstrings/numpy_style.py</code> - NumPy-style docstrings</p> <p>What you'll learn: - Creating subcommands from class methods - Global options vs command-specific arguments - Custom type conversion and validation - Generating help from docstrings</p>"},{"location":"examples/#advanced","title":"Advanced","text":"<p>Inheritance Patterns - <code>inheritance/mixins.py</code> - Cooperative inheritance with mixins - <code>inheritance/abstract.py</code> - Abstract base classes for CLIs</p> <p>Complex Type Handling - <code>advanced/generics.py</code> - Generic types and containers - <code>advanced/dataclasses.py</code> - Dataclass parameters</p> <p>Configuration &amp; Customization - <code>advanced/dict_expansion.py</code> - Dictionary expansion to CLI args - <code>advanced/arg_config.py</code> - Fine-grained <code>Arg()</code> configuration</p> <p>What you'll learn: - Method resolution order (MRO) traversal - Complex type hierarchies - Advanced argument configuration - Custom help formatting</p>"},{"location":"examples/#by-use-case","title":"By Use Case","text":""},{"location":"examples/#data-processing","title":"Data Processing","text":"<p>File Processing <pre><code># examples/use-cases/data/file_processor.py\nfrom pathlib import Path\nfrom wArgs import wArgs\n\n@wArgs\ndef process_csv(\n    input: Path,\n    output: Path,\n    delimiter: str = \",\",\n    skip_header: bool = False,\n):\n    \"\"\"Process CSV files with custom delimiter.\"\"\"\n    # Implementation\n</code></pre></p> <p>Data Transformation <pre><code># examples/use-cases/data/transformer.py\nfrom typing import Literal\nfrom wArgs import wArgs\n\n@wArgs\ndef transform(\n    input_format: Literal[\"json\", \"yaml\", \"csv\"],\n    output_format: Literal[\"json\", \"yaml\", \"csv\"],\n    input_file: Path,\n    output_file: Path,\n):\n    \"\"\"Transform data between formats.\"\"\"\n    # Implementation\n</code></pre></p>"},{"location":"examples/#system-administration","title":"System Administration","text":"<p>Process Management <pre><code># examples/use-cases/sysadmin/process_manager.py\nfrom wArgs import wArgs\n\n@wArgs\nclass ProcessManager:\n    def __init__(self, verbose: bool = False):\n        self.verbose = verbose\n\n    def start(self, service: str, port: int = 8080):\n        \"\"\"Start a service.\"\"\"\n        pass\n\n    def stop(self, service: str, force: bool = False):\n        \"\"\"Stop a service.\"\"\"\n        pass\n\n    def restart(self, service: str):\n        \"\"\"Restart a service.\"\"\"\n        pass\n</code></pre></p> <p>Log Analysis <pre><code># examples/use-cases/sysadmin/log_analyzer.py\nfrom pathlib import Path\nfrom datetime import datetime\nfrom wArgs import wArgs\n\n@wArgs\ndef analyze_logs(\n    log_file: Path,\n    since: datetime,\n    level: str = \"ERROR\",\n    output: Path | None = None,\n):\n    \"\"\"Analyze log files for errors.\"\"\"\n    # Implementation\n</code></pre></p>"},{"location":"examples/#web-services","title":"Web Services","text":"<p>API Client <pre><code># examples/use-cases/web/api_client.py\nfrom wArgs import wArgs\nfrom typing import Literal\n\n@wArgs\nclass APIClient:\n    def __init__(self, base_url: str, token: str | None = None):\n        self.base_url = base_url\n        self.token = token\n\n    def get(self, endpoint: str):\n        \"\"\"GET request.\"\"\"\n        pass\n\n    def post(self, endpoint: str, data: str):\n        \"\"\"POST request with JSON data.\"\"\"\n        pass\n</code></pre></p> <p>Web Scraper <pre><code># examples/use-cases/web/scraper.py\nfrom wArgs import wArgs\nfrom pathlib import Path\n\n@wArgs\ndef scrape(\n    url: str,\n    output: Path,\n    timeout: int = 30,\n    user_agent: str = \"wArgs-Scraper/1.0\",\n):\n    \"\"\"Scrape a website and save results.\"\"\"\n    # Implementation\n</code></pre></p>"},{"location":"examples/#development-tools","title":"Development Tools","text":"<p>Build Tool <pre><code># examples/use-cases/devtools/builder.py\nfrom wArgs import wArgs\n\n@wArgs\nclass Build:\n    def __init__(self, config: Path = Path(\"build.toml\")):\n        self.config = config\n\n    def clean(self):\n        \"\"\"Remove build artifacts.\"\"\"\n        pass\n\n    def compile(self, target: str = \"release\"):\n        \"\"\"Compile the project.\"\"\"\n        pass\n\n    def test(self, verbose: bool = False):\n        \"\"\"Run tests.\"\"\"\n        pass\n</code></pre></p>"},{"location":"examples/#running-examples","title":"Running Examples","text":""},{"location":"examples/#from-the-repository","title":"From the Repository","text":"<pre><code># Clone the repository\ngit clone https://github.com/cmoxiv/wArgs.git\ncd wArgs\n\n# Install wArgs\npip install -e .\n\n# Run any example\npython examples/simple/greet.py --greet-name \"World\"\npython examples/subcommands/git_clone.py --help\npython examples/advanced/custom_types.py --help\n</code></pre>"},{"location":"examples/#standalone-scripts","title":"Standalone Scripts","text":"<p>Each example is self-contained and can be copied directly:</p> <pre><code># Copy an example to your project\ncp examples/simple/greet.py my_cli.py\n\n# Customize and run\npython my_cli.py --help\n</code></pre>"},{"location":"examples/#example-structure","title":"Example Structure","text":"<p>Each example follows this pattern:</p> <pre><code>#!/usr/bin/env python3\n\"\"\"\nExample: Brief description\n\nDemonstrates:\n- Feature 1\n- Feature 2\n- Feature 3\n\"\"\"\n\nfrom wArgs import wArgs\n# Other imports\n\n@wArgs\ndef example_function(param: Type):\n    \"\"\"Function docstring.\"\"\"\n    # Implementation\n    pass\n\nif __name__ == \"__main__\":\n    example_function()\n</code></pre>"},{"location":"examples/#contributing-examples","title":"Contributing Examples","text":"<p>Have a great example? We'd love to include it!</p>"},{"location":"examples/#requirements","title":"Requirements","text":"<ul> <li>Self-contained: Minimal external dependencies (prefer stdlib)</li> <li>Documented: Clear docstrings and inline comments</li> <li>Focused: Demonstrates one main concept</li> <li>Realistic: Solves a real-world problem</li> <li>Tested: Works correctly with current wArgs version</li> </ul>"},{"location":"examples/#submission-process","title":"Submission Process","text":"<ol> <li>Add your example to <code>examples/</code> in an appropriate subdirectory</li> <li>Follow the existing naming convention: <code>feature_name.py</code></li> <li>Include a docstring explaining what it demonstrates</li> <li>Test it thoroughly</li> <li>Submit a PR with description</li> </ol> <p>See CONTRIBUTING.md for more details.</p>"},{"location":"examples/#example-categories","title":"Example Categories","text":""},{"location":"examples/#current-categories","title":"Current Categories","text":"<ul> <li><code>simple/</code> - Basic usage patterns</li> <li><code>typed/</code> - Type system examples</li> <li><code>subcommands/</code> - Class-based CLIs</li> <li><code>advanced/</code> - Complex features</li> <li><code>inheritance/</code> - Inheritance patterns</li> <li><code>docstrings/</code> - Documentation styles</li> </ul>"},{"location":"examples/#proposed-categories","title":"Proposed Categories","text":"<p>Help us expand the examples! We'd love examples for:</p> <ul> <li>Database CLIs (SQLAlchemy, raw SQL)</li> <li>Testing tools (pytest plugins, test runners)</li> <li>Deployment scripts (Docker, K8s)</li> <li>CI/CD tools</li> <li>Configuration management</li> <li>Monitoring and alerting</li> <li>Code generation</li> <li>Project scaffolding</li> </ul>"},{"location":"examples/#learn-more","title":"Learn More","text":"<ul> <li>Tutorial: getting-started/tutorial.md - Step-by-step guide</li> <li>User Guide: guide/basic-usage.md - Comprehensive documentation</li> <li>Cookbook: cookbook/patterns.md - Common patterns and recipes</li> <li>API Reference: api/decorators.md - Complete API documentation</li> </ul> <p>Browse all examples on GitHub or suggest new examples.</p>"},{"location":"faq/","title":"Frequently Asked Questions","text":""},{"location":"faq/#general","title":"General","text":""},{"location":"faq/#why-wargs-vs-clicktyper","title":"Why wArgs vs Click/Typer?","text":"<p>wArgs takes a different approach from Click and Typer:</p> <ul> <li>Decorator-first: Just add <code>@wArgs</code> to your function - no additional annotations needed</li> <li>Type-native: Uses Python's native type hints exclusively (no custom parameter objects)</li> <li>No runtime overhead: wArgs generates standard <code>argparse.ArgumentParser</code> objects</li> <li>Class-based subcommands: Natural support for class-based CLIs with <code>__init__</code> parameters</li> <li>Zero dependencies: Pure Python standard library (except dev dependencies)</li> </ul> <p>Click/Typer require custom decorators for each parameter and introduce runtime dependencies, while wArgs leverages Python's built-in introspection.</p>"},{"location":"faq/#does-wargs-work-with-async-functions","title":"Does wArgs work with async functions?","text":"<p>Not currently. Async function support is planned for v2.0. The main challenge is that <code>argparse</code> and the standard CLI model are synchronous. We're exploring options for:</p> <ul> <li>Automatic event loop management</li> <li>Integration with <code>asyncio.run()</code></li> <li>Support for async context managers</li> </ul> <p>Follow #123 for updates.</p>"},{"location":"faq/#can-i-use-wargs-with-existing-argparse-code","title":"Can I use wArgs with existing argparse code?","text":"<p>Yes! wArgs generates standard <code>ArgumentParser</code> objects that you can customize:</p> <pre><code>from wArgs import wArgs, get_parser\n\n@wArgs\ndef my_cli(name: str):\n    \"\"\"My CLI tool.\"\"\"\n    print(f\"Hello, {name}!\")\n\n# Get the parser and add custom arguments\nparser = get_parser(my_cli)\nparser.add_argument(\"--legacy-flag\", action=\"store_true\")\n\n# Use it\nif __name__ == \"__main__\":\n    parser.parse_args()\n</code></pre> <p>See cookbook/migration-argparse.md for more examples.</p>"},{"location":"faq/#is-wargs-compatible-with-python-38","title":"Is wArgs compatible with Python 3.8?","text":"<p>Yes! wArgs supports Python 3.8+ and uses <code>from __future__ import annotations</code> for backward compatibility. We test against all supported Python versions in CI.</p>"},{"location":"faq/#how-does-wargs-handle-argument-prefixing","title":"How does wArgs handle argument prefixing?","text":"<p>All arguments are automatically prefixed with the callable name to avoid conflicts:</p> <pre><code>@wArgs\ndef greet(name: str, count: int = 1):\n    pass\n\n# CLI: --greet-name, --greet-count\n</code></pre> <p>This is especially useful for class-based CLIs where <code>__init__</code> and methods share argument names.</p>"},{"location":"faq/#type-system","title":"Type System","text":""},{"location":"faq/#how-do-i-handle-custom-types","title":"How do I handle custom types?","text":"<p>Use the <code>@converter</code> decorator to register type converters:</p> <pre><code>from wArgs import wArgs, converter\nfrom pathlib import Path\n\n@converter(Path)\ndef convert_path(value: str) -&gt; Path:\n    path = Path(value)\n    if not path.exists():\n        raise ValueError(f\"Path does not exist: {value}\")\n    return path\n\n@wArgs\ndef process_file(input: Path):\n    \"\"\"Process a file.\"\"\"\n    print(f\"Processing {input}\")\n</code></pre> <p>See examples/advanced/custom_types.py for complete examples.</p>"},{"location":"faq/#why-isnt-my-optionalstr-working","title":"Why isn't my Optional[str] working?","text":"<p><code>Optional[str]</code> alone doesn't make an argument optional in the CLI - you need a default value:</p> <pre><code># \u274c Wrong - still required\ndef greet(name: Optional[str]):\n    pass\n\n# \u2705 Correct - optional with default\ndef greet(name: Optional[str] = None):\n    pass\n\n# \u2705 Also correct - using new union syntax\ndef greet(name: str | None = None):\n    pass\n</code></pre> <p>The type hint describes what values are valid, while the default value controls whether the argument is required.</p>"},{"location":"faq/#how-do-i-use-annotated-for-advanced-configuration","title":"How do I use Annotated for advanced configuration?","text":"<p>Use <code>Annotated</code> with <code>Arg()</code> for fine-grained control:</p> <pre><code>from typing import Annotated\nfrom wArgs import wArgs, Arg\n\n@wArgs\ndef deploy(\n    env: Annotated[str, Arg(choices=[\"dev\", \"staging\", \"prod\"], help=\"Target environment\")],\n    verbose: Annotated[bool, Arg(short=\"-v\")] = False,\n):\n    \"\"\"Deploy to environment.\"\"\"\n    pass\n</code></pre> <p>See guide/type-system.md for more details.</p>"},{"location":"faq/#can-i-use-pydantic-models","title":"Can I use Pydantic models?","text":"<p>Not directly, but you can use dataclasses:</p> <pre><code>from dataclasses import dataclass\nfrom wArgs import wArgs\n\n@dataclass\nclass Config:\n    host: str\n    port: int\n\n@wArgs\ndef serve(config: Config):\n    \"\"\"Start server.\"\"\"\n    print(f\"Serving on {config.host}:{config.port}\")\n</code></pre> <p>Full Pydantic integration is planned for v1.2.</p>"},{"location":"faq/#common-issues","title":"Common Issues","text":""},{"location":"faq/#typeerror-unsupported-type-for-argument","title":"\"TypeError: unsupported type for argument\"","text":"<p>This means wArgs doesn't know how to convert the CLI string to your type. Solutions:</p> <ol> <li>Use a built-in type: <code>str</code>, <code>int</code>, <code>float</code>, <code>bool</code>, <code>Path</code></li> <li>Register a converter: Use <code>@converter</code> decorator</li> <li>Debug with <code>explain()</code>: See what wArgs detected</li> </ol> <pre><code>from wArgs import explain\n\nexplain(my_function)  # Shows full introspection details\n</code></pre>"},{"location":"faq/#subcommands-not-appearing","title":"Subcommands not appearing","text":"<p>Check these common issues:</p> <ol> <li>Forgot <code>@wArgs</code> decorator: Class must be decorated</li> <li><code>__init__</code> signature: Parameters in <code>__init__</code> become global options, not subcommands</li> <li>Method naming: Only public methods (not starting with <code>_</code>) become subcommands</li> <li>traverse_mro: Set to <code>False</code> if inherited methods shouldn't be subcommands</li> </ol> <pre><code># \u2705 Correct\n@wArgs\nclass CLI:\n    def __init__(self, verbose: bool = False):\n        self.verbose = verbose\n\n    def hello(self, name: str):\n        \"\"\"This becomes a subcommand.\"\"\"\n        print(f\"Hello, {name}!\")\n\n# \u274c Wrong - no methods\n@wArgs\nclass CLI:\n    def __init__(self, name: str):\n        print(f\"Hello, {name}!\")\n</code></pre>"},{"location":"faq/#dictionary-expansion-not-working","title":"Dictionary expansion not working","text":"<p>Dictionary defaults automatically expand to multiple arguments:</p> <pre><code>@wArgs\ndef connect(config: dict = {\"host\": \"localhost\", \"port\": 8080}):\n    pass\n\n# CLI: --connect-config-host, --connect-config-port\n</code></pre> <p>If you want a single argument that takes JSON, use <code>str</code> and parse manually.</p>"},{"location":"faq/#performance","title":"Performance","text":""},{"location":"faq/#does-wargs-add-overhead","title":"Does wArgs add overhead?","text":"<p>Parse-time overhead: Minimal - introspection happens once when the decorator is applied (import time), not on each invocation.</p> <p>Runtime overhead: None - wArgs generates standard <code>argparse.ArgumentParser</code> objects that handle argument parsing. The decorated function runs directly after parsing.</p> <p>Memory overhead: Negligible - cached introspection metadata is small (~1KB per function).</p>"},{"location":"faq/#is-introspection-cached","title":"Is introspection cached?","text":"<p>Yes! Function introspection happens once at decoration time (when the module is imported). The results are cached in the <code>WargsWrapper</code> object, so there's no repeated introspection overhead.</p>"},{"location":"faq/#can-i-use-wargs-in-production","title":"Can I use wArgs in production?","text":"<p>Absolutely! wArgs is:</p> <ul> <li>Battle-tested: 600+ passing tests with 100% coverage target</li> <li>Type-safe: Full mypy compliance in strict mode</li> <li>Stable API: Semantic versioning, no breaking changes in minor releases</li> <li>Pure Python: No C extensions or complex dependencies</li> </ul> <p>Used in production by several projects (see examples).</p>"},{"location":"faq/#development","title":"Development","text":""},{"location":"faq/#how-do-i-contribute","title":"How do I contribute?","text":"<p>See the CONTRIBUTING.md file in the repository for development setup, coding standards, and the contribution process.</p>"},{"location":"faq/#how-do-i-request-a-feature","title":"How do I request a feature?","text":"<ol> <li>Check ROADMAP.md to see if it's already planned</li> <li>Search issues for similar requests</li> <li>Create a Feature Request with details</li> </ol>"},{"location":"faq/#where-can-i-get-help","title":"Where can I get help?","text":"<ul> <li>Documentation: Start with Getting Started</li> <li>Examples: Browse examples/ directory</li> <li>Issues: Search existing issues</li> <li>Discussions: Join GitHub Discussions</li> <li>Troubleshooting: See troubleshooting guide</li> </ul> <p>Don't see your question? Open a discussion or create an issue.</p>"},{"location":"troubleshooting/","title":"Troubleshooting Guide","text":"<p>This guide helps you diagnose and fix common issues with wArgs.</p>"},{"location":"troubleshooting/#debugging-techniques","title":"Debugging Techniques","text":""},{"location":"troubleshooting/#using-explain","title":"Using explain()","text":"<p>The <code>explain()</code> utility shows exactly what wArgs extracted from your function:</p> <pre><code>from wArgs import wArgs, explain\n\n@wArgs\ndef greet(name: str, count: int = 1):\n    \"\"\"Greet someone multiple times.\"\"\"\n    for _ in range(count):\n        print(f\"Hello, {name}!\")\n\n# See full introspection details\nexplain(greet)\n</code></pre> <p>Output includes: - Function signature and docstring - Detected parameters with types, defaults, and descriptions - Type resolution details (origin, args, is_optional) - Registered converters - Argument configuration (flags, choices, help text)</p> <p>Use this when: - Arguments aren't appearing as expected - Type conversion is failing - Docstring parsing seems wrong</p>"},{"location":"troubleshooting/#enable-debug-output","title":"Enable Debug Output","text":"<p>Set the <code>WARGS_DEBUG</code> environment variable to see detailed parsing information:</p> <pre><code>WARGS_DEBUG=1 python my_cli.py --help\n</code></pre> <p>This shows: - <code>[wargs] Building parser for function: ...</code> - <code>[wargs] Parsing args: [...]</code> - <code>[wargs] Parsed result: Namespace(...)</code></p>"},{"location":"troubleshooting/#inspect-the-generated-parser","title":"Inspect the Generated Parser","text":"<p>Use <code>get_parser()</code> to examine the <code>ArgumentParser</code> object:</p> <pre><code>from wArgs import wArgs, get_parser\n\n@wArgs\ndef my_cli(name: str):\n    pass\n\nparser = get_parser(my_cli)\nparser.print_help()  # See generated help\n</code></pre>"},{"location":"troubleshooting/#test-argument-parsing","title":"Test Argument Parsing","text":"<p>Test what arguments are being parsed without running your function:</p> <pre><code>import sys\nfrom wArgs import get_parser\n\nparser = get_parser(my_cli)\nargs = parser.parse_args(sys.argv[1:])\nprint(f\"Parsed arguments: {args}\")\n</code></pre>"},{"location":"troubleshooting/#common-errors","title":"Common Errors","text":""},{"location":"troubleshooting/#import-errors","title":"Import Errors","text":""},{"location":"troubleshooting/#cannot-import-name-wargs","title":"\"cannot import name 'wargs'\"","text":"<p>Problem: Using lowercase <code>wargs</code> instead of mixed-case <code>wArgs</code>.</p> <p>Solution: Update your import:</p> <pre><code># \u274c Wrong\nfrom wargs import wArgs\n\n# \u2705 Correct\nfrom wArgs import wArgs\n</code></pre> <p>Note: The PyPI package name is <code>wargs</code> (lowercase), but the module exports are <code>wArgs</code> (mixed-case).</p>"},{"location":"troubleshooting/#modulenotfounderror-no-module-named-wargs","title":"\"ModuleNotFoundError: No module named 'wArgs'\"","text":"<p>Problem: Package not installed or wrong Python environment.</p> <p>Solution:</p> <pre><code># Install from PyPI\npip install wargs\n\n# Or install from source\npip install -e .\n\n# Verify installation\npython -c \"from wArgs import wArgs; print('Success!')\"\n</code></pre>"},{"location":"troubleshooting/#type-resolution-issues","title":"Type Resolution Issues","text":""},{"location":"troubleshooting/#typeerror-unsupported-type-for-argument-param","title":"\"TypeError: unsupported type for argument 'param'\"","text":"<p>Problem: wArgs doesn't have a converter for your type.</p> <p>Solutions:</p> <ol> <li> <p>Use a built-in type:    <pre><code># Supported: str, int, float, bool, Path, list, dict, etc.\ndef my_cli(value: int):  # \u2705 Works\n    pass\n</code></pre></p> </li> <li> <p>Register a converter:    <pre><code>from wArgs import wArgs, converter\n\n@converter(MyCustomType)\ndef convert_my_type(value: str) -&gt; MyCustomType:\n    return MyCustomType(value)\n\n@wArgs\ndef my_cli(value: MyCustomType):  # \u2705 Now works\n    pass\n</code></pre></p> </li> <li> <p>Check type annotation syntax:    <pre><code># \u274c Wrong - typo or undefined type\ndef my_cli(value: Paht):\n    pass\n\n# \u2705 Correct\nfrom pathlib import Path\ndef my_cli(value: Path):\n    pass\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#attributeerror-nonetype-has-no-attribute","title":"\"AttributeError: 'NoneType' has no attribute ...\"","text":"<p>Problem: Type hint resolved to <code>None</code> (missing import or forward reference issue).</p> <p>Solution:</p> <pre><code># \u2705 Add missing import\nfrom __future__ import annotations\nfrom pathlib import Path\n\n@wArgs\ndef process(file: Path):  # Now Path is defined\n    pass\n</code></pre>"},{"location":"troubleshooting/#subcommand-problems","title":"Subcommand Problems","text":""},{"location":"troubleshooting/#methods-not-appearing-as-subcommands","title":"Methods not appearing as subcommands","text":"<p>Checklist:</p> <ol> <li> <p>Is the class decorated? <pre><code>@wArgs  # \u2705 Required\nclass CLI:\n    def hello(self):\n        pass\n</code></pre></p> </li> <li> <p>Are methods public? <pre><code>class CLI:\n    def hello(self):  # \u2705 Public - becomes subcommand\n        pass\n\n    def _internal(self):  # \u274c Private - ignored\n        pass\n</code></pre></p> </li> <li> <p>Is <code>__init__</code> used correctly? <pre><code>@wArgs\nclass CLI:\n    def __init__(self, verbose: bool = False):  # \u2705 Global options\n        self.verbose = verbose\n\n    def deploy(self, env: str):  # \u2705 Subcommand\n        pass\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#wrong-arguments-for-subcommands","title":"Wrong arguments for subcommands","text":"<p>Problem: Seeing both <code>__init__</code> and method parameters, or wrong prefixes.</p> <p>Explanation: By default, <code>__init__</code> parameters become global options:</p> <pre><code># With @wArgs\nmy_cli --CLI-verbose deploy --deploy-env prod\n\n# If you don't want __init__ params, set traverse_mro=False\n@wArgs(traverse_mro=False)\nclass CLI:\n    ...\n</code></pre>"},{"location":"troubleshooting/#docstring-parsing-issues","title":"Docstring Parsing Issues","text":""},{"location":"troubleshooting/#descriptions-not-appearing-in-help","title":"Descriptions not appearing in help","text":"<p>Problem: Unsupported docstring format.</p> <p>Solution: Use Google, NumPy, or Sphinx style:</p> <pre><code># \u2705 Google style (recommended)\ndef greet(name: str, count: int = 1):\n    \"\"\"Greet someone.\n\n    Args:\n        name: The person's name\n        count: Number of greetings\n    \"\"\"\n\n# \u2705 NumPy style\ndef greet(name: str, count: int = 1):\n    \"\"\"Greet someone.\n\n    Parameters\n    ----------\n    name : str\n        The person's name\n    count : int\n        Number of greetings\n    \"\"\"\n</code></pre>"},{"location":"troubleshooting/#multi-line-descriptions-truncated","title":"Multi-line descriptions truncated","text":"<p>Problem: Only first line showing in help.</p> <p>Cause: This is expected behavior - only the first line of parameter descriptions appears in <code>--help</code> for brevity.</p> <p>Solution: Keep important info in the first line.</p>"},{"location":"troubleshooting/#argument-value-issues","title":"Argument Value Issues","text":""},{"location":"troubleshooting/#boolean-flags-always-true","title":"Boolean flags always True","text":"<p>Problem: Using boolean arguments incorrectly.</p> <p>Explanation: Boolean parameters become flags (no value needed):</p> <pre><code>@wArgs\ndef my_cli(verbose: bool = False):\n    pass\n\n# \u2705 Correct usage\nmy_cli --my_cli-verbose      # verbose=True\nmy_cli                       # verbose=False\n\n# \u274c Wrong - this will fail\nmy_cli --my_cli-verbose true\n</code></pre>"},{"location":"troubleshooting/#optional-arguments-still-required","title":"Optional arguments still required","text":"<p>Problem: Type hint says <code>Optional</code> but CLI still requires the argument.</p> <p>Solution: Add a default value:</p> <pre><code># \u274c Still required\ndef my_cli(name: Optional[str]):\n    pass\n\n# \u2705 Optional\ndef my_cli(name: Optional[str] = None):\n    pass\n</code></pre>"},{"location":"troubleshooting/#stack-traces","title":"Stack Traces","text":""},{"location":"troubleshooting/#understanding-wargs-stack-traces","title":"Understanding wArgs Stack Traces","text":"<p>When errors occur, wArgs stack traces show:</p> <pre><code>Traceback (most recent call last):\n  File \"my_cli.py\", line 10, in &lt;module&gt;\n    @wArgs\n  File \"wArgs/decorator.py\", line 45, in wArgs\n    return WargsWrapper(func, **kwargs)\n  File \"wArgs/decorator.py\", line 78, in __init__\n    self.config = build_parser_config(func)\n  File \"wArgs/builders/parser.py\", line 23, in build_parser_config\n    function_info = extract_function_info(func)\n  File \"wArgs/introspection/signatures.py\", line 56, in extract_function_info\n    raise IntrospectionError(f\"Cannot extract signature: {e}\")\nwArgs.core.exceptions.IntrospectionError: Cannot extract signature: ...\n</code></pre> <p>Key files to check:</p> <ul> <li><code>decorator.py</code>: Decorator application and wrapper creation</li> <li><code>introspection/signatures.py</code>: Function signature extraction</li> <li><code>introspection/types.py</code>: Type resolution</li> <li><code>builders/arguments.py</code>: Argument configuration</li> <li><code>converters/registry.py</code>: Type converter lookup</li> </ul>"},{"location":"troubleshooting/#common-stack-trace-patterns","title":"Common Stack Trace Patterns","text":""},{"location":"troubleshooting/#introspectionerror-during-decoration","title":"IntrospectionError during decoration","text":"<p>Cause: Problem analyzing function signature or docstring.</p> <p>Fix: Use <code>explain()</code> to see what was detected, check function definition.</p>"},{"location":"troubleshooting/#conversionerror-during-execution","title":"ConversionError during execution","text":"<p>Cause: Invalid argument value provided by user.</p> <p>Fix: Check converter implementation, validate input in converter.</p>"},{"location":"troubleshooting/#configurationerror-during-decoration","title":"ConfigurationError during decoration","text":"<p>Cause: Invalid decorator parameters.</p> <p>Fix: Check <code>@wArgs(...)</code> parameters match documented options.</p>"},{"location":"troubleshooting/#advanced-debugging","title":"Advanced Debugging","text":""},{"location":"troubleshooting/#run-tests","title":"Run Tests","text":"<p>If you suspect a bug in wArgs:</p> <pre><code># Clone repo\ngit clone https://github.com/cmoxiv/wArgs.git\ncd wArgs\n\n# Install dev dependencies\npip install -e \".[dev]\"\n\n# Run relevant tests\npytest tests/unit/test_decorator.py -v\npytest tests/unit/introspection/test_signatures.py -v\n</code></pre>"},{"location":"troubleshooting/#create-minimal-reproduction","title":"Create Minimal Reproduction","text":"<p>When reporting issues, create a minimal example:</p> <pre><code># minimal_repro.py\nfrom wArgs import wArgs\n\n@wArgs\ndef my_cli(param: SomeType):\n    \"\"\"Description.\"\"\"\n    pass\n\nif __name__ == \"__main__\":\n    my_cli()\n</code></pre> <p>Include: - Python version: <code>python --version</code> - wArgs version: <code>pip show wargs</code> - Full error message and stack trace - Expected vs actual behavior</p>"},{"location":"troubleshooting/#getting-help","title":"Getting Help","text":"<p>If you're still stuck after trying these steps:</p> <ol> <li>Check the FAQ: faq.md covers common questions</li> <li>Search issues: GitHub Issues</li> <li>Browse examples: examples/ directory</li> <li>Ask for help:</li> <li>GitHub Discussions - Questions and community help</li> <li>Create an issue - Bug reports and problems</li> </ol>"},{"location":"troubleshooting/#when-creating-an-issue","title":"When Creating an Issue","text":"<p>Include:</p> <ol> <li> <p>Environment:    <pre><code>python --version\npip show wargs\n</code></pre></p> </li> <li> <p>Minimal code example that reproduces the issue</p> </li> <li> <p>Full error message with stack trace</p> </li> <li> <p>Expected behavior - what should happen</p> </li> <li> <p>Actual behavior - what actually happens</p> </li> <li> <p>Debugging attempted - what you've tried from this guide</p> </li> </ol> <p>For more help, see FAQ or join the discussion.</p>"},{"location":"api/decorators/","title":"Decorators","text":""},{"location":"api/decorators/#wargs","title":"wArgs","text":"<p>The main decorator for creating CLI applications.</p>"},{"location":"api/decorators/#wArgs.wArgs","title":"wArgs.wArgs","text":"<pre><code>wArgs(func: type) -&gt; WargsClassWrapper\n</code></pre><pre><code>wArgs(func: Callable[..., Any]) -&gt; WargsWrapper\n</code></pre><pre><code>wArgs(\n    *,\n    prog: str | None = None,\n    description: str | None = None,\n    add_help: bool = True,\n    formatter_class: str | None = None,\n    traverse_mro: bool = True,\n    completion: bool = False,\n    prefix: bool | str = False\n) -&gt; Callable[\n    [Callable[..., Any] | type],\n    WargsWrapper | WargsClassWrapper,\n]\n</code></pre> <pre><code>wArgs(\n    func: Callable[..., Any] | type | None = None,\n    *,\n    prog: str | None = None,\n    description: str | None = None,\n    add_help: bool = True,\n    formatter_class: str | None = None,\n    traverse_mro: bool = True,\n    completion: bool = False,\n    prefix: bool | str = False\n) -&gt; (\n    WargsWrapper\n    | WargsClassWrapper\n    | Callable[\n        [Callable[..., Any] | type],\n        WargsWrapper | WargsClassWrapper,\n    ]\n)\n</code></pre> <p>Decorator to generate CLI from function or class.</p> <p>Can be used with or without arguments on functions or classes:</p> <pre><code># Function-based CLI\n@wArgs\ndef my_func(name: str): ...\n\n# Class-based CLI with subcommands\n@wArgs\nclass CLI:\n    def __init__(self, verbose: bool = False): ...\n    def add(self, name: str): ...\n    def remove(self, item_id: int): ...\n\n@wArgs(prog=\"myapp\", description=\"My application\")\ndef my_func(name: str): ...\n\n# Disable MRO traversal for inherited parameters\n@wArgs(traverse_mro=False)\nclass CLI(BaseClass): ...\n\n# Enable shell completion support\n@wArgs(completion=True)\ndef cli(name: str): ...\n# Then run: python script.py --completion bash\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[..., Any] | type | None</code> <p>The function or class to decorate (when used without parentheses).</p> <code>None</code> <code>prog</code> <code>str | None</code> <p>Program name override.</p> <code>None</code> <code>description</code> <code>str | None</code> <p>Description override.</p> <code>None</code> <code>add_help</code> <code>bool</code> <p>Whether to add -h/--help option.</p> <code>True</code> <code>formatter_class</code> <code>str | None</code> <p>Help formatter class name.</p> <code>None</code> <code>traverse_mro</code> <code>bool</code> <p>Whether to collect init params from parent classes (only applies to class decoration).</p> <code>True</code> <code>completion</code> <code>bool</code> <p>Whether to add --completion flag for shell completion.</p> <code>False</code> <code>prefix</code> <code>bool | str</code> <p>Argument prefixing mode. False (default) = no prefix, True = use callable name as prefix, str = use custom prefix string.</p> <code>False</code> <p>Returns:</p> Type Description <code>WargsWrapper | WargsClassWrapper | Callable[[Callable[..., Any] | type], WargsWrapper | WargsClassWrapper]</code> <p>WargsWrapper for functions, WargsClassWrapper for classes,</p> <code>WargsWrapper | WargsClassWrapper | Callable[[Callable[..., Any] | type], WargsWrapper | WargsClassWrapper]</code> <p>or a decorator function.</p>"},{"location":"api/decorators/#wargswrapper","title":"WargsWrapper","text":"<p>Wrapper class for decorated functions.</p>"},{"location":"api/decorators/#wArgs.WargsWrapper","title":"wArgs.WargsWrapper","text":"<pre><code>WargsWrapper(\n    func: Callable[..., Any],\n    *,\n    prog: str | None = None,\n    description: str | None = None,\n    add_help: bool = True,\n    formatter_class: str | None = None,\n    completion: bool = False,\n    prefix: bool | str = False\n)\n</code></pre> <p>Wrapper class for functions decorated with @wArgs.</p> <p>Provides access to the underlying function, parser, and CLI execution.</p> <p>Attributes:</p> Name Type Description <code>func</code> <code>Callable[..., Any]</code> <p>The wrapped function.</p> <code>parser</code> <code>ArgumentParser</code> <p>The generated ArgumentParser.</p> <code>prog</code> <code>ArgumentParser</code> <p>Program name override.</p> <code>description</code> <code>ArgumentParser</code> <p>Description override.</p> <p>Initialize the wrapper.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[..., Any]</code> <p>The function to wrap.</p> required <code>prog</code> <code>str | None</code> <p>Program name override.</p> <code>None</code> <code>description</code> <code>str | None</code> <p>Description override.</p> <code>None</code> <code>add_help</code> <code>bool</code> <p>Whether to add -h/--help.</p> <code>True</code> <code>formatter_class</code> <code>str | None</code> <p>Help formatter class name.</p> <code>None</code> <code>completion</code> <code>bool</code> <p>Whether to add --completion flag for shell completion.</p> <code>False</code> <code>prefix</code> <code>bool | str</code> <p>Argument prefixing mode. False (default) = no prefix, True = use function name as prefix, str = use custom prefix string.</p> <code>False</code> Source code in <code>wArgs/decorator.py</code> <pre><code>def __init__(\n    self,\n    func: Callable[..., Any],\n    *,\n    prog: str | None = None,\n    description: str | None = None,\n    add_help: bool = True,\n    formatter_class: str | None = None,\n    completion: bool = False,\n    prefix: bool | str = False,\n) -&gt; None:\n    \"\"\"Initialize the wrapper.\n\n    Args:\n        func: The function to wrap.\n        prog: Program name override.\n        description: Description override.\n        add_help: Whether to add -h/--help.\n        formatter_class: Help formatter class name.\n        completion: Whether to add --completion flag for shell completion.\n        prefix: Argument prefixing mode. False (default) = no prefix, True = use\n            function name as prefix, str = use custom prefix string.\n    \"\"\"\n    self._func = func\n    self._prog = prog\n    self._description = description\n    self._add_help = add_help\n    self._formatter_class = formatter_class\n    self._completion = completion\n    self._prefix = prefix\n    self._parser: ArgumentParser | None = None\n    self._func_info: FunctionInfo | None = None\n    self._parser_config: ParserConfig | None = None\n\n    # Copy function metadata\n    wraps(func)(self)\n</code></pre>"},{"location":"api/decorators/#wArgs.WargsWrapper.func","title":"func  <code>property</code>","text":"<pre><code>func: Callable[..., Any]\n</code></pre> <p>Get the wrapped function.</p>"},{"location":"api/decorators/#wArgs.WargsWrapper.parser","title":"parser  <code>property</code>","text":"<pre><code>parser: ArgumentParser\n</code></pre> <p>Get or build the ArgumentParser (lazy construction).</p>"},{"location":"api/decorators/#wArgs.WargsWrapper.parse_args","title":"parse_args","text":"<pre><code>parse_args(args: list[str] | None = None) -&gt; Namespace\n</code></pre> <p>Parse command-line arguments.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>list[str] | None</code> <p>Arguments to parse. Defaults to sys.argv[1:].</p> <code>None</code> <p>Returns:</p> Type Description <code>Namespace</code> <p>Namespace with parsed arguments.</p> Source code in <code>wArgs/decorator.py</code> <pre><code>def parse_args(self, args: list[str] | None = None) -&gt; Namespace:\n    \"\"\"Parse command-line arguments.\n\n    Args:\n        args: Arguments to parse. Defaults to sys.argv[1:].\n\n    Returns:\n        Namespace with parsed arguments.\n    \"\"\"\n    debug_print(f\"Parsing args: {args}\")\n    result = self.parser.parse_args(args)\n    debug_print(f\"Parsed result: {result}\")\n    return result\n</code></pre>"},{"location":"api/decorators/#wArgs.WargsWrapper.run","title":"run","text":"<pre><code>run(args: list[str] | None = None) -&gt; Any\n</code></pre> <p>Parse arguments and call the function.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>list[str] | None</code> <p>Arguments to parse. Defaults to sys.argv[1:].</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>The return value of the wrapped function.</p> Source code in <code>wArgs/decorator.py</code> <pre><code>def run(self, args: list[str] | None = None) -&gt; Any:\n    \"\"\"Parse arguments and call the function.\n\n    Args:\n        args: Arguments to parse. Defaults to sys.argv[1:].\n\n    Returns:\n        The return value of the wrapped function.\n    \"\"\"\n    # Handle completion before full parsing (to avoid required arg errors)\n    if self._completion:\n        import sys\n\n        check_args = args if args is not None else sys.argv[1:]\n        if \"--completion\" in check_args:\n            idx = check_args.index(\"--completion\")\n            if idx + 1 &lt; len(check_args):\n                shell = check_args[idx + 1]\n                if shell in (\"bash\", \"zsh\", \"fish\"):\n                    from wArgs.completion import generate_completion\n\n                    print(generate_completion(self, shell=shell))\n                    return None\n\n    namespace = self.parse_args(args)\n    kwargs = self._convert_namespace_to_kwargs(namespace)\n    return self._func(**kwargs)\n</code></pre>"},{"location":"api/decorators/#wargsclasswrapper","title":"WargsClassWrapper","text":"<p>Wrapper class for decorated classes.</p>"},{"location":"api/decorators/#wArgs.WargsClassWrapper","title":"wArgs.WargsClassWrapper","text":"<pre><code>WargsClassWrapper(\n    cls: type,\n    *,\n    prog: str | None = None,\n    description: str | None = None,\n    add_help: bool = True,\n    formatter_class: str | None = None,\n    traverse_mro: bool = True,\n    completion: bool = False,\n    prefix: bool | str = False\n)\n</code></pre> <p>Wrapper class for classes decorated with @wArgs.</p> <p>Provides subcommand support where methods become subcommands and init parameters become global options.</p> <p>Attributes:</p> Name Type Description <code>cls</code> <code>type</code> <p>The wrapped class.</p> <code>parser</code> <code>ArgumentParser</code> <p>The generated ArgumentParser with subparsers.</p> <p>Initialize the class wrapper.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>type</code> <p>The class to wrap.</p> required <code>prog</code> <code>str | None</code> <p>Program name override.</p> <code>None</code> <code>description</code> <code>str | None</code> <p>Description override.</p> <code>None</code> <code>add_help</code> <code>bool</code> <p>Whether to add -h/--help.</p> <code>True</code> <code>formatter_class</code> <code>str | None</code> <p>Help formatter class name.</p> <code>None</code> <code>traverse_mro</code> <code>bool</code> <p>Whether to collect init params from parent classes.</p> <code>True</code> <code>completion</code> <code>bool</code> <p>Whether to add --completion flag for shell completion.</p> <code>False</code> <code>prefix</code> <code>bool | str</code> <p>Argument prefixing mode. False (default) = no prefix, True = use class/method names as prefix, str = use custom prefix for init args.</p> <code>False</code> Source code in <code>wArgs/decorator.py</code> <pre><code>def __init__(\n    self,\n    cls: type,\n    *,\n    prog: str | None = None,\n    description: str | None = None,\n    add_help: bool = True,\n    formatter_class: str | None = None,\n    traverse_mro: bool = True,\n    completion: bool = False,\n    prefix: bool | str = False,\n) -&gt; None:\n    \"\"\"Initialize the class wrapper.\n\n    Args:\n        cls: The class to wrap.\n        prog: Program name override.\n        description: Description override.\n        add_help: Whether to add -h/--help.\n        formatter_class: Help formatter class name.\n        traverse_mro: Whether to collect __init__ params from parent classes.\n        completion: Whether to add --completion flag for shell completion.\n        prefix: Argument prefixing mode. False (default) = no prefix, True = use\n            class/method names as prefix, str = use custom prefix for __init__ args.\n    \"\"\"\n    self._cls = cls\n    self._prog = prog\n    self._description = description\n    self._add_help = add_help\n    self._formatter_class = formatter_class\n    self._traverse_mro = traverse_mro\n    self._completion = completion\n    self._prefix = prefix\n    self._parser: ArgumentParser | None = None\n    self._parser_config: ParserConfig | None = None\n    self._methods: dict[str, Any] = {}\n\n    # Copy class metadata\n    self.__name__ = cls.__name__\n    self.__doc__ = cls.__doc__\n    self.__module__ = cls.__module__\n</code></pre>"},{"location":"api/decorators/#wArgs.WargsClassWrapper.cls","title":"cls  <code>property</code>","text":"<pre><code>cls: type\n</code></pre> <p>Get the wrapped class.</p>"},{"location":"api/decorators/#wArgs.WargsClassWrapper.parser","title":"parser  <code>property</code>","text":"<pre><code>parser: ArgumentParser\n</code></pre> <p>Get or build the ArgumentParser (lazy construction).</p>"},{"location":"api/decorators/#wArgs.WargsClassWrapper.parse_args","title":"parse_args","text":"<pre><code>parse_args(args: list[str] | None = None) -&gt; Namespace\n</code></pre> <p>Parse command-line arguments.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>list[str] | None</code> <p>Arguments to parse. Defaults to sys.argv[1:].</p> <code>None</code> <p>Returns:</p> Type Description <code>Namespace</code> <p>Namespace with parsed arguments.</p> Source code in <code>wArgs/decorator.py</code> <pre><code>def parse_args(self, args: list[str] | None = None) -&gt; Namespace:\n    \"\"\"Parse command-line arguments.\n\n    Args:\n        args: Arguments to parse. Defaults to sys.argv[1:].\n\n    Returns:\n        Namespace with parsed arguments.\n    \"\"\"\n    debug_print(f\"Parsing args for class: {args}\")\n    result = self.parser.parse_args(args)\n    debug_print(f\"Parsed result: {result}\")\n    return result\n</code></pre>"},{"location":"api/decorators/#wArgs.WargsClassWrapper.run","title":"run","text":"<pre><code>run(args: list[str] | None = None) -&gt; Any\n</code></pre> <p>Parse arguments and call the appropriate method.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>list[str] | None</code> <p>Arguments to parse. Defaults to sys.argv[1:].</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>The return value of the called method.</p> Source code in <code>wArgs/decorator.py</code> <pre><code>def run(self, args: list[str] | None = None) -&gt; Any:\n    \"\"\"Parse arguments and call the appropriate method.\n\n    Args:\n        args: Arguments to parse. Defaults to sys.argv[1:].\n\n    Returns:\n        The return value of the called method.\n    \"\"\"\n    # Handle completion before full parsing (to avoid required arg errors)\n    if self._completion:\n        import sys\n\n        check_args = args if args is not None else sys.argv[1:]\n        if \"--completion\" in check_args:\n            idx = check_args.index(\"--completion\")\n            if idx + 1 &lt; len(check_args):\n                shell = check_args[idx + 1]\n                if shell in (\"bash\", \"zsh\", \"fish\"):\n                    from wArgs.completion import generate_completion\n\n                    print(generate_completion(self, shell=shell))\n                    return None\n\n    namespace = self.parse_args(args)\n\n    # Get the subcommand (method) name\n    command = getattr(namespace, \"command\", None)\n    if command is None:\n        # No subcommand specified - print help\n        self.parser.print_help()\n        return None\n\n    # Create instance with global options\n    init_kwargs = self._get_init_kwargs(namespace)\n    instance = self._cls(**init_kwargs)\n\n    # Get method kwargs\n    method_kwargs = self._get_method_kwargs(namespace, command)\n\n    # Convert hyphenated command to Python method name\n    method_name = command.replace(\"-\", \"_\")\n\n    # Call the method\n    method = getattr(instance, method_name)\n    return method(**method_kwargs)\n</code></pre>"},{"location":"api/decorators/#arg","title":"Arg","text":"<p>Metadata class for configuring arguments.</p>"},{"location":"api/decorators/#wArgs.Arg","title":"wArgs.Arg  <code>dataclass</code>","text":"<pre><code>Arg(\n    short: str | None = None,\n    long: str | None = None,\n    help: str | None = None,\n    metavar: str | None = None,\n    choices: list[Any] | None = None,\n    action: str | None = None,\n    nargs: str | int | None = None,\n    const: Any = None,\n    default: Any = None,\n    required: bool | None = None,\n    dest: str | None = None,\n    group: str | None = None,\n    mutually_exclusive: str | None = None,\n    positional: bool = False,\n    hidden: bool = False,\n    skip: bool = False,\n    envvar: str | None = None,\n)\n</code></pre> <p>Metadata for configuring a CLI argument.</p> <p>Use with typing.Annotated to customize argument behavior.</p> <p>Attributes:</p> Name Type Description <code>short</code> <code>str | None</code> <p>Short flag (e.g., \"-n\").</p> <code>long</code> <code>str | None</code> <p>Long flag override (default: \"--{param_name}\").</p> <code>help</code> <code>str | None</code> <p>Help text for the argument.</p> <code>metavar</code> <code>str | None</code> <p>Placeholder in help text.</p> <code>choices</code> <code>list[Any] | None</code> <p>List of valid choices.</p> <code>action</code> <code>str | None</code> <p>argparse action (e.g., \"store_true\", \"count\").</p> <code>nargs</code> <code>str | int | None</code> <p>Number of arguments.</p> <code>const</code> <code>Any</code> <p>Constant value for certain actions.</p> <code>default</code> <code>Any</code> <p>Default value override.</p> <code>required</code> <code>bool | None</code> <p>Override required status.</p> <code>dest</code> <code>str | None</code> <p>Destination attribute name.</p> <code>group</code> <code>str | None</code> <p>Argument group name.</p> <code>mutually_exclusive</code> <code>str | None</code> <p>Mutually exclusive group name.</p> <code>positional</code> <code>bool</code> <p>Make this a positional argument.</p> <code>hidden</code> <code>bool</code> <p>Hide from help output.</p> <code>skip</code> <code>bool</code> <p>Skip this parameter entirely.</p> <code>envvar</code> <code>str | None</code> <p>Environment variable to read default from.</p>"},{"location":"api/decorators/#wArgs.Arg.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> <p>Validate Arg configuration.</p>"},{"location":"api/decorators/#usage-examples","title":"Usage Examples","text":""},{"location":"api/decorators/#function-decorator","title":"Function Decorator","text":"<pre><code>from wArgs import wArgs\n\n@wArgs\ndef greet(name: str) -&gt; None:\n    \"\"\"Greet someone.\"\"\"\n    print(f\"Hello, {name}!\")\n\n# Usage\ngreet()  # CLI mode\ngreet(name=\"World\")  # Direct call\ngreet.run([\"--name\", \"World\"])  # Explicit\n</code></pre>"},{"location":"api/decorators/#class-decorator","title":"Class Decorator","text":"<pre><code>from wArgs import wArgs\n\n@wArgs\nclass CLI:\n    \"\"\"My CLI tool.\"\"\"\n\n    def __init__(self, verbose: bool = False) -&gt; None:\n        self.verbose = verbose\n\n    def run(self) -&gt; None:\n        \"\"\"Run the command.\"\"\"\n        print(\"Running...\")\n\n# Usage\nCLI()  # CLI mode\nCLI(verbose=True)  # Direct instantiation\nCLI.run([\"--verbose\", \"run\"])  # Explicit\n</code></pre>"},{"location":"api/decorators/#with-options","title":"With Options","text":"<pre><code>@wArgs(\n    prog=\"myapp\",\n    description=\"My application\",\n    add_help=True,\n    formatter_class=\"RawDescriptionHelpFormatter\",\n)\ndef my_command() -&gt; None:\n    ...\n</code></pre>"},{"location":"api/decorators/#with-arg-metadata","title":"With Arg Metadata","text":"<pre><code>from typing import Annotated\nfrom wArgs import wArgs, Arg\n\n@wArgs\ndef process(\n    input_file: Annotated[str, Arg(\"-i\", help=\"Input file\")],\n    verbose: Annotated[bool, Arg(\"-v\")] = False,\n) -&gt; None:\n    ...\n</code></pre>"},{"location":"api/exceptions/","title":"Exceptions","text":"<p>wArgs defines a hierarchy of exceptions for different error scenarios.</p>"},{"location":"api/exceptions/#exception-hierarchy","title":"Exception Hierarchy","text":"<pre><code>WargsError (base)\n\u251c\u2500\u2500 ConfigurationError  # Invalid decorator config\n\u251c\u2500\u2500 IntrospectionError  # Function analysis errors\n\u2514\u2500\u2500 ConversionError     # Argument conversion errors\n</code></pre>"},{"location":"api/exceptions/#wargserror","title":"WargsError","text":"<p>Base exception for all wArgs errors.</p>"},{"location":"api/exceptions/#wArgs.WargsError","title":"wArgs.WargsError","text":"<pre><code>WargsError(\n    message: str, context: ErrorContext | None = None\n)\n</code></pre> <p>               Bases: <code>Exception</code></p> <p>Base exception for all wArgs errors.</p> <p>All wArgs exceptions inherit from this class, making it easy to catch all wArgs-related errors:</p> <pre><code>try:\n    my_cli()\nexcept WargsError as e:\n    print(f\"CLI error: {e}\")\n</code></pre> <p>Attributes:</p> Name Type Description <code>message</code> <p>The error message.</p> <code>context</code> <p>Optional context about where the error occurred.</p> Source code in <code>wArgs/core/exceptions.py</code> <pre><code>def __init__(\n    self,\n    message: str,\n    context: ErrorContext | None = None,\n) -&gt; None:\n    self.message = message\n    self.context = context\n    super().__init__(self._format_message())\n</code></pre>"},{"location":"api/exceptions/#configurationerror","title":"ConfigurationError","text":"<p>Raised when decorator configuration is invalid.</p>"},{"location":"api/exceptions/#wArgs.ConfigurationError","title":"wArgs.ConfigurationError","text":"<pre><code>ConfigurationError(\n    message: str, context: ErrorContext | None = None\n)\n</code></pre> <p>               Bases: <code>WargsError</code></p> <p>Error in decorator configuration.</p> <p>Raised at import time when the @wargs decorator is misconfigured.</p> <p>Examples:</p> <ul> <li>Invalid decorator options</li> <li>Conflicting argument configurations</li> <li>Unsupported parameter patterns</li> </ul> Example <p>@wargs(invalid_option=True)  # Raises ConfigurationError def my_func():     pass</p> Source code in <code>wArgs/core/exceptions.py</code> <pre><code>def __init__(\n    self,\n    message: str,\n    context: ErrorContext | None = None,\n) -&gt; None:\n    self.message = message\n    self.context = context\n    super().__init__(self._format_message())\n</code></pre>"},{"location":"api/exceptions/#when-its-raised","title":"When It's Raised","text":"<ul> <li>Invalid <code>Arg</code> configuration</li> <li>Conflicting options</li> <li>Invalid decorator arguments</li> </ul>"},{"location":"api/exceptions/#example","title":"Example","text":"<pre><code>from wArgs import wArgs, Arg\nfrom typing import Annotated\n\n# This raises ConfigurationError at import time\n@wArgs\ndef bad_config(\n    name: Annotated[str, Arg(positional=True, short=\"-n\")],  # Can't have both!\n) -&gt; None:\n    pass\n</code></pre>"},{"location":"api/exceptions/#introspectionerror","title":"IntrospectionError","text":"<p>Raised when function introspection fails.</p>"},{"location":"api/exceptions/#wArgs.IntrospectionError","title":"wArgs.IntrospectionError","text":"<pre><code>IntrospectionError(\n    message: str, context: ErrorContext | None = None\n)\n</code></pre> <p>               Bases: <code>WargsError</code></p> <p>Error during function or class introspection.</p> <p>Raised at import time when wArgs cannot analyze a decorated function or class.</p> <p>Examples:</p> <ul> <li>Unsupported type annotation</li> <li>Missing type annotation on required parameter</li> <li>Unparseable docstring format</li> </ul> Example <p>@wargs def my_func(x):  # Missing type annotation     pass</p> Source code in <code>wArgs/core/exceptions.py</code> <pre><code>def __init__(\n    self,\n    message: str,\n    context: ErrorContext | None = None,\n) -&gt; None:\n    self.message = message\n    self.context = context\n    super().__init__(self._format_message())\n</code></pre>"},{"location":"api/exceptions/#when-its-raised_1","title":"When It's Raised","text":"<ul> <li>Unable to inspect function signature</li> <li>Invalid type annotations</li> <li>Unresolvable forward references</li> </ul>"},{"location":"api/exceptions/#example_1","title":"Example","text":"<pre><code>from wArgs import wArgs\n\n# This might raise IntrospectionError\n@wArgs\ndef problematic(x: \"NonExistentType\") -&gt; None:\n    pass\n</code></pre>"},{"location":"api/exceptions/#conversionerror","title":"ConversionError","text":"<p>Raised when argument conversion fails.</p>"},{"location":"api/exceptions/#wArgs.ConversionError","title":"wArgs.ConversionError","text":"<pre><code>ConversionError(\n    message: str,\n    value: str | None = None,\n    target_type: type | None = None,\n    context: ErrorContext | None = None,\n)\n</code></pre> <p>               Bases: <code>WargsError</code></p> <p>Error converting an argument value.</p> <p>Raised at runtime when a command-line argument cannot be converted to the expected type.</p> <p>Examples:</p> <ul> <li>Invalid integer format</li> <li>File path that doesn't exist</li> <li>Custom converter failure</li> </ul> Example Source code in <code>wArgs/core/exceptions.py</code> <pre><code>def __init__(\n    self,\n    message: str,\n    value: str | None = None,\n    target_type: type | None = None,\n    context: ErrorContext | None = None,\n) -&gt; None:\n    self.value = value\n    self.target_type = target_type\n    super().__init__(message, context)\n</code></pre>"},{"location":"api/exceptions/#wArgs.ConversionError--cli-my_script-count-abc","title":"CLI: my_script --count abc","text":""},{"location":"api/exceptions/#wArgs.ConversionError--raises-conversionerrorcannot-convert-abc-to-int","title":"Raises: ConversionError(\"Cannot convert 'abc' to int\")","text":""},{"location":"api/exceptions/#when-its-raised_2","title":"When It's Raised","text":"<ul> <li>Invalid value for type</li> <li>Custom converter failure</li> <li>Type coercion failure</li> </ul>"},{"location":"api/exceptions/#example_2","title":"Example","text":"<pre><code>from wArgs import wArgs\nfrom datetime import datetime\n\n@wArgs\ndef schedule(when: datetime) -&gt; None:\n    print(f\"Scheduled: {when}\")\n\n# This raises ConversionError at runtime\nschedule.run([\"--when\", \"not-a-date\"])\n# ConversionError: Cannot convert 'not-a-date' to datetime.\n</code></pre>"},{"location":"api/exceptions/#errorcontext","title":"ErrorContext","text":"<p>Context information for exceptions.</p>"},{"location":"api/exceptions/#wArgs.ErrorContext","title":"wArgs.ErrorContext  <code>dataclass</code>","text":"<pre><code>ErrorContext(\n    function_name: str,\n    parameter_name: str | None = None,\n    source_file: str | None = None,\n    line_number: int | None = None,\n)\n</code></pre> <p>Context information for error messages.</p> <p>Provides source location and parameter context for debugging.</p>"},{"location":"api/exceptions/#wArgs.ErrorContext.format_context","title":"format_context","text":"<pre><code>format_context() -&gt; str\n</code></pre> <p>Format the full context for display.</p> Source code in <code>wArgs/core/exceptions.py</code> <pre><code>def format_context(self) -&gt; str:\n    \"\"\"Format the full context for display.\"\"\"\n    parts = [f\"Function: {self.function_name}\"]\n    if self.parameter_name:\n        parts.append(f\"Parameter: {self.parameter_name}\")\n    parts.append(f\"Location: {self.format_location()}\")\n    return \"\\n  \".join(parts)\n</code></pre>"},{"location":"api/exceptions/#wArgs.ErrorContext.format_location","title":"format_location","text":"<pre><code>format_location() -&gt; str\n</code></pre> <p>Format the source location for display.</p> Source code in <code>wArgs/core/exceptions.py</code> <pre><code>def format_location(self) -&gt; str:\n    \"\"\"Format the source location for display.\"\"\"\n    if self.source_file and self.line_number:\n        return f\"{self.source_file}:{self.line_number}\"\n    elif self.source_file:\n        return self.source_file\n    return \"&lt;unknown&gt;\"\n</code></pre>"},{"location":"api/exceptions/#handling-exceptions","title":"Handling Exceptions","text":"<pre><code>from wArgs import wArgs, WargsError, ConversionError\nimport sys\n\n@wArgs\ndef my_command(count: int) -&gt; None:\n    print(f\"Count: {count}\")\n\ntry:\n    my_command()\nexcept ConversionError as e:\n    print(f\"Invalid argument: {e}\", file=sys.stderr)\n    sys.exit(1)\nexcept WargsError as e:\n    print(f\"CLI error: {e}\", file=sys.stderr)\n    sys.exit(1)\n</code></pre>"},{"location":"api/exceptions/#best-practices","title":"Best Practices","text":"<ol> <li>Catch specific exceptions when you need specific handling</li> <li>Catch WargsError as a fallback for all wArgs errors</li> <li>Let ConfigurationError propagate - it indicates a bug in your code</li> <li>Handle ConversionError for user-friendly error messages</li> </ol>"},{"location":"api/types/","title":"Types","text":""},{"location":"api/types/#configuration-types","title":"Configuration Types","text":""},{"location":"api/types/#parserconfig","title":"ParserConfig","text":"<p>Configuration for an ArgumentParser.</p>"},{"location":"api/types/#wArgs.core.config.ParserConfig","title":"wArgs.core.config.ParserConfig  <code>dataclass</code>","text":"<pre><code>ParserConfig(\n    prog: str | None = None,\n    description: str | None = None,\n    epilog: str | None = None,\n    arguments: list[ArgumentConfig] = list(),\n    subcommands: dict[str, ParserConfig] = dict(),\n    add_help: bool = True,\n    formatter_class: str | None = None,\n    dict_expansions: dict[str, DictExpansion] = dict(),\n)\n</code></pre> <p>Configuration for an ArgumentParser.</p> <p>Contains all the information needed to build an ArgumentParser.</p> <p>Attributes:</p> Name Type Description <code>prog</code> <code>str | None</code> <p>Program name.</p> <code>description</code> <code>str | None</code> <p>Parser description.</p> <code>epilog</code> <code>str | None</code> <p>Text to display after argument help.</p> <code>arguments</code> <code>list[ArgumentConfig]</code> <p>List of argument configurations.</p> <code>subcommands</code> <code>dict[str, ParserConfig]</code> <p>Mapping of subcommand names to their ParserConfigs.</p> <code>add_help</code> <code>bool</code> <p>Whether to add -h/--help option.</p> <code>formatter_class</code> <code>str | None</code> <p>Help formatter class name.</p> <code>dict_expansions</code> <code>dict[str, DictExpansion]</code> <p>Dict parameters expanded into multiple args.</p>"},{"location":"api/types/#argumentconfig","title":"ArgumentConfig","text":"<p>Configuration for a single CLI argument.</p>"},{"location":"api/types/#wArgs.core.config.ArgumentConfig","title":"wArgs.core.config.ArgumentConfig  <code>dataclass</code>","text":"<pre><code>ArgumentConfig(\n    name: str,\n    flags: list[str] = list(),\n    type: Callable[[str], Any] | None = None,\n    default: Any = None,\n    required: bool = False,\n    help: str | None = None,\n    choices: list[Any] | None = None,\n    action: str | None = None,\n    nargs: str | int | None = None,\n    metavar: str | None = None,\n    dest: str | None = None,\n    group: str | None = None,\n    mutually_exclusive: str | None = None,\n    positional: bool = False,\n    hidden: bool = False,\n    skip: bool = False,\n)\n</code></pre> <p>Configuration for a single CLI argument.</p> <p>Represents the argparse configuration for one parameter.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The parameter name (used as dest).</p> <code>flags</code> <code>list[str]</code> <p>List of flags (e.g., ['--name', '-n']).</p> <code>type</code> <code>Callable[[str], Any] | None</code> <p>Type converter function.</p> <code>default</code> <code>Any</code> <p>Default value.</p> <code>required</code> <code>bool</code> <p>Whether the argument is required.</p> <code>help</code> <code>str | None</code> <p>Help text for the argument.</p> <code>choices</code> <code>list[Any] | None</code> <p>List of valid choices.</p> <code>action</code> <code>str | None</code> <p>argparse action (e.g., 'store_true').</p> <code>nargs</code> <code>str | int | None</code> <p>Number of arguments (e.g., '*', '+', '?', int).</p> <code>metavar</code> <code>str | None</code> <p>Placeholder in help text.</p> <code>dest</code> <code>str | None</code> <p>Destination attribute name.</p> <code>group</code> <code>str | None</code> <p>Argument group name.</p> <code>mutually_exclusive</code> <code>str | None</code> <p>Mutually exclusive group name.</p> <code>positional</code> <code>bool</code> <p>Whether this is a positional argument.</p> <code>hidden</code> <code>bool</code> <p>Whether to hide from help.</p> <code>skip</code> <code>bool</code> <p>Whether to skip this argument entirely.</p>"},{"location":"api/types/#parameterinfo","title":"ParameterInfo","text":"<p>Information about a function parameter.</p>"},{"location":"api/types/#wArgs.core.config.ParameterInfo","title":"wArgs.core.config.ParameterInfo  <code>dataclass</code>","text":"<pre><code>ParameterInfo(\n    name: str,\n    annotation: Any = None,\n    type_info: TypeInfo | None = None,\n    default: Any = None,\n    has_default: bool = False,\n    kind: ParameterKind = POSITIONAL_OR_KEYWORD,\n    description: str | None = None,\n)\n</code></pre> <p>Information about a function parameter.</p> <p>Extracted from function signature, type hints, and docstrings.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Parameter name.</p> <code>annotation</code> <code>Any</code> <p>The raw type annotation (may be None).</p> <code>type_info</code> <code>TypeInfo | None</code> <p>Resolved type information.</p> <code>default</code> <code>Any</code> <p>Default value (MISSING if no default).</p> <code>has_default</code> <code>bool</code> <p>Whether the parameter has a default value.</p> <code>kind</code> <code>ParameterKind</code> <p>The parameter kind (positional, keyword, etc.).</p> <code>description</code> <code>str | None</code> <p>Help text from docstring.</p>"},{"location":"api/types/#functioninfo","title":"FunctionInfo","text":"<p>Information about a function.</p>"},{"location":"api/types/#wArgs.core.config.FunctionInfo","title":"wArgs.core.config.FunctionInfo  <code>dataclass</code>","text":"<pre><code>FunctionInfo(\n    name: str,\n    qualname: str,\n    description: str | None = None,\n    parameters: list[ParameterInfo] = list(),\n    return_type: Any = None,\n    module: str | None = None,\n    source_file: str | None = None,\n    line_number: int | None = None,\n)\n</code></pre> <p>Information about a function or method.</p> <p>Contains all metadata extracted during introspection.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Function name.</p> <code>qualname</code> <code>str</code> <p>Qualified name (includes class name for methods).</p> <code>description</code> <code>str | None</code> <p>Function description from docstring.</p> <code>parameters</code> <code>list[ParameterInfo]</code> <p>List of parameter information.</p> <code>return_type</code> <code>Any</code> <p>Return type annotation.</p> <code>module</code> <code>str | None</code> <p>Module where the function is defined.</p> <code>source_file</code> <code>str | None</code> <p>Source file path.</p> <code>line_number</code> <code>int | None</code> <p>Line number in source file.</p>"},{"location":"api/types/#typeinfo","title":"TypeInfo","text":"<p>Information about a resolved type.</p>"},{"location":"api/types/#wArgs.core.config.TypeInfo","title":"wArgs.core.config.TypeInfo  <code>dataclass</code>","text":"<pre><code>TypeInfo(\n    origin: type | None = None,\n    args: tuple[Any, ...] = tuple(),\n    is_optional: bool = False,\n    is_literal: bool = False,\n    literal_values: tuple[Any, ...] = tuple(),\n    is_enum: bool = False,\n    enum_class: type[Enum] | None = None,\n    converter: Callable[[str], Any] | None = None,\n)\n</code></pre> <p>Information about a resolved type annotation.</p> <p>Attributes:</p> Name Type Description <code>origin</code> <code>type | None</code> <p>The origin type (e.g., list for list[str]).</p> <code>args</code> <code>tuple[Any, ...]</code> <p>Type arguments (e.g., (str,) for list[str]).</p> <code>is_optional</code> <code>bool</code> <p>Whether the type is Optional (allows None).</p> <code>is_literal</code> <code>bool</code> <p>Whether the type is a Literal.</p> <code>literal_values</code> <code>tuple[Any, ...]</code> <p>Values if this is a Literal type.</p> <code>is_enum</code> <code>bool</code> <p>Whether the type is an Enum subclass.</p> <code>enum_class</code> <code>type[Enum] | None</code> <p>The Enum class if is_enum is True.</p> <code>converter</code> <code>Callable[[str], Any] | None</code> <p>Function to convert string to this type.</p>"},{"location":"api/types/#converter-types","title":"Converter Types","text":""},{"location":"api/types/#converterregistry","title":"ConverterRegistry","text":"<p>Registry for type converters.</p>"},{"location":"api/types/#wArgs.ConverterRegistry","title":"wArgs.ConverterRegistry","text":"<pre><code>ConverterRegistry()\n</code></pre> <p>Registry for type converters.</p> <p>Converters are functions that take a string and return a typed value. The registry supports: - Explicit registration via register() or @converter decorator - Inheritance-based lookup (if no exact match, check base classes) - Entry point discovery for plugins</p> Example <p>registry = ConverterRegistry()</p> <p>@registry.converter(MyClass) def convert_myclass(value: str) -&gt; MyClass:     return MyClass.from_string(value)</p> <p>Initialize an empty registry.</p> Source code in <code>wArgs/converters/registry.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize an empty registry.\"\"\"\n    self._converters: dict[type, Converter] = {}\n    self._plugins_loaded = False\n</code></pre>"},{"location":"api/types/#wArgs.ConverterRegistry--or-register-directly","title":"Or register directly","text":"<p>registry.register(MyClass, MyClass.from_string)</p>"},{"location":"api/types/#wArgs.ConverterRegistry--lookup","title":"Lookup","text":"<p>converter = registry.get(MyClass) result = converter(\"some value\")</p>"},{"location":"api/types/#wArgs.ConverterRegistry.register","title":"register","text":"<pre><code>register(type_: type, converter: Converter) -&gt; None\n</code></pre> <p>Register a converter for a type.</p> <p>If a converter is already registered for this type, it will be replaced (last-wins semantics).</p> <p>Parameters:</p> Name Type Description Default <code>type_</code> <code>type</code> <p>The type to register the converter for.</p> required <code>converter</code> <code>Converter</code> <p>A callable that takes a string and returns the type.</p> required Source code in <code>wArgs/converters/registry.py</code> <pre><code>def register(self, type_: type, converter: Converter) -&gt; None:\n    \"\"\"Register a converter for a type.\n\n    If a converter is already registered for this type, it will be\n    replaced (last-wins semantics).\n\n    Args:\n        type_: The type to register the converter for.\n        converter: A callable that takes a string and returns the type.\n    \"\"\"\n    self._converters[type_] = converter\n</code></pre>"},{"location":"api/types/#wArgs.ConverterRegistry.converter","title":"converter","text":"<pre><code>converter(\n    type_: type[T],\n) -&gt; Callable[[Callable[[str], T]], Callable[[str], T]]\n</code></pre> <p>Decorator to register a converter function.</p> <p>Parameters:</p> Name Type Description Default <code>type_</code> <code>type[T]</code> <p>The type to register the converter for.</p> required <p>Returns:</p> Type Description <code>Callable[[Callable[[str], T]], Callable[[str], T]]</code> <p>A decorator that registers the function.</p> Example <p>@registry.converter(MyClass) def convert_myclass(value: str) -&gt; MyClass:     return MyClass(value)</p> Source code in <code>wArgs/converters/registry.py</code> <pre><code>def converter(\n    self, type_: type[T]\n) -&gt; Callable[[Callable[[str], T]], Callable[[str], T]]:\n    \"\"\"Decorator to register a converter function.\n\n    Args:\n        type_: The type to register the converter for.\n\n    Returns:\n        A decorator that registers the function.\n\n    Example:\n        @registry.converter(MyClass)\n        def convert_myclass(value: str) -&gt; MyClass:\n            return MyClass(value)\n    \"\"\"\n\n    def decorator(func: Callable[[str], T]) -&gt; Callable[[str], T]:\n        self.register(type_, func)\n        return func\n\n    return decorator\n</code></pre>"},{"location":"api/types/#wArgs.ConverterRegistry.get","title":"get","text":"<pre><code>get(\n    type_: type, *, check_inheritance: bool = True\n) -&gt; Converter | None\n</code></pre> <p>Look up a converter for a type.</p> <p>Parameters:</p> Name Type Description Default <code>type_</code> <code>type</code> <p>The type to look up.</p> required <code>check_inheritance</code> <code>bool</code> <p>If True, check base classes if no exact match.</p> <code>True</code> <p>Returns:</p> Type Description <code>Converter | None</code> <p>The converter function, or None if not found.</p> Source code in <code>wArgs/converters/registry.py</code> <pre><code>def get(self, type_: type, *, check_inheritance: bool = True) -&gt; Converter | None:\n    \"\"\"Look up a converter for a type.\n\n    Args:\n        type_: The type to look up.\n        check_inheritance: If True, check base classes if no exact match.\n\n    Returns:\n        The converter function, or None if not found.\n    \"\"\"\n    # Exact match first\n    if type_ in self._converters:\n        return self._converters[type_]\n\n    # Check inheritance chain\n    if check_inheritance:\n        for base in type_.__mro__[1:]:  # Skip the type itself\n            if base in self._converters:\n                return self._converters[base]\n\n    return None\n</code></pre>"},{"location":"api/types/#wArgs.ConverterRegistry.has","title":"has","text":"<pre><code>has(type_: type) -&gt; bool\n</code></pre> <p>Check if a converter is registered for a type.</p> <p>Parameters:</p> Name Type Description Default <code>type_</code> <code>type</code> <p>The type to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if a converter is registered (including via inheritance).</p> Source code in <code>wArgs/converters/registry.py</code> <pre><code>def has(self, type_: type) -&gt; bool:\n    \"\"\"Check if a converter is registered for a type.\n\n    Args:\n        type_: The type to check.\n\n    Returns:\n        True if a converter is registered (including via inheritance).\n    \"\"\"\n    return self.get(type_) is not None\n</code></pre>"},{"location":"api/types/#wArgs.ConverterRegistry.unregister","title":"unregister","text":"<pre><code>unregister(type_: type) -&gt; bool\n</code></pre> <p>Remove a converter registration.</p> <p>Parameters:</p> Name Type Description Default <code>type_</code> <code>type</code> <p>The type to unregister.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if a converter was removed, False if none was registered.</p> Source code in <code>wArgs/converters/registry.py</code> <pre><code>def unregister(self, type_: type) -&gt; bool:\n    \"\"\"Remove a converter registration.\n\n    Args:\n        type_: The type to unregister.\n\n    Returns:\n        True if a converter was removed, False if none was registered.\n    \"\"\"\n    if type_ in self._converters:\n        del self._converters[type_]\n        return True\n    return False\n</code></pre>"},{"location":"api/types/#wArgs.ConverterRegistry.clear","title":"clear","text":"<pre><code>clear() -&gt; None\n</code></pre> <p>Remove all registered converters.</p> Source code in <code>wArgs/converters/registry.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Remove all registered converters.\"\"\"\n    self._converters.clear()\n    self._plugins_loaded = False\n</code></pre>"},{"location":"api/types/#wArgs.ConverterRegistry.load_entry_points","title":"load_entry_points","text":"<pre><code>load_entry_points(group: str = 'wargs.converters') -&gt; int\n</code></pre> <p>Load converters from entry points.</p> <p>Entry points should be functions that take a ConverterRegistry and register converters on it.</p> <p>Parameters:</p> Name Type Description Default <code>group</code> <code>str</code> <p>The entry point group name.</p> <code>'wargs.converters'</code> <p>Returns:</p> Type Description <code>int</code> <p>Number of entry points loaded.</p> <p>Example pyproject.toml:     [project.entry-points.\"wargs.converters\"]     mypackage = \"mypackage.converters:register_converters\"</p> Example register function <p>def register_converters(registry: ConverterRegistry) -&gt; None:     @registry.converter(MyType)     def convert_mytype(value: str) -&gt; MyType:         return MyType(value)</p> Source code in <code>wArgs/converters/registry.py</code> <pre><code>def load_entry_points(self, group: str = \"wargs.converters\") -&gt; int:\n    \"\"\"Load converters from entry points.\n\n    Entry points should be functions that take a ConverterRegistry\n    and register converters on it.\n\n    Args:\n        group: The entry point group name.\n\n    Returns:\n        Number of entry points loaded.\n\n    Example pyproject.toml:\n        [project.entry-points.\"wargs.converters\"]\n        mypackage = \"mypackage.converters:register_converters\"\n\n    Example register function:\n        def register_converters(registry: ConverterRegistry) -&gt; None:\n            @registry.converter(MyType)\n            def convert_mytype(value: str) -&gt; MyType:\n                return MyType(value)\n    \"\"\"\n    if self._plugins_loaded:\n        return 0\n\n    count = 0\n    eps = entry_points(group=group)\n\n    for ep in eps:\n        try:\n            register_func = ep.load()\n            register_func(self)\n            count += 1\n        except Exception:\n            # Silently skip failed entry points\n            # In a production system, we might want to log this\n            pass\n\n    self._plugins_loaded = True\n    return count\n</code></pre>"},{"location":"api/types/#converter-decorator","title":"converter decorator","text":"<p>Decorator to register a converter on the default registry.</p>"},{"location":"api/types/#wArgs.converters.registry.converter","title":"wArgs.converters.registry.converter","text":"<pre><code>converter(\n    type_: type[T],\n) -&gt; Callable[[Callable[[str], T]], Callable[[str], T]]\n</code></pre> <p>Decorator to register a converter on the default registry.</p> <p>This is a convenience function that delegates to the default registry.</p> <p>Parameters:</p> Name Type Description Default <code>type_</code> <code>type[T]</code> <p>The type to register the converter for.</p> required <p>Returns:</p> Type Description <code>Callable[[Callable[[str], T]], Callable[[str], T]]</code> <p>A decorator that registers the function.</p> Example <p>from wargs import converter</p> <p>@converter(MyClass) def convert_myclass(value: str) -&gt; MyClass:     return MyClass(value)</p> Source code in <code>wArgs/converters/registry.py</code> <pre><code>def converter(type_: type[T]) -&gt; Callable[[Callable[[str], T]], Callable[[str], T]]:\n    \"\"\"Decorator to register a converter on the default registry.\n\n    This is a convenience function that delegates to the default registry.\n\n    Args:\n        type_: The type to register the converter for.\n\n    Returns:\n        A decorator that registers the function.\n\n    Example:\n        from wargs import converter\n\n        @converter(MyClass)\n        def convert_myclass(value: str) -&gt; MyClass:\n            return MyClass(value)\n    \"\"\"\n    return get_default_registry().converter(type_)\n</code></pre>"},{"location":"api/types/#get_default_registry","title":"get_default_registry","text":"<p>Get the default global converter registry.</p>"},{"location":"api/types/#wArgs.converters.registry.get_default_registry","title":"wArgs.converters.registry.get_default_registry","text":"<pre><code>get_default_registry() -&gt; ConverterRegistry\n</code></pre> <p>Get the default global converter registry.</p> <p>Returns:</p> Type Description <code>ConverterRegistry</code> <p>The default ConverterRegistry instance.</p> Source code in <code>wArgs/converters/registry.py</code> <pre><code>def get_default_registry() -&gt; ConverterRegistry:\n    \"\"\"Get the default global converter registry.\n\n    Returns:\n        The default ConverterRegistry instance.\n    \"\"\"\n    global _default_registry\n    if _default_registry is None:\n        _default_registry = ConverterRegistry()\n    return _default_registry\n</code></pre>"},{"location":"api/types/#built-in-converters","title":"Built-in Converters","text":"<p>wArgs includes converters for common types:</p> Type Converter Format <code>datetime</code> <code>convert_datetime</code> ISO 8601 <code>date</code> <code>convert_date</code> YYYY-MM-DD <code>time</code> <code>convert_time</code> HH:MM:SS <code>UUID</code> <code>convert_uuid</code> Standard UUID <code>Decimal</code> <code>convert_decimal</code> Decimal string <code>Path</code> <code>convert_path</code> File path <code>complex</code> <code>convert_complex</code> a+bj <code>Fraction</code> <code>convert_fraction</code> a/b"},{"location":"api/types/#registering-built-in-converters","title":"Registering Built-in Converters","text":"<pre><code>from wargs.converters.builtin import register_builtin_converters\n\n# Register on default registry\nregister_builtin_converters()\n\n# Or on custom registry\nfrom wArgs import ConverterRegistry\nregistry = ConverterRegistry()\nregister_builtin_converters(registry)\n</code></pre>"},{"location":"api/types/#custom-converter-example","title":"Custom Converter Example","text":"<pre><code>from wArgs import converter\n\nclass EmailAddress:\n    def __init__(self, address: str) -&gt; None:\n        if \"@\" not in address:\n            raise ValueError(\"Invalid email\")\n        self.address = address\n\n@converter(EmailAddress)\ndef convert_email(value: str) -&gt; EmailAddress:\n    return EmailAddress(value)\n</code></pre>"},{"location":"api/utilities/","title":"Utilities","text":""},{"location":"api/utilities/#explain","title":"explain","text":"<p>Get a human-readable explanation of a wargs-decorated function.</p>"},{"location":"api/utilities/#wArgs.utilities.explain","title":"wArgs.utilities.explain","text":"<pre><code>explain(\n    func: (\n        Callable[..., Any]\n        | WargsWrapper\n        | WargsClassWrapper\n    ),\n    *,\n    verbose: bool = False\n) -&gt; str\n</code></pre> <p>Return a human-readable explanation of a wargs-decorated function.</p> <p>This is useful for debugging and understanding how wargs interprets your function signature and docstring.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[..., Any] | WargsWrapper | WargsClassWrapper</code> <p>A wargs-decorated function or class.</p> required <code>verbose</code> <code>bool</code> <p>If True, include additional details.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>Human-readable string describing the configuration.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If func is not a wargs-decorated function.</p> Example <p>@wargs def greet(name: str, count: int = 1):     '''Greet someone.</p> <pre><code>Args:\n    name: The person to greet.\n    count: Number of greetings.\n'''\npass\n</code></pre> <p>print(explain(greet))</p> Source code in <code>wArgs/utilities.py</code> <pre><code>def explain(\n    func: Callable[..., Any] | WargsWrapper | WargsClassWrapper,\n    *,\n    verbose: bool = False,\n) -&gt; str:\n    \"\"\"Return a human-readable explanation of a wargs-decorated function.\n\n    This is useful for debugging and understanding how wargs interprets\n    your function signature and docstring.\n\n    Args:\n        func: A wargs-decorated function or class.\n        verbose: If True, include additional details.\n\n    Returns:\n        Human-readable string describing the configuration.\n\n    Raises:\n        TypeError: If func is not a wargs-decorated function.\n\n    Example:\n        @wargs\n        def greet(name: str, count: int = 1):\n            '''Greet someone.\n\n            Args:\n                name: The person to greet.\n                count: Number of greetings.\n            '''\n            pass\n\n        print(explain(greet))\n    \"\"\"\n    from wArgs.decorator import WargsClassWrapper\n\n    wrapper = _get_wrapper(func)\n    config = get_config(func)\n\n    lines: list[str] = []\n\n    # Header\n    if isinstance(wrapper, WargsClassWrapper):\n        lines.append(f\"Class: {wrapper._cls.__name__}\")\n        lines.append(\"Type: Subcommand-based CLI\")\n    else:\n        lines.append(f\"Function: {wrapper._func.__name__}\")\n        lines.append(\"Type: Single-command CLI\")\n\n    # Program info\n    if config.prog:\n        lines.append(f\"Program: {config.prog}\")\n    if config.description:\n        lines.append(f\"Description: {config.description}\")\n\n    lines.append(\"\")\n\n    # Arguments\n    if config.arguments:\n        lines.append(\"Arguments:\")\n        for arg in config.arguments:\n            if arg.skip:\n                continue\n\n            # Build flag string\n            if arg.positional:\n                flag_str = arg.name\n            else:\n                flag_str = \", \".join(arg.flags) if arg.flags else f\"--{arg.name}\"\n\n            # Build type string\n            type_str = \"\"\n            if arg.type:\n                type_name = getattr(arg.type, \"__name__\", str(arg.type))\n                type_str = f\" ({type_name})\"\n\n            # Build required/default string\n            req_str = \"\"\n            if arg.required:\n                req_str = \" [required]\"\n            elif arg.default is not None:\n                req_str = f\" [default: {arg.default!r}]\"\n\n            # Build choices string\n            choice_str = \"\"\n            if arg.choices:\n                choice_str = f\" choices: {arg.choices}\"\n\n            lines.append(f\"  {flag_str}{type_str}{req_str}{choice_str}\")\n\n            if verbose and arg.help:\n                lines.append(f\"    Help: {arg.help}\")\n\n    # Subcommands\n    if config.subcommands:\n        lines.append(\"\")\n        lines.append(\"Subcommands:\")\n        for name, subconfig in config.subcommands.items():\n            desc = subconfig.description or \"\"\n            if desc and len(desc) &gt; 60:\n                desc = desc[:57] + \"...\"\n            lines.append(f\"  {name}: {desc}\")\n\n            if verbose and subconfig.arguments:\n                for arg in subconfig.arguments:\n                    if arg.skip:\n                        continue\n                    flag_str = \", \".join(arg.flags) if arg.flags else arg.name\n                    lines.append(f\"    {flag_str}\")\n\n    return \"\\n\".join(lines)\n</code></pre>"},{"location":"api/utilities/#example","title":"Example","text":"<pre><code>from wArgs import wArgs, explain\n\n@wArgs\ndef greet(name: str, count: int = 1) -&gt; None:\n    \"\"\"Greet someone.\n\n    Args:\n        name: Person to greet\n        count: Number of times\n    \"\"\"\n    pass\n\nprint(explain(greet))\n</code></pre> <p>Output:</p> <pre><code>Function: greet\nType: Single-command CLI\n\nArguments:\n  --name (str) [required]\n  --count (int) [default: 1]\n</code></pre> <p>With <code>verbose=True</code>:</p> <pre><code>print(explain(greet, verbose=True))\n</code></pre> <pre><code>Function: greet\nType: Single-command CLI\n\nArguments:\n  --name (str) [required]\n    Help: Person to greet\n  --count (int) [default: 1]\n    Help: Number of times\n</code></pre>"},{"location":"api/utilities/#get_parser","title":"get_parser","text":"<p>Get the ArgumentParser for a wargs-decorated function.</p>"},{"location":"api/utilities/#wArgs.utilities.get_parser","title":"wArgs.utilities.get_parser","text":"<pre><code>get_parser(\n    func: (\n        Callable[..., Any]\n        | WargsWrapper\n        | WargsClassWrapper\n    ),\n) -&gt; ArgumentParser\n</code></pre> <p>Get the ArgumentParser for a wargs-decorated function.</p> <p>This is useful for testing or extending the parser with additional arguments not derived from the function signature.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[..., Any] | WargsWrapper | WargsClassWrapper</code> <p>A wargs-decorated function or class.</p> required <p>Returns:</p> Type Description <code>ArgumentParser</code> <p>The ArgumentParser instance.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If func is not a wargs-decorated function.</p> Example <p>@wargs def greet(name: str):     pass</p> <p>parser = get_parser(greet) parser.add_argument(\"--extra\", help=\"Extra option\")</p> Source code in <code>wArgs/utilities.py</code> <pre><code>def get_parser(\n    func: Callable[..., Any] | WargsWrapper | WargsClassWrapper,\n) -&gt; ArgumentParser:\n    \"\"\"Get the ArgumentParser for a wargs-decorated function.\n\n    This is useful for testing or extending the parser with additional\n    arguments not derived from the function signature.\n\n    Args:\n        func: A wargs-decorated function or class.\n\n    Returns:\n        The ArgumentParser instance.\n\n    Raises:\n        TypeError: If func is not a wargs-decorated function.\n\n    Example:\n        @wargs\n        def greet(name: str):\n            pass\n\n        parser = get_parser(greet)\n        parser.add_argument(\"--extra\", help=\"Extra option\")\n    \"\"\"\n    wrapper = _get_wrapper(func)\n    return wrapper.parser\n</code></pre>"},{"location":"api/utilities/#example_1","title":"Example","text":"<pre><code>from wArgs import wArgs, get_parser\n\n@wArgs\ndef my_command(name: str) -&gt; None:\n    pass\n\nparser = get_parser(my_command)\n\n# Extend the parser\nparser.add_argument(\"--extra\", help=\"Extra option\")\n\n# Use the parser directly\nargs = parser.parse_args([\"--name\", \"test\", \"--extra\", \"value\"])\n</code></pre>"},{"location":"api/utilities/#get_config","title":"get_config","text":"<p>Get the ParserConfig for a wargs-decorated function.</p>"},{"location":"api/utilities/#wArgs.utilities.get_config","title":"wArgs.utilities.get_config","text":"<pre><code>get_config(\n    func: (\n        Callable[..., Any]\n        | WargsWrapper\n        | WargsClassWrapper\n    ),\n) -&gt; ParserConfig\n</code></pre> <p>Get the ParserConfig for a wargs-decorated function.</p> <p>This returns the internal configuration used to build the parser, useful for debugging or advanced customization.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[..., Any] | WargsWrapper | WargsClassWrapper</code> <p>A wargs-decorated function or class.</p> required <p>Returns:</p> Type Description <code>ParserConfig</code> <p>The ParserConfig instance.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If func is not a wargs-decorated function.</p> Example <p>@wargs def greet(name: str):     pass</p> <p>config = get_config(greet) for arg in config.arguments:     print(f\"{arg.name}: {arg.flags}\")</p> Source code in <code>wArgs/utilities.py</code> <pre><code>def get_config(\n    func: Callable[..., Any] | WargsWrapper | WargsClassWrapper,\n) -&gt; ParserConfig:\n    \"\"\"Get the ParserConfig for a wargs-decorated function.\n\n    This returns the internal configuration used to build the parser,\n    useful for debugging or advanced customization.\n\n    Args:\n        func: A wargs-decorated function or class.\n\n    Returns:\n        The ParserConfig instance.\n\n    Raises:\n        TypeError: If func is not a wargs-decorated function.\n\n    Example:\n        @wargs\n        def greet(name: str):\n            pass\n\n        config = get_config(greet)\n        for arg in config.arguments:\n            print(f\"{arg.name}: {arg.flags}\")\n    \"\"\"\n    wrapper = _get_wrapper(func)\n\n    # Ensure parser is built (which also builds config)\n    _ = wrapper.parser\n\n    # Access the internal config\n    return wrapper._parser_config  # type: ignore[return-value]\n</code></pre>"},{"location":"api/utilities/#example_2","title":"Example","text":"<pre><code>from wArgs import wArgs, get_config\n\n@wArgs\ndef my_command(name: str, count: int = 1) -&gt; None:\n    pass\n\nconfig = get_config(my_command)\n\n# Inspect arguments\nfor arg in config.arguments:\n    print(f\"{arg.name}: flags={arg.flags}, required={arg.required}\")\n</code></pre>"},{"location":"api/utilities/#debug-utilities","title":"Debug Utilities","text":""},{"location":"api/utilities/#is_debug_enabled","title":"is_debug_enabled","text":"<p>Check if WARGS_DEBUG environment variable is set.</p>"},{"location":"api/utilities/#wArgs.utilities.is_debug_enabled","title":"wArgs.utilities.is_debug_enabled","text":"<pre><code>is_debug_enabled() -&gt; bool\n</code></pre> <p>Check if WARGS_DEBUG environment variable is set.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if WARGS_DEBUG is set to a truthy value (1, true, yes, on).</p> Source code in <code>wArgs/utilities.py</code> <pre><code>def is_debug_enabled() -&gt; bool:\n    \"\"\"Check if WARGS_DEBUG environment variable is set.\n\n    Returns:\n        True if WARGS_DEBUG is set to a truthy value (1, true, yes, on).\n    \"\"\"\n    value = os.environ.get(WARGS_DEBUG_VAR, \"\").lower()\n    return value in (\"1\", \"true\", \"yes\", \"on\")\n</code></pre>"},{"location":"api/utilities/#debug_print","title":"debug_print","text":"<p>Print debug output if WARGS_DEBUG is enabled.</p>"},{"location":"api/utilities/#wArgs.utilities.debug_print","title":"wArgs.utilities.debug_print","text":"<pre><code>debug_print(*args: Any, **kwargs: Any) -&gt; None\n</code></pre> <p>Print debug output if WARGS_DEBUG is enabled.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Any</code> <p>Arguments to print.</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Keyword arguments for print.</p> <code>{}</code> Source code in <code>wArgs/utilities.py</code> <pre><code>def debug_print(*args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"Print debug output if WARGS_DEBUG is enabled.\n\n    Args:\n        *args: Arguments to print.\n        **kwargs: Keyword arguments for print.\n    \"\"\"\n    if is_debug_enabled():\n        print(\"[wargs]\", *args, file=sys.stderr, **kwargs)\n</code></pre>"},{"location":"api/utilities/#wargs_debug-environment-variable","title":"WARGS_DEBUG Environment Variable","text":"<p>Set <code>WARGS_DEBUG=1</code> to enable debug output:</p> <pre><code>$ WARGS_DEBUG=1 python myapp.py --name test\n[wargs] Building parser for function: myapp\n[wargs] Parsing args: ['--name', 'test']\n[wargs] Parsed result: Namespace(name='test')\n</code></pre> <p>Valid values: <code>1</code>, <code>true</code>, <code>yes</code>, <code>on</code> (case-insensitive)</p>"},{"location":"community/resources/","title":"Community Resources","text":"<p>A curated list of wArgs resources, plugins, articles, and projects from the community.</p>"},{"location":"community/resources/#official-resources","title":"Official Resources","text":"<ul> <li>Documentation: https://cmoxiv.github.io/wArgs/</li> <li>GitHub: https://github.com/cmoxiv/wArgs</li> <li>ROADMAP: Feature Roadmap</li> <li>Issues: Bug Reports &amp; Features</li> <li>Discussions: Community Forum</li> </ul>"},{"location":"community/resources/#community-plugins","title":"Community Plugins","text":"<p>Coming soon - submit your plugins!</p> <p>To add your plugin: 1. Create a plugin using the wArgs converter registry 2. Publish to PyPI with <code>wargs-</code> prefix 3. Submit a PR to add it here</p>"},{"location":"community/resources/#blog-posts-articles","title":"Blog Posts &amp; Articles","text":"<p>Share your wArgs articles!</p> <p>To add your article: 1. Write about wArgs on your blog 2. Submit a PR with title, link, and brief description 3. We'll add it to this list</p>"},{"location":"community/resources/#video-tutorials","title":"Video Tutorials","text":"<p>Create a tutorial video!</p> <p>YouTube channels and screencasts: - More coming soon!</p>"},{"location":"community/resources/#projects-using-wargs","title":"Projects Using wArgs","text":"<p>Showcase your project!</p> <p>Open source projects built with wArgs: - Submit yours via PR!</p>"},{"location":"community/resources/#how-to-add-your-project","title":"How to Add Your Project","text":"<ol> <li>Fork the wiki</li> <li>Add your project to this page:    <pre><code>### Project Name\n- **Description**: What it does\n- **GitHub**: Link to repo\n- **Author**: Your name\n</code></pre></li> <li>Submit a pull request</li> </ol>"},{"location":"community/resources/#related-tools","title":"Related Tools","text":"<p>Complementary tools and libraries: - Rich: Terminal formatting (https://github.com/Textualize/rich) - Typer: Alternative CLI framework (https://typer.tiangolo.com/) - Click: CLI creation kit (https://click.palletsprojects.com/)</p>"},{"location":"community/resources/#contributing","title":"Contributing","text":"<p>Want to contribute resources? 1. Check [[Contributing to Wiki]] 2. Submit via PR or Discussion 3. Follow the community guidelines</p> <p>This page is community-maintained. Last updated: 2024-02-07</p>"},{"location":"cookbook/migration-argparse/","title":"Migrating from argparse","text":"<p>This guide shows how to convert argparse-based CLIs to wArgs.</p>"},{"location":"cookbook/migration-argparse/#basic-example","title":"Basic Example","text":""},{"location":"cookbook/migration-argparse/#before-argparse","title":"Before (argparse)","text":"<pre><code>import argparse\n\ndef greet(name: str, greeting: str, times: int) -&gt; None:\n    for _ in range(times):\n        print(f\"{greeting}, {name}!\")\n\ndef main():\n    parser = argparse.ArgumentParser(description=\"Greet someone.\")\n    parser.add_argument(\"--name\", required=True, help=\"Name to greet\")\n    parser.add_argument(\"--greeting\", default=\"Hello\", help=\"Greeting to use\")\n    parser.add_argument(\"--times\", type=int, default=1, help=\"Number of times\")\n\n    args = parser.parse_args()\n    greet(args.name, args.greeting, args.times)\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"cookbook/migration-argparse/#after-wargs","title":"After (wArgs)","text":"<pre><code>from wArgs import wArgs\n\n@wArgs\ndef greet(name: str, greeting: str = \"Hello\", times: int = 1) -&gt; None:\n    \"\"\"Greet someone.\n\n    Args:\n        name: Name to greet\n        greeting: Greeting to use\n        times: Number of times\n    \"\"\"\n    for _ in range(times):\n        print(f\"{greeting}, {name}!\")\n\nif __name__ == \"__main__\":\n    greet()\n</code></pre>"},{"location":"cookbook/migration-argparse/#conversion-reference","title":"Conversion Reference","text":""},{"location":"cookbook/migration-argparse/#required-arguments","title":"Required Arguments","text":"<pre><code># argparse\nparser.add_argument(\"--name\", required=True)\n\n# wArgs - no default = required\ndef func(name: str): ...\n</code></pre>"},{"location":"cookbook/migration-argparse/#optional-arguments-with-defaults","title":"Optional Arguments with Defaults","text":"<pre><code># argparse\nparser.add_argument(\"--count\", type=int, default=1)\n\n# wArgs - has default = optional\ndef func(count: int = 1): ...\n</code></pre>"},{"location":"cookbook/migration-argparse/#boolean-flags","title":"Boolean Flags","text":"<pre><code># argparse\nparser.add_argument(\"--verbose\", action=\"store_true\")\n\n# wArgs - bool with False default\ndef func(verbose: bool = False): ...\n</code></pre>"},{"location":"cookbook/migration-argparse/#choices","title":"Choices","text":"<pre><code># argparse\nparser.add_argument(\"--format\", choices=[\"json\", \"xml\", \"csv\"])\n\n# wArgs - use Literal\nfrom typing import Literal\ndef func(format: Literal[\"json\", \"xml\", \"csv\"]): ...\n</code></pre>"},{"location":"cookbook/migration-argparse/#type-conversion","title":"Type Conversion","text":"<pre><code># argparse\nparser.add_argument(\"--count\", type=int)\nparser.add_argument(\"--rate\", type=float)\n\n# wArgs - use type hints\ndef func(count: int, rate: float): ...\n</code></pre>"},{"location":"cookbook/migration-argparse/#multiple-values-nargs","title":"Multiple Values (nargs)","text":"<pre><code># argparse\nparser.add_argument(\"--files\", nargs=\"+\")\n\n# wArgs - use list\ndef func(files: list[str]): ...\n</code></pre>"},{"location":"cookbook/migration-argparse/#positional-arguments","title":"Positional Arguments","text":"<pre><code># argparse\nparser.add_argument(\"filename\")\n\n# wArgs\nfrom typing import Annotated\nfrom wArgs import Arg\ndef func(filename: Annotated[str, Arg(positional=True)]): ...\n</code></pre>"},{"location":"cookbook/migration-argparse/#short-flags","title":"Short Flags","text":"<pre><code># argparse\nparser.add_argument(\"-n\", \"--name\")\n\n# wArgs\nfrom typing import Annotated\nfrom wArgs import Arg\ndef func(name: Annotated[str, Arg(\"-n\")]): ...\n</code></pre>"},{"location":"cookbook/migration-argparse/#help-text","title":"Help Text","text":"<pre><code># argparse\nparser.add_argument(\"--name\", help=\"The name to use\")\n\n# wArgs - use docstring\ndef func(name: str) -&gt; None:\n    \"\"\"Do something.\n\n    Args:\n        name: The name to use\n    \"\"\"\n</code></pre>"},{"location":"cookbook/migration-argparse/#metavar","title":"Metavar","text":"<pre><code># argparse\nparser.add_argument(\"--config\", metavar=\"FILE\")\n\n# wArgs\nfrom typing import Annotated\nfrom wArgs import Arg\ndef func(config: Annotated[str, Arg(metavar=\"FILE\")]): ...\n</code></pre>"},{"location":"cookbook/migration-argparse/#argument-groups","title":"Argument Groups","text":"<pre><code># argparse\ngroup = parser.add_argument_group(\"Network\")\ngroup.add_argument(\"--host\")\ngroup.add_argument(\"--port\", type=int)\n\n# wArgs\nfrom typing import Annotated\nfrom wArgs import Arg\ndef func(\n    host: Annotated[str, Arg(group=\"Network\")],\n    port: Annotated[int, Arg(group=\"Network\")],\n): ...\n</code></pre>"},{"location":"cookbook/migration-argparse/#mutually-exclusive","title":"Mutually Exclusive","text":"<pre><code># argparse\ngroup = parser.add_mutually_exclusive_group()\ngroup.add_argument(\"--json\", action=\"store_true\")\ngroup.add_argument(\"--xml\", action=\"store_true\")\n\n# wArgs\nfrom typing import Annotated\nfrom wArgs import Arg\ndef func(\n    json: Annotated[bool, Arg(mutually_exclusive=\"format\")] = False,\n    xml: Annotated[bool, Arg(mutually_exclusive=\"format\")] = False,\n): ...\n</code></pre>"},{"location":"cookbook/migration-argparse/#subparsers","title":"Subparsers","text":""},{"location":"cookbook/migration-argparse/#before-argparse_1","title":"Before (argparse)","text":"<pre><code>import argparse\n\ndef add(args):\n    print(args.a + args.b)\n\ndef multiply(args):\n    print(args.a * args.b)\n\nparser = argparse.ArgumentParser()\nsubparsers = parser.add_subparsers()\n\nadd_parser = subparsers.add_parser(\"add\", help=\"Add numbers\")\nadd_parser.add_argument(\"--a\", type=int, required=True)\nadd_parser.add_argument(\"--b\", type=int, required=True)\nadd_parser.set_defaults(func=add)\n\nmul_parser = subparsers.add_parser(\"multiply\", help=\"Multiply numbers\")\nmul_parser.add_argument(\"--a\", type=int, required=True)\nmul_parser.add_argument(\"--b\", type=int, required=True)\nmul_parser.set_defaults(func=multiply)\n\nargs = parser.parse_args()\nargs.func(args)\n</code></pre>"},{"location":"cookbook/migration-argparse/#after-wargs_1","title":"After (wArgs)","text":"<pre><code>from wArgs import wArgs\n\n@wArgs\nclass Calculator:\n    \"\"\"Calculator CLI.\"\"\"\n\n    def add(self, a: int, b: int) -&gt; None:\n        \"\"\"Add numbers.\"\"\"\n        print(a + b)\n\n    def multiply(self, a: int, b: int) -&gt; None:\n        \"\"\"Multiply numbers.\"\"\"\n        print(a * b)\n\nif __name__ == \"__main__\":\n    Calculator()\n</code></pre>"},{"location":"cookbook/migration-argparse/#global-options","title":"Global Options","text":""},{"location":"cookbook/migration-argparse/#before-argparse_2","title":"Before (argparse)","text":"<pre><code>parser = argparse.ArgumentParser()\nparser.add_argument(\"--verbose\", action=\"store_true\")\nsubparsers = parser.add_subparsers()\n# ... add subparsers\n\nargs = parser.parse_args()\nif args.verbose:\n    print(\"Verbose mode\")\n</code></pre>"},{"location":"cookbook/migration-argparse/#after-wargs_2","title":"After (wArgs)","text":"<pre><code>@wArgs\nclass CLI:\n    def __init__(self, verbose: bool = False) -&gt; None:\n        self.verbose = verbose\n\n    def run(self) -&gt; None:\n        if self.verbose:\n            print(\"Verbose mode\")\n</code></pre>"},{"location":"cookbook/migration-argparse/#complete-migration-example","title":"Complete Migration Example","text":""},{"location":"cookbook/migration-argparse/#before-100-lines","title":"Before (100+ lines)","text":"<pre><code>import argparse\nimport sys\n\ndef setup_parser():\n    parser = argparse.ArgumentParser(\n        prog=\"myapp\",\n        description=\"My application\"\n    )\n    parser.add_argument(\"-v\", \"--verbose\", action=\"store_true\",\n                        help=\"Enable verbose output\")\n    parser.add_argument(\"-c\", \"--config\", default=\"config.yml\",\n                        help=\"Configuration file\")\n\n    subparsers = parser.add_subparsers(dest=\"command\")\n\n    # Init command\n    init = subparsers.add_parser(\"init\", help=\"Initialize project\")\n    init.add_argument(\"--name\", required=True, help=\"Project name\")\n    init.add_argument(\"--template\", choices=[\"basic\", \"full\"],\n                      default=\"basic\", help=\"Template to use\")\n\n    # Build command\n    build = subparsers.add_parser(\"build\", help=\"Build project\")\n    build.add_argument(\"--output\", \"-o\", default=\"dist\",\n                       help=\"Output directory\")\n    build.add_argument(\"--minify\", action=\"store_true\",\n                       help=\"Minify output\")\n\n    return parser\n\ndef cmd_init(args):\n    print(f\"Initializing {args.name} with {args.template} template\")\n\ndef cmd_build(args):\n    print(f\"Building to {args.output}\")\n    if args.minify:\n        print(\"Minifying...\")\n\ndef main():\n    parser = setup_parser()\n    args = parser.parse_args()\n\n    if args.verbose:\n        print(f\"Using config: {args.config}\")\n\n    if args.command == \"init\":\n        cmd_init(args)\n    elif args.command == \"build\":\n        cmd_build(args)\n    else:\n        parser.print_help()\n        sys.exit(1)\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"cookbook/migration-argparse/#after-30-lines","title":"After (30 lines)","text":"<pre><code>from typing import Annotated, Literal\nfrom wArgs import wArgs, Arg\n\n@wArgs(prog=\"myapp\")\nclass CLI:\n    \"\"\"My application.\"\"\"\n\n    def __init__(\n        self,\n        verbose: Annotated[bool, Arg(\"-v\")] = False,\n        config: Annotated[str, Arg(\"-c\")] = \"config.yml\",\n    ) -&gt; None:\n        self.verbose = verbose\n        if verbose:\n            print(f\"Using config: {config}\")\n\n    def init(\n        self,\n        name: str,\n        template: Literal[\"basic\", \"full\"] = \"basic\",\n    ) -&gt; None:\n        \"\"\"Initialize project.\"\"\"\n        print(f\"Initializing {name} with {template} template\")\n\n    def build(\n        self,\n        output: Annotated[str, Arg(\"-o\")] = \"dist\",\n        minify: bool = False,\n    ) -&gt; None:\n        \"\"\"Build project.\"\"\"\n        print(f\"Building to {output}\")\n        if minify:\n            print(\"Minifying...\")\n\nif __name__ == \"__main__\":\n    CLI()\n</code></pre>"},{"location":"cookbook/migration-click/","title":"Migrating from Click","text":"<p>This guide shows how to convert Click-based CLIs to wArgs.</p>"},{"location":"cookbook/migration-click/#key-differences","title":"Key Differences","text":"Feature Click wArgs Decorator <code>@click.command()</code> <code>@wArgs</code> Options <code>@click.option()</code> Type hints + <code>Arg</code> Arguments <code>@click.argument()</code> <code>Arg(positional=True)</code> Groups <code>@click.group()</code> Class with methods Help <code>help=</code> parameter Docstrings Types <code>type=click.INT</code> Type hints"},{"location":"cookbook/migration-click/#basic-command","title":"Basic Command","text":""},{"location":"cookbook/migration-click/#before-click","title":"Before (Click)","text":"<pre><code>import click\n\n@click.command()\n@click.option(\"--name\", required=True, help=\"Name to greet\")\n@click.option(\"--count\", default=1, type=int, help=\"Number of times\")\ndef greet(name: str, count: int):\n    \"\"\"Greet someone.\"\"\"\n    for _ in range(count):\n        click.echo(f\"Hello, {name}!\")\n\nif __name__ == \"__main__\":\n    greet()\n</code></pre>"},{"location":"cookbook/migration-click/#after-wargs","title":"After (wArgs)","text":"<pre><code>from wArgs import wArgs\n\n@wArgs\ndef greet(name: str, count: int = 1) -&gt; None:\n    \"\"\"Greet someone.\n\n    Args:\n        name: Name to greet\n        count: Number of times\n    \"\"\"\n    for _ in range(count):\n        print(f\"Hello, {name}!\")\n\nif __name__ == \"__main__\":\n    greet()\n</code></pre>"},{"location":"cookbook/migration-click/#conversion-reference","title":"Conversion Reference","text":""},{"location":"cookbook/migration-click/#options","title":"Options","text":"<pre><code># Click\n@click.option(\"--name\", required=True)\n@click.option(\"--count\", default=1, type=int)\n\n# wArgs\ndef func(name: str, count: int = 1): ...\n</code></pre>"},{"location":"cookbook/migration-click/#short-options","title":"Short Options","text":"<pre><code># Click\n@click.option(\"-n\", \"--name\")\n\n# wArgs\nfrom typing import Annotated\nfrom wArgs import Arg\ndef func(name: Annotated[str, Arg(\"-n\")]): ...\n</code></pre>"},{"location":"cookbook/migration-click/#boolean-flags","title":"Boolean Flags","text":"<pre><code># Click\n@click.option(\"--verbose/--no-verbose\", default=False)\n# or\n@click.option(\"--verbose\", is_flag=True)\n\n# wArgs\ndef func(verbose: bool = False): ...\n</code></pre>"},{"location":"cookbook/migration-click/#multiple-values","title":"Multiple Values","text":"<pre><code># Click\n@click.option(\"--file\", multiple=True)\n\n# wArgs\ndef func(file: list[str]): ...\n</code></pre>"},{"location":"cookbook/migration-click/#choices","title":"Choices","text":"<pre><code># Click\n@click.option(\"--format\", type=click.Choice([\"json\", \"xml\"]))\n\n# wArgs\nfrom typing import Literal\ndef func(format: Literal[\"json\", \"xml\"]): ...\n</code></pre>"},{"location":"cookbook/migration-click/#arguments-positional","title":"Arguments (Positional)","text":"<pre><code># Click\n@click.argument(\"filename\")\n\n# wArgs\nfrom typing import Annotated\nfrom wArgs import Arg\ndef func(filename: Annotated[str, Arg(positional=True)]): ...\n</code></pre>"},{"location":"cookbook/migration-click/#file-arguments","title":"File Arguments","text":"<pre><code># Click\n@click.argument(\"input\", type=click.File(\"r\"))\n@click.argument(\"output\", type=click.File(\"w\"))\n\n# wArgs - use Path, handle file opening yourself\nfrom pathlib import Path\ndef func(input: Path, output: Path) -&gt; None:\n    content = input.read_text()\n    output.write_text(content)\n</code></pre>"},{"location":"cookbook/migration-click/#path-arguments","title":"Path Arguments","text":"<pre><code># Click\n@click.option(\"--path\", type=click.Path(exists=True))\n\n# wArgs\nfrom pathlib import Path\ndef func(path: Path): ...\n# Note: wArgs doesn't validate existence; do it in your code\n</code></pre>"},{"location":"cookbook/migration-click/#command-groups","title":"Command Groups","text":""},{"location":"cookbook/migration-click/#before-click_1","title":"Before (Click)","text":"<pre><code>import click\n\n@click.group()\n@click.option(\"--verbose\", is_flag=True)\n@click.pass_context\ndef cli(ctx, verbose):\n    ctx.ensure_object(dict)\n    ctx.obj[\"verbose\"] = verbose\n\n@cli.command()\n@click.argument(\"name\")\n@click.pass_context\ndef add(ctx, name):\n    \"\"\"Add an item.\"\"\"\n    if ctx.obj[\"verbose\"]:\n        click.echo(f\"Adding {name}\")\n    click.echo(f\"Added: {name}\")\n\n@cli.command()\n@click.argument(\"item_id\", type=int)\n@click.pass_context\ndef remove(ctx, item_id):\n    \"\"\"Remove an item.\"\"\"\n    if ctx.obj[\"verbose\"]:\n        click.echo(f\"Removing {item_id}\")\n    click.echo(f\"Removed: {item_id}\")\n\nif __name__ == \"__main__\":\n    cli()\n</code></pre>"},{"location":"cookbook/migration-click/#after-wargs_1","title":"After (wArgs)","text":"<pre><code>from typing import Annotated\nfrom wArgs import wArgs, Arg\n\n@wArgs\nclass CLI:\n    \"\"\"CLI tool.\"\"\"\n\n    def __init__(self, verbose: bool = False) -&gt; None:\n        self.verbose = verbose\n\n    def add(self, name: Annotated[str, Arg(positional=True)]) -&gt; None:\n        \"\"\"Add an item.\"\"\"\n        if self.verbose:\n            print(f\"Adding {name}\")\n        print(f\"Added: {name}\")\n\n    def remove(self, item_id: Annotated[int, Arg(positional=True)]) -&gt; None:\n        \"\"\"Remove an item.\"\"\"\n        if self.verbose:\n            print(f\"Removing {item_id}\")\n        print(f\"Removed: {item_id}\")\n\nif __name__ == \"__main__\":\n    CLI()\n</code></pre>"},{"location":"cookbook/migration-click/#context-and-state","title":"Context and State","text":""},{"location":"cookbook/migration-click/#before-click_2","title":"Before (Click)","text":"<pre><code>import click\n\n@click.group()\n@click.option(\"--config\", default=\"config.yml\")\n@click.pass_context\ndef cli(ctx, config):\n    ctx.ensure_object(dict)\n    ctx.obj[\"config\"] = load_config(config)\n\n@cli.command()\n@click.pass_context\ndef show(ctx):\n    print(ctx.obj[\"config\"])\n</code></pre>"},{"location":"cookbook/migration-click/#after-wargs_2","title":"After (wArgs)","text":"<pre><code>from wArgs import wArgs\n\n@wArgs\nclass CLI:\n    def __init__(self, config: str = \"config.yml\") -&gt; None:\n        self.config_data = load_config(config)\n\n    def show(self) -&gt; None:\n        print(self.config_data)\n</code></pre>"},{"location":"cookbook/migration-click/#callbacks-and-validation","title":"Callbacks and Validation","text":""},{"location":"cookbook/migration-click/#before-click_3","title":"Before (Click)","text":"<pre><code>def validate_port(ctx, param, value):\n    if value &lt; 1 or value &gt; 65535:\n        raise click.BadParameter(\"Port must be 1-65535\")\n    return value\n\n@click.command()\n@click.option(\"--port\", type=int, callback=validate_port)\ndef serve(port):\n    print(f\"Serving on port {port}\")\n</code></pre>"},{"location":"cookbook/migration-click/#after-wargs_3","title":"After (wArgs)","text":"<pre><code>from wArgs import wArgs\n\n@wArgs\ndef serve(port: int) -&gt; None:\n    \"\"\"Start server.\n\n    Args:\n        port: Port number (1-65535)\n    \"\"\"\n    if port &lt; 1 or port &gt; 65535:\n        raise ValueError(\"Port must be 1-65535\")\n    print(f\"Serving on port {port}\")\n</code></pre>"},{"location":"cookbook/migration-click/#progress-bars","title":"Progress Bars","text":"<p>Click has built-in progress bars. With wArgs, use tqdm or rich:</p> <pre><code>from wArgs import wArgs\nfrom tqdm import tqdm\n\n@wArgs\ndef process(files: list[str]) -&gt; None:\n    \"\"\"Process files.\"\"\"\n    for f in tqdm(files, desc=\"Processing\"):\n        # process file\n        pass\n</code></pre>"},{"location":"cookbook/migration-click/#prompts","title":"Prompts","text":"<p>Click has built-in prompts. With wArgs, use standard input:</p> <pre><code>from wArgs import wArgs\n\n@wArgs\ndef login(username: str, password: str = \"\") -&gt; None:\n    \"\"\"Login to service.\"\"\"\n    if not password:\n        password = input(\"Password: \")\n    print(f\"Logging in as {username}\")\n</code></pre> <p>Or use <code>getpass</code> for hidden input:</p> <pre><code>from getpass import getpass\nfrom wArgs import wArgs\n\n@wArgs\ndef login(username: str) -&gt; None:\n    \"\"\"Login to service.\"\"\"\n    password = getpass(\"Password: \")\n    print(f\"Logging in as {username}\")\n</code></pre>"},{"location":"cookbook/migration-click/#complete-migration-example","title":"Complete Migration Example","text":""},{"location":"cookbook/migration-click/#before-click_4","title":"Before (Click)","text":"<pre><code>import click\n\n@click.group()\n@click.option(\"-v\", \"--verbose\", is_flag=True, help=\"Verbose output\")\n@click.option(\"-c\", \"--config\", default=\"config.yml\", help=\"Config file\")\n@click.pass_context\ndef cli(ctx, verbose, config):\n    \"\"\"My CLI application.\"\"\"\n    ctx.ensure_object(dict)\n    ctx.obj[\"verbose\"] = verbose\n    ctx.obj[\"config\"] = config\n\n@cli.command()\n@click.argument(\"name\")\n@click.option(\"--template\", type=click.Choice([\"basic\", \"full\"]),\n              default=\"basic\", help=\"Project template\")\n@click.pass_context\ndef init(ctx, name, template):\n    \"\"\"Initialize a new project.\"\"\"\n    if ctx.obj[\"verbose\"]:\n        click.echo(f\"Config: {ctx.obj['config']}\")\n    click.echo(f\"Creating {name} with {template} template\")\n\n@cli.command()\n@click.option(\"-o\", \"--output\", default=\"dist\", help=\"Output directory\")\n@click.option(\"--minify\", is_flag=True, help=\"Minify output\")\n@click.pass_context\ndef build(ctx, output, minify):\n    \"\"\"Build the project.\"\"\"\n    if ctx.obj[\"verbose\"]:\n        click.echo(f\"Building to {output}\")\n    if minify:\n        click.echo(\"Minifying...\")\n    click.echo(\"Build complete!\")\n\nif __name__ == \"__main__\":\n    cli()\n</code></pre>"},{"location":"cookbook/migration-click/#after-wargs_4","title":"After (wArgs)","text":"<pre><code>from typing import Annotated, Literal\nfrom wArgs import wArgs, Arg\n\n@wArgs\nclass CLI:\n    \"\"\"My CLI application.\"\"\"\n\n    def __init__(\n        self,\n        verbose: Annotated[bool, Arg(\"-v\")] = False,\n        config: Annotated[str, Arg(\"-c\")] = \"config.yml\",\n    ) -&gt; None:\n        self.verbose = verbose\n        self.config = config\n\n    def init(\n        self,\n        name: Annotated[str, Arg(positional=True)],\n        template: Literal[\"basic\", \"full\"] = \"basic\",\n    ) -&gt; None:\n        \"\"\"Initialize a new project.\"\"\"\n        if self.verbose:\n            print(f\"Config: {self.config}\")\n        print(f\"Creating {name} with {template} template\")\n\n    def build(\n        self,\n        output: Annotated[str, Arg(\"-o\")] = \"dist\",\n        minify: bool = False,\n    ) -&gt; None:\n        \"\"\"Build the project.\"\"\"\n        if self.verbose:\n            print(f\"Building to {output}\")\n        if minify:\n            print(\"Minifying...\")\n        print(\"Build complete!\")\n\nif __name__ == \"__main__\":\n    CLI()\n</code></pre>"},{"location":"cookbook/migration-click/#why-migrate","title":"Why Migrate?","text":"<ol> <li>Less boilerplate - No separate decorator for each option</li> <li>Type safety - Type hints are the source of truth</li> <li>Standard Python - Uses standard library only</li> <li>Testability - Easy to test directly or via CLI</li> <li>IDE support - Better autocomplete and type checking</li> </ol>"},{"location":"cookbook/patterns/","title":"Common Patterns","text":"<p>This cookbook contains common patterns and recipes for wArgs.</p>"},{"location":"cookbook/patterns/#1-file-inputoutput","title":"1. File Input/Output","text":"<pre><code>from pathlib import Path\nfrom wArgs import wArgs\n\n@wArgs\ndef process(\n    input_file: Path,\n    output_file: Path = Path(\"output.txt\"),\n) -&gt; None:\n    \"\"\"Process a file.\n\n    Args:\n        input_file: Input file to process\n        output_file: Output file path\n    \"\"\"\n    content = input_file.read_text()\n    processed = content.upper()\n    output_file.write_text(processed)\n    print(f\"Processed {input_file} -&gt; {output_file}\")\n</code></pre> <pre><code>$ python process.py --input-file data.txt --output-file result.txt\n</code></pre>"},{"location":"cookbook/patterns/#2-multiple-input-files","title":"2. Multiple Input Files","text":"<pre><code>from pathlib import Path\nfrom wArgs import wArgs\n\n@wArgs\ndef concat(files: list[Path], output: Path) -&gt; None:\n    \"\"\"Concatenate multiple files.\n\n    Args:\n        files: Files to concatenate\n        output: Output file\n    \"\"\"\n    contents = [f.read_text() for f in files]\n    output.write_text(\"\\n\".join(contents))\n    print(f\"Concatenated {len(files)} files to {output}\")\n</code></pre> <pre><code>$ python concat.py --files a.txt b.txt c.txt --output combined.txt\n</code></pre>"},{"location":"cookbook/patterns/#3-verbose-mode-mixin","title":"3. Verbose Mode Mixin","text":"<pre><code>from wArgs import wArgs\n\nclass VerboseMixin:\n    \"\"\"Adds verbose output support.\"\"\"\n\n    def __init__(self, verbose: bool = False, **kwargs) -&gt; None:\n        super().__init__(**kwargs)\n        self.verbose = verbose\n\n    def log(self, message: str) -&gt; None:\n        if self.verbose:\n            print(f\"[INFO] {message}\")\n\n@wArgs\nclass CLI(VerboseMixin):\n    def __init__(self, **kwargs) -&gt; None:\n        super().__init__(**kwargs)\n\n    def process(self, data: str) -&gt; None:\n        \"\"\"Process data.\"\"\"\n        self.log(f\"Processing: {data}\")\n        print(f\"Result: {data.upper()}\")\n</code></pre> <pre><code>$ python app.py --verbose process --data \"hello\"\n[INFO] Processing: hello\nResult: HELLO\n</code></pre>"},{"location":"cookbook/patterns/#4-configuration-file-support","title":"4. Configuration File Support","text":"<pre><code>import json\nfrom pathlib import Path\nfrom typing import Annotated\nfrom wArgs import wArgs, Arg\n\n@wArgs\nclass CLI:\n    def __init__(\n        self,\n        config: Annotated[Path, Arg(\"-c\", help=\"Config file\")] = Path(\"config.json\"),\n    ) -&gt; None:\n        self.config_data = {}\n        if config.exists():\n            self.config_data = json.loads(config.read_text())\n\n    def show(self) -&gt; None:\n        \"\"\"Show current configuration.\"\"\"\n        print(json.dumps(self.config_data, indent=2))\n\n    def get(self, key: str) -&gt; None:\n        \"\"\"Get a config value.\"\"\"\n        print(self.config_data.get(key, \"Not found\"))\n</code></pre>"},{"location":"cookbook/patterns/#5-progress-output","title":"5. Progress Output","text":"<pre><code>from wArgs import wArgs\n\n@wArgs\ndef download(\n    urls: list[str],\n    quiet: bool = False,\n) -&gt; None:\n    \"\"\"Download files from URLs.\n\n    Args:\n        urls: URLs to download\n        quiet: Suppress progress output\n    \"\"\"\n    for i, url in enumerate(urls, 1):\n        if not quiet:\n            print(f\"[{i}/{len(urls)}] Downloading {url}...\")\n        # download logic here\n        if not quiet:\n            print(f\"  Done!\")\n</code></pre>"},{"location":"cookbook/patterns/#6-output-format-selection","title":"6. Output Format Selection","text":"<pre><code>import json\nfrom typing import Literal\nfrom wArgs import wArgs\n\n@wArgs\ndef export(\n    data: str,\n    format: Literal[\"json\", \"csv\", \"text\"] = \"text\",\n) -&gt; None:\n    \"\"\"Export data in various formats.\n\n    Args:\n        data: Data to export\n        format: Output format\n    \"\"\"\n    if format == \"json\":\n        print(json.dumps({\"data\": data}))\n    elif format == \"csv\":\n        print(f\"data\\n{data}\")\n    else:\n        print(data)\n</code></pre> <pre><code>$ python export.py --data \"hello\" --format json\n{\"data\": \"hello\"}\n</code></pre>"},{"location":"cookbook/patterns/#7-confirmation-prompt","title":"7. Confirmation Prompt","text":"<pre><code>from wArgs import wArgs\n\n@wArgs\ndef delete(\n    path: str,\n    force: bool = False,\n) -&gt; None:\n    \"\"\"Delete a file.\n\n    Args:\n        path: File to delete\n        force: Skip confirmation\n    \"\"\"\n    if not force:\n        response = input(f\"Delete {path}? [y/N] \")\n        if response.lower() != \"y\":\n            print(\"Cancelled.\")\n            return\n    print(f\"Deleted: {path}\")\n</code></pre> <pre><code>$ python delete.py --path test.txt\nDelete test.txt? [y/N] y\nDeleted: test.txt\n\n$ python delete.py --path test.txt --force\nDeleted: test.txt\n</code></pre>"},{"location":"cookbook/patterns/#8-environment-based-defaults","title":"8. Environment-Based Defaults","text":"<pre><code>import os\nfrom typing import Annotated\nfrom wArgs import wArgs, Arg\n\n@wArgs\ndef deploy(\n    env: str = os.environ.get(\"DEPLOY_ENV\", \"dev\"),\n    host: str = os.environ.get(\"DEPLOY_HOST\", \"localhost\"),\n) -&gt; None:\n    \"\"\"Deploy to an environment.\n\n    Args:\n        env: Target environment (default from DEPLOY_ENV)\n        host: Target host (default from DEPLOY_HOST)\n    \"\"\"\n    print(f\"Deploying to {env} on {host}\")\n</code></pre> <pre><code>$ DEPLOY_ENV=prod DEPLOY_HOST=example.com python deploy.py\nDeploying to prod on example.com\n\n$ python deploy.py --env staging\nDeploying to staging on localhost\n</code></pre>"},{"location":"cookbook/patterns/#9-logging-integration","title":"9. Logging Integration","text":"<pre><code>import logging\nfrom wArgs import wArgs\n\n@wArgs\ndef process(\n    data: str,\n    log_level: str = \"INFO\",\n) -&gt; None:\n    \"\"\"Process data with logging.\n\n    Args:\n        data: Data to process\n        log_level: Logging level (DEBUG, INFO, WARNING, ERROR)\n    \"\"\"\n    logging.basicConfig(level=getattr(logging, log_level))\n    logger = logging.getLogger(__name__)\n\n    logger.debug(f\"Starting processing: {data}\")\n    logger.info(f\"Processing: {data}\")\n    result = data.upper()\n    logger.debug(f\"Result: {result}\")\n    print(result)\n</code></pre> <pre><code>$ python process.py --data hello --log-level DEBUG\nDEBUG:__main__:Starting processing: hello\nINFO:__main__:Processing: hello\nDEBUG:__main__:Result: HELLO\nHELLO\n</code></pre>"},{"location":"cookbook/patterns/#10-dry-run-mode","title":"10. Dry Run Mode","text":"<pre><code>from wArgs import wArgs\n\nclass DryRunMixin:\n    \"\"\"Adds dry-run support.\"\"\"\n\n    def __init__(self, dry_run: bool = False, **kwargs) -&gt; None:\n        super().__init__(**kwargs)\n        self.dry_run = dry_run\n\n    def execute(self, action: str, func: callable) -&gt; None:\n        if self.dry_run:\n            print(f\"[DRY RUN] Would {action}\")\n        else:\n            func()\n            print(f\"Done: {action}\")\n\n@wArgs\nclass FileManager(DryRunMixin):\n    def __init__(self, **kwargs) -&gt; None:\n        super().__init__(**kwargs)\n\n    def delete(self, path: str) -&gt; None:\n        \"\"\"Delete a file.\"\"\"\n        self.execute(f\"delete {path}\", lambda: print(f\"Deleting {path}\"))\n\n    def copy(self, src: str, dest: str) -&gt; None:\n        \"\"\"Copy a file.\"\"\"\n        self.execute(f\"copy {src} to {dest}\", lambda: print(f\"Copying...\"))\n</code></pre> <pre><code>$ python files.py --dry-run delete --path test.txt\n[DRY RUN] Would delete test.txt\n</code></pre>"},{"location":"cookbook/patterns/#11-subcommand-with-shared-state","title":"11. Subcommand with Shared State","text":"<pre><code>from wArgs import wArgs\n\n@wArgs\nclass Database:\n    \"\"\"Database management tool.\"\"\"\n\n    def __init__(self, connection: str = \"sqlite:///data.db\") -&gt; None:\n        self.connection = connection\n        self._connected = False\n\n    def _connect(self) -&gt; None:\n        if not self._connected:\n            print(f\"Connecting to {self.connection}...\")\n            self._connected = True\n\n    def query(self, sql: str) -&gt; None:\n        \"\"\"Execute a SQL query.\"\"\"\n        self._connect()\n        print(f\"Executing: {sql}\")\n\n    def migrate(self, version: str) -&gt; None:\n        \"\"\"Run migrations.\"\"\"\n        self._connect()\n        print(f\"Migrating to version {version}\")\n</code></pre>"},{"location":"cookbook/patterns/#12-plugin-style-commands","title":"12. Plugin-Style Commands","text":"<pre><code>from wArgs import wArgs\n\n@wArgs\nclass CLI:\n    \"\"\"Extensible CLI with plugins.\"\"\"\n\n    def __init__(self) -&gt; None:\n        self.plugins: dict[str, callable] = {}\n\n    def register(self, name: str, func: callable) -&gt; None:\n        \"\"\"Register a plugin command.\"\"\"\n        self.plugins[name] = func\n\n    def run_plugin(self, name: str, args: str = \"\") -&gt; None:\n        \"\"\"Run a registered plugin.\n\n        Args:\n            name: Plugin name\n            args: Arguments to pass\n        \"\"\"\n        if name in self.plugins:\n            self.plugins[name](args)\n        else:\n            print(f\"Plugin not found: {name}\")\n            print(f\"Available: {list(self.plugins.keys())}\")\n</code></pre>"},{"location":"cookbook/patterns/#13-batch-processing","title":"13. Batch Processing","text":"<pre><code>from pathlib import Path\nfrom wArgs import wArgs\n\n@wArgs\ndef batch(\n    input_dir: Path,\n    output_dir: Path,\n    pattern: str = \"*.txt\",\n    parallel: int = 1,\n) -&gt; None:\n    \"\"\"Process files in batch.\n\n    Args:\n        input_dir: Input directory\n        output_dir: Output directory\n        pattern: File pattern to match\n        parallel: Number of parallel workers\n    \"\"\"\n    files = list(input_dir.glob(pattern))\n    print(f\"Found {len(files)} files matching {pattern}\")\n    print(f\"Processing with {parallel} workers...\")\n\n    for f in files:\n        out = output_dir / f.name\n        print(f\"  {f} -&gt; {out}\")\n</code></pre> <pre><code>$ python batch.py --input-dir ./data --output-dir ./out --pattern \"*.csv\" --parallel 4\n</code></pre>"},{"location":"cookbook/testing/","title":"Testing CLIs","text":"<p>This guide covers strategies for testing wArgs CLI applications.</p>"},{"location":"cookbook/testing/#basic-testing","title":"Basic Testing","text":""},{"location":"cookbook/testing/#test-direct-calls","title":"Test Direct Calls","text":"<p>The simplest approach - call the function directly:</p> <pre><code>from wArgs import wArgs\n\n@wArgs\ndef add(a: int, b: int) -&gt; int:\n    \"\"\"Add two numbers.\"\"\"\n    return a + b\n\ndef test_add_direct():\n    result = add(a=2, b=3)\n    assert result == 5\n\ndef test_add_positional():\n    result = add(2, 3)\n    assert result == 5\n</code></pre>"},{"location":"cookbook/testing/#test-cli-parsing","title":"Test CLI Parsing","text":"<p>Use <code>.run()</code> to test CLI argument parsing:</p> <pre><code>def test_add_cli():\n    result = add.run([\"--a\", \"2\", \"--b\", \"3\"])\n    assert result == 5\n\ndef test_add_cli_negative():\n    result = add.run([\"--a\", \"-5\", \"--b\", \"10\"])\n    assert result == 5\n</code></pre>"},{"location":"cookbook/testing/#test-argument-parsing-only","title":"Test Argument Parsing Only","text":"<p>Use <code>.parse_args()</code> to test just the parsing:</p> <pre><code>def test_parse_args():\n    args = add.parse_args([\"--a\", \"10\", \"--b\", \"20\"])\n    assert args.a == 10\n    assert args.b == 20\n</code></pre>"},{"location":"cookbook/testing/#testing-with-pytest","title":"Testing with pytest","text":""},{"location":"cookbook/testing/#fixtures-for-cli-testing","title":"Fixtures for CLI Testing","text":"<pre><code>import pytest\nfrom wArgs import wArgs\n\n@wArgs\ndef greet(name: str, loud: bool = False) -&gt; str:\n    msg = f\"Hello, {name}!\"\n    return msg.upper() if loud else msg\n\n@pytest.fixture\ndef greet_cli():\n    \"\"\"Provide the greet CLI for testing.\"\"\"\n    return greet\n\nclass TestGreetCLI:\n    def test_basic(self, greet_cli):\n        result = greet_cli.run([\"--name\", \"World\"])\n        assert result == \"Hello, World!\"\n\n    def test_loud(self, greet_cli):\n        result = greet_cli.run([\"--name\", \"World\", \"--loud\"])\n        assert result == \"HELLO, WORLD!\"\n\n    def test_direct_call(self, greet_cli):\n        result = greet_cli(name=\"Test\")\n        assert result == \"Hello, Test!\"\n</code></pre>"},{"location":"cookbook/testing/#parameterized-tests","title":"Parameterized Tests","text":"<pre><code>import pytest\nfrom wArgs import wArgs\n\n@wArgs\ndef calculate(op: str, a: int, b: int) -&gt; int:\n    ops = {\n        \"add\": lambda x, y: x + y,\n        \"sub\": lambda x, y: x - y,\n        \"mul\": lambda x, y: x * y,\n    }\n    return ops[op](a, b)\n\n@pytest.mark.parametrize(\"op,a,b,expected\", [\n    (\"add\", 2, 3, 5),\n    (\"sub\", 10, 4, 6),\n    (\"mul\", 3, 7, 21),\n])\ndef test_calculate(op, a, b, expected):\n    result = calculate.run([\"--op\", op, \"--a\", str(a), \"--b\", str(b)])\n    assert result == expected\n</code></pre>"},{"location":"cookbook/testing/#testing-output","title":"Testing Output","text":""},{"location":"cookbook/testing/#capture-stdout","title":"Capture stdout","text":"<pre><code>from wArgs import wArgs\n\n@wArgs\ndef echo(message: str) -&gt; None:\n    print(message)\n\ndef test_echo_output(capsys):\n    echo.run([\"--message\", \"Hello\"])\n    captured = capsys.readouterr()\n    assert captured.out == \"Hello\\n\"\n</code></pre>"},{"location":"cookbook/testing/#capture-stderr","title":"Capture stderr","text":"<pre><code>import sys\nfrom wArgs import wArgs\n\n@wArgs\ndef warn(message: str) -&gt; None:\n    print(message, file=sys.stderr)\n\ndef test_warn_output(capsys):\n    warn.run([\"--message\", \"Warning!\"])\n    captured = capsys.readouterr()\n    assert captured.err == \"Warning!\\n\"\n</code></pre>"},{"location":"cookbook/testing/#testing-class-based-clis","title":"Testing Class-Based CLIs","text":"<pre><code>from wArgs import wArgs\n\n@wArgs\nclass Calculator:\n    def __init__(self, precision: int = 2) -&gt; None:\n        self.precision = precision\n\n    def add(self, a: float, b: float) -&gt; None:\n        result = round(a + b, self.precision)\n        print(result)\n\ndef test_calculator_add(capsys):\n    Calculator.run([\"add\", \"--a\", \"1.234\", \"--b\", \"2.345\"])\n    captured = capsys.readouterr()\n    assert captured.out.strip() == \"3.58\"\n\ndef test_calculator_precision(capsys):\n    Calculator.run([\"--precision\", \"4\", \"add\", \"--a\", \"1.2345\", \"--b\", \"2.3456\"])\n    captured = capsys.readouterr()\n    assert captured.out.strip() == \"3.5801\"\n</code></pre>"},{"location":"cookbook/testing/#testing-error-handling","title":"Testing Error Handling","text":""},{"location":"cookbook/testing/#test-required-arguments","title":"Test Required Arguments","text":"<pre><code>import pytest\nfrom wArgs import wArgs\n\n@wArgs\ndef greet(name: str) -&gt; str:\n    return f\"Hello, {name}!\"\n\ndef test_missing_required_argument():\n    with pytest.raises(SystemExit) as exc_info:\n        greet.run([])\n    assert exc_info.value.code == 2  # argparse exit code for errors\n</code></pre>"},{"location":"cookbook/testing/#test-invalid-arguments","title":"Test Invalid Arguments","text":"<pre><code>@wArgs\ndef process(count: int) -&gt; int:\n    return count\n\ndef test_invalid_type():\n    with pytest.raises(SystemExit):\n        process.run([\"--count\", \"not-a-number\"])\n</code></pre>"},{"location":"cookbook/testing/#test-conversion-errors","title":"Test Conversion Errors","text":"<pre><code>from datetime import datetime\nfrom wArgs import wArgs, ConversionError\n\n@wArgs\ndef schedule(when: datetime) -&gt; None:\n    print(f\"Scheduled: {when}\")\n\ndef test_invalid_datetime():\n    with pytest.raises(SystemExit):\n        schedule.run([\"--when\", \"invalid-date\"])\n</code></pre>"},{"location":"cookbook/testing/#testing-help-output","title":"Testing Help Output","text":"<pre><code>def test_help_output(capsys):\n    with pytest.raises(SystemExit) as exc_info:\n        greet.run([\"--help\"])\n\n    assert exc_info.value.code == 0\n    captured = capsys.readouterr()\n    assert \"Hello\" in captured.out or \"greet\" in captured.out\n</code></pre>"},{"location":"cookbook/testing/#integration-testing-with-subprocess","title":"Integration Testing with subprocess","text":"<p>For full integration testing:</p> <pre><code>import subprocess\nimport sys\n\ndef test_cli_integration():\n    result = subprocess.run(\n        [sys.executable, \"greet.py\", \"--name\", \"World\"],\n        capture_output=True,\n        text=True,\n    )\n    assert result.returncode == 0\n    assert \"Hello, World!\" in result.stdout\n\ndef test_cli_help():\n    result = subprocess.run(\n        [sys.executable, \"greet.py\", \"--help\"],\n        capture_output=True,\n        text=True,\n    )\n    assert result.returncode == 0\n    assert \"usage:\" in result.stdout\n</code></pre>"},{"location":"cookbook/testing/#mocking-dependencies","title":"Mocking Dependencies","text":"<pre><code>from unittest.mock import patch, MagicMock\nfrom wArgs import wArgs\n\n@wArgs\ndef fetch(url: str) -&gt; str:\n    import requests\n    return requests.get(url).text\n\ndef test_fetch_mocked():\n    with patch(\"requests.get\") as mock_get:\n        mock_get.return_value = MagicMock(text=\"mocked content\")\n        result = fetch.run([\"--url\", \"http://example.com\"])\n        assert result == \"mocked content\"\n        mock_get.assert_called_once_with(\"http://example.com\")\n</code></pre>"},{"location":"cookbook/testing/#best-practices","title":"Best Practices","text":"<ol> <li>Test both CLI and direct calls - Ensure both work correctly</li> <li>Use parameterized tests - Cover multiple input combinations</li> <li>Test error cases - Invalid input, missing arguments</li> <li>Capture output - Verify what's printed</li> <li>Test help output - Ensure documentation is correct</li> <li>Mock external dependencies - Keep tests fast and isolated</li> </ol>"},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.8 or higher</li> <li>No runtime dependencies</li> </ul>"},{"location":"getting-started/installation/#install-from-pypi","title":"Install from PyPI","text":"<p>The recommended way to install wArgs is via pip:</p> <pre><code>pip install wargs\n</code></pre>"},{"location":"getting-started/installation/#install-from-source","title":"Install from Source","text":"<p>To install the latest development version:</p> <pre><code>pip install git+https://github.com/wargs/wargs.git\n</code></pre> <p>Or clone and install locally:</p> <pre><code>git clone https://github.com/wargs/wargs.git\ncd wargs\npip install -e .\n</code></pre>"},{"location":"getting-started/installation/#development-installation","title":"Development Installation","text":"<p>For contributing to wArgs:</p> <pre><code>git clone https://github.com/wargs/wargs.git\ncd wargs\npip install -e \".[dev]\"\n</code></pre> <p>This installs all development dependencies including:</p> <ul> <li>pytest for testing</li> <li>mypy for type checking</li> <li>ruff for linting and formatting</li> </ul>"},{"location":"getting-started/installation/#verify-installation","title":"Verify Installation","text":"<pre><code>&gt;&gt;&gt; import wargs\n&gt;&gt;&gt; wargs.__version__\n'0.1.0'\n</code></pre> <p>Or from the command line:</p> <pre><code>python -c \"import wargs; print(wargs.__version__)\"\n</code></pre>"},{"location":"getting-started/installation/#optional-dependencies","title":"Optional Dependencies","text":""},{"location":"getting-started/installation/#documentation","title":"Documentation","text":"<p>To build the documentation locally:</p> <pre><code>pip install -e \".[docs]\"\nmkdocs serve\n</code></pre>"},{"location":"getting-started/installation/#all-dependencies","title":"All Dependencies","text":"<p>To install everything:</p> <pre><code>pip install -e \".[all]\"\n</code></pre>"},{"location":"getting-started/quickstart/","title":"Quick Start","text":"<p>This guide will get you up and running with wArgs in 5 minutes.</p>"},{"location":"getting-started/quickstart/#your-first-cli","title":"Your First CLI","text":"<p>Create a file called <code>greet.py</code>:</p> <pre><code>from wArgs import wArgs\n\n@wArgs\ndef greet(name: str, greeting: str = \"Hello\") -&gt; None:\n    \"\"\"Greet someone.\n\n    Args:\n        name: The person to greet\n        greeting: The greeting to use\n    \"\"\"\n    print(f\"{greeting}, {name}!\")\n\nif __name__ == \"__main__\":\n    greet()\n</code></pre> <p>Run it:</p> <pre><code>$ python greet.py --help\nusage: greet.py [-h] --name NAME [--greeting GREETING]\n\nGreet someone.\n\noptions:\n  -h, --help           show this help message and exit\n  --name NAME          The person to greet\n  --greeting GREETING  The greeting to use (default: 'Hello')\n\n$ python greet.py --name World\nHello, World!\n\n$ python greet.py --name Alice --greeting Hi\nHi, Alice!\n</code></pre>"},{"location":"getting-started/quickstart/#how-it-works","title":"How It Works","text":"<p>wArgs extracts everything it needs from your function:</p> Source Used For Function name Program name Docstring summary CLI description Parameter names Argument names (<code>--name</code>) Type hints Argument types and conversion Default values Optional vs required, default values Docstring <code>Args:</code> Help text for each argument"},{"location":"getting-started/quickstart/#type-conversion","title":"Type Conversion","text":"<p>wArgs automatically converts arguments based on type hints:</p> <pre><code>@wArgs\ndef process(\n    count: int,           # Converted to integer\n    rate: float,          # Converted to float\n    verbose: bool,        # Boolean flag (--verbose)\n    files: list[str],     # Multiple values (--files a.txt b.txt)\n) -&gt; None:\n    print(f\"Processing {count} items at {rate}x\")\n    if verbose:\n        print(f\"Files: {files}\")\n</code></pre> <pre><code>$ python process.py --count 5 --rate 1.5 --verbose --files a.txt b.txt\nProcessing 5 items at 1.5x\nFiles: ['a.txt', 'b.txt']\n</code></pre>"},{"location":"getting-started/quickstart/#boolean-flags","title":"Boolean Flags","text":"<p>Boolean parameters with <code>False</code> default become flags:</p> <pre><code>@wArgs\ndef build(debug: bool = False, optimize: bool = False) -&gt; None:\n    \"\"\"Build the project.\"\"\"\n    print(f\"Debug: {debug}, Optimize: {optimize}\")\n</code></pre> <pre><code>$ python build.py --debug\nDebug: True, Optimize: False\n\n$ python build.py --debug --optimize\nDebug: True, Optimize: True\n</code></pre>"},{"location":"getting-started/quickstart/#subcommands-with-classes","title":"Subcommands with Classes","text":"<p>Use a class to create subcommands:</p> <pre><code>from wArgs import wArgs\n\n@wArgs\nclass CLI:\n    \"\"\"File management tool.\"\"\"\n\n    def list(self, path: str = \".\") -&gt; None:\n        \"\"\"List files in a directory.\"\"\"\n        print(f\"Listing {path}\")\n\n    def copy(self, source: str, dest: str) -&gt; None:\n        \"\"\"Copy a file.\"\"\"\n        print(f\"Copying {source} to {dest}\")\n\nif __name__ == \"__main__\":\n    CLI()\n</code></pre> <pre><code>$ python files.py --help\nusage: files.py [-h] {list,copy} ...\n\nFile management tool.\n\npositional arguments:\n  {list,copy}\n    list       List files in a directory.\n    copy       Copy a file.\n\n$ python files.py list --path /tmp\nListing /tmp\n\n$ python files.py copy --source a.txt --dest b.txt\nCopying a.txt to b.txt\n</code></pre>"},{"location":"getting-started/quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>Tutorial - Build a complete CLI application step by step</li> <li>Basic Usage - Learn more about decorating functions</li> <li>Type System - All supported types</li> <li>Subcommands - Complex CLI hierarchies</li> </ul>"},{"location":"getting-started/tutorial/","title":"Tutorial: Building a Task Manager CLI","text":"<p>In this tutorial, we'll build a complete task manager CLI application from scratch, demonstrating all the key features of wArgs.</p>"},{"location":"getting-started/tutorial/#what-well-build","title":"What We'll Build","text":"<p>A command-line task manager with these features:</p> <ul> <li>Add, list, complete, and delete tasks</li> <li>Filter tasks by status</li> <li>Global options for output format</li> <li>Persistent storage in a JSON file</li> </ul>"},{"location":"getting-started/tutorial/#step-1-basic-structure","title":"Step 1: Basic Structure","text":"<p>Let's start with the project structure:</p> <pre><code>tasks/\n\u251c\u2500\u2500 tasks.py      # Main CLI\n\u2514\u2500\u2500 tasks.json    # Data file (auto-created)\n</code></pre> <p>Create <code>tasks.py</code> with a basic class structure:</p> <pre><code>from wArgs import wArgs\n\n@wArgs(prog=\"tasks\", description=\"A simple task manager\")\nclass Tasks:\n    \"\"\"Manage your tasks from the command line.\"\"\"\n\n    def add(self, title: str) -&gt; None:\n        \"\"\"Add a new task.\"\"\"\n        print(f\"Adding task: {title}\")\n\n    def list(self) -&gt; None:\n        \"\"\"List all tasks.\"\"\"\n        print(\"Listing tasks...\")\n\nif __name__ == \"__main__\":\n    Tasks()\n</code></pre> <p>Test it:</p> <pre><code>$ python tasks.py --help\nusage: tasks [-h] {add,list} ...\n\nManage your tasks from the command line.\n\n$ python tasks.py add --title \"Buy groceries\"\nAdding task: Buy groceries\n</code></pre>"},{"location":"getting-started/tutorial/#step-2-add-data-persistence","title":"Step 2: Add Data Persistence","text":"<p>Let's add actual storage functionality:</p> <pre><code>from __future__ import annotations\nimport json\nfrom pathlib import Path\nfrom wArgs import wArgs\n\nDATA_FILE = Path(\"tasks.json\")\n\ndef load_tasks() -&gt; list[dict]:\n    \"\"\"Load tasks from JSON file.\"\"\"\n    if DATA_FILE.exists():\n        return json.loads(DATA_FILE.read_text())\n    return []\n\ndef save_tasks(tasks: list[dict]) -&gt; None:\n    \"\"\"Save tasks to JSON file.\"\"\"\n    DATA_FILE.write_text(json.dumps(tasks, indent=2))\n\n@wArgs(prog=\"tasks\")\nclass Tasks:\n    \"\"\"Manage your tasks from the command line.\"\"\"\n\n    def add(self, title: str, priority: int = 1) -&gt; None:\n        \"\"\"Add a new task.\n\n        Args:\n            title: The task description\n            priority: Priority level (1=low, 2=medium, 3=high)\n        \"\"\"\n        tasks = load_tasks()\n        task = {\n            \"id\": len(tasks) + 1,\n            \"title\": title,\n            \"priority\": priority,\n            \"done\": False,\n        }\n        tasks.append(task)\n        save_tasks(tasks)\n        print(f\"Added task #{task['id']}: {title}\")\n\n    def list(self) -&gt; None:\n        \"\"\"List all tasks.\"\"\"\n        tasks = load_tasks()\n        if not tasks:\n            print(\"No tasks found.\")\n            return\n        for task in tasks:\n            status = \"x\" if task[\"done\"] else \" \"\n            print(f\"[{status}] #{task['id']} (P{task['priority']}): {task['title']}\")\n\nif __name__ == \"__main__\":\n    Tasks()\n</code></pre> <p>Test it:</p> <pre><code>$ python tasks.py add --title \"Buy groceries\" --priority 2\nAdded task #1: Buy groceries\n\n$ python tasks.py add --title \"Call mom\" --priority 3\nAdded task #2: Call mom\n\n$ python tasks.py list\n[ ] #1 (P2): Buy groceries\n[ ] #2 (P3): Call mom\n</code></pre>"},{"location":"getting-started/tutorial/#step-3-add-more-commands","title":"Step 3: Add More Commands","text":"<p>Let's add complete and delete commands:</p> <pre><code>from __future__ import annotations\nimport json\nfrom pathlib import Path\nfrom wArgs import wArgs\n\nDATA_FILE = Path(\"tasks.json\")\n\ndef load_tasks() -&gt; list[dict]:\n    if DATA_FILE.exists():\n        return json.loads(DATA_FILE.read_text())\n    return []\n\ndef save_tasks(tasks: list[dict]) -&gt; None:\n    DATA_FILE.write_text(json.dumps(tasks, indent=2))\n\ndef find_task(tasks: list[dict], task_id: int) -&gt; dict | None:\n    for task in tasks:\n        if task[\"id\"] == task_id:\n            return task\n    return None\n\n@wArgs(prog=\"tasks\")\nclass Tasks:\n    \"\"\"Manage your tasks from the command line.\"\"\"\n\n    def add(self, title: str, priority: int = 1) -&gt; None:\n        \"\"\"Add a new task.\n\n        Args:\n            title: The task description\n            priority: Priority level (1=low, 2=medium, 3=high)\n        \"\"\"\n        tasks = load_tasks()\n        task = {\n            \"id\": len(tasks) + 1,\n            \"title\": title,\n            \"priority\": priority,\n            \"done\": False,\n        }\n        tasks.append(task)\n        save_tasks(tasks)\n        print(f\"Added task #{task['id']}: {title}\")\n\n    def list(self, all: bool = False) -&gt; None:\n        \"\"\"List tasks.\n\n        Args:\n            all: Show completed tasks too\n        \"\"\"\n        tasks = load_tasks()\n        if not all:\n            tasks = [t for t in tasks if not t[\"done\"]]\n        if not tasks:\n            print(\"No tasks found.\")\n            return\n        for task in tasks:\n            status = \"x\" if task[\"done\"] else \" \"\n            print(f\"[{status}] #{task['id']} (P{task['priority']}): {task['title']}\")\n\n    def complete(self, task_id: int) -&gt; None:\n        \"\"\"Mark a task as complete.\n\n        Args:\n            task_id: The task ID to complete\n        \"\"\"\n        tasks = load_tasks()\n        task = find_task(tasks, task_id)\n        if task is None:\n            print(f\"Task #{task_id} not found.\")\n            return\n        task[\"done\"] = True\n        save_tasks(tasks)\n        print(f\"Completed task #{task_id}: {task['title']}\")\n\n    def delete(self, task_id: int) -&gt; None:\n        \"\"\"Delete a task.\n\n        Args:\n            task_id: The task ID to delete\n        \"\"\"\n        tasks = load_tasks()\n        task = find_task(tasks, task_id)\n        if task is None:\n            print(f\"Task #{task_id} not found.\")\n            return\n        tasks.remove(task)\n        save_tasks(tasks)\n        print(f\"Deleted task #{task_id}: {task['title']}\")\n\nif __name__ == \"__main__\":\n    Tasks()\n</code></pre> <pre><code>$ python tasks.py complete --task-id 1\nCompleted task #1: Buy groceries\n\n$ python tasks.py list\n[ ] #2 (P3): Call mom\n\n$ python tasks.py list --all\n[x] #1 (P2): Buy groceries\n[ ] #2 (P3): Call mom\n</code></pre>"},{"location":"getting-started/tutorial/#step-4-add-global-options","title":"Step 4: Add Global Options","text":"<p>Let's add a <code>--verbose</code> flag that affects all commands:</p> <pre><code>from __future__ import annotations\nimport json\nfrom pathlib import Path\nfrom wArgs import wArgs\n\nDATA_FILE = Path(\"tasks.json\")\n\ndef load_tasks() -&gt; list[dict]:\n    if DATA_FILE.exists():\n        return json.loads(DATA_FILE.read_text())\n    return []\n\ndef save_tasks(tasks: list[dict]) -&gt; None:\n    DATA_FILE.write_text(json.dumps(tasks, indent=2))\n\ndef find_task(tasks: list[dict], task_id: int) -&gt; dict | None:\n    for task in tasks:\n        if task[\"id\"] == task_id:\n            return task\n    return None\n\n@wArgs(prog=\"tasks\")\nclass Tasks:\n    \"\"\"Manage your tasks from the command line.\"\"\"\n\n    def __init__(self, verbose: bool = False) -&gt; None:\n        \"\"\"Initialize with global options.\n\n        Args:\n            verbose: Enable verbose output\n        \"\"\"\n        self.verbose = verbose\n\n    def _log(self, message: str) -&gt; None:\n        \"\"\"Print a message if verbose mode is enabled.\"\"\"\n        if self.verbose:\n            print(f\"[DEBUG] {message}\")\n\n    def add(self, title: str, priority: int = 1) -&gt; None:\n        \"\"\"Add a new task.\n\n        Args:\n            title: The task description\n            priority: Priority level (1=low, 2=medium, 3=high)\n        \"\"\"\n        self._log(f\"Loading tasks from {DATA_FILE}\")\n        tasks = load_tasks()\n        task = {\n            \"id\": len(tasks) + 1,\n            \"title\": title,\n            \"priority\": priority,\n            \"done\": False,\n        }\n        tasks.append(task)\n        self._log(f\"Saving {len(tasks)} tasks\")\n        save_tasks(tasks)\n        print(f\"Added task #{task['id']}: {title}\")\n\n    def list(self, all: bool = False) -&gt; None:\n        \"\"\"List tasks.\n\n        Args:\n            all: Show completed tasks too\n        \"\"\"\n        self._log(f\"Loading tasks from {DATA_FILE}\")\n        tasks = load_tasks()\n        if not all:\n            tasks = [t for t in tasks if not t[\"done\"]]\n        self._log(f\"Showing {len(tasks)} tasks\")\n        if not tasks:\n            print(\"No tasks found.\")\n            return\n        for task in tasks:\n            status = \"x\" if task[\"done\"] else \" \"\n            print(f\"[{status}] #{task['id']} (P{task['priority']}): {task['title']}\")\n\n    def complete(self, task_id: int) -&gt; None:\n        \"\"\"Mark a task as complete.\n\n        Args:\n            task_id: The task ID to complete\n        \"\"\"\n        tasks = load_tasks()\n        task = find_task(tasks, task_id)\n        if task is None:\n            print(f\"Task #{task_id} not found.\")\n            return\n        task[\"done\"] = True\n        save_tasks(tasks)\n        print(f\"Completed task #{task_id}: {task['title']}\")\n\n    def delete(self, task_id: int) -&gt; None:\n        \"\"\"Delete a task.\n\n        Args:\n            task_id: The task ID to delete\n        \"\"\"\n        tasks = load_tasks()\n        task = find_task(tasks, task_id)\n        if task is None:\n            print(f\"Task #{task_id} not found.\")\n            return\n        tasks.remove(task)\n        save_tasks(tasks)\n        print(f\"Deleted task #{task_id}: {task['title']}\")\n\nif __name__ == \"__main__\":\n    Tasks()\n</code></pre> <p>The <code>--verbose</code> flag now appears as a global option:</p> <pre><code>$ python tasks.py --help\nusage: tasks [-h] [--verbose] {add,list,complete,delete} ...\n\n$ python tasks.py --verbose list\n[DEBUG] Loading tasks from tasks.json\n[DEBUG] Showing 1 tasks\n[ ] #2 (P3): Call mom\n</code></pre>"},{"location":"getting-started/tutorial/#step-5-add-type-hints-for-choices","title":"Step 5: Add Type Hints for Choices","text":"<p>Let's use <code>Literal</code> to restrict priority values:</p> <pre><code>from __future__ import annotations\nimport json\nfrom pathlib import Path\nfrom typing import Literal\nfrom wArgs import wArgs\n\n# ... (same helper functions)\n\n@wArgs(prog=\"tasks\")\nclass Tasks:\n    \"\"\"Manage your tasks from the command line.\"\"\"\n\n    def __init__(self, verbose: bool = False) -&gt; None:\n        self.verbose = verbose\n\n    def add(\n        self,\n        title: str,\n        priority: Literal[\"low\", \"medium\", \"high\"] = \"medium\",\n    ) -&gt; None:\n        \"\"\"Add a new task.\n\n        Args:\n            title: The task description\n            priority: Priority level\n        \"\"\"\n        priority_map = {\"low\": 1, \"medium\": 2, \"high\": 3}\n        tasks = load_tasks()\n        task = {\n            \"id\": len(tasks) + 1,\n            \"title\": title,\n            \"priority\": priority_map[priority],\n            \"done\": False,\n        }\n        tasks.append(task)\n        save_tasks(tasks)\n        print(f\"Added task #{task['id']}: {title}\")\n\n    # ... (rest of methods)\n</code></pre> <pre><code>$ python tasks.py add --help\nusage: tasks add [-h] --title TITLE [--priority {low,medium,high}]\n\n$ python tasks.py add --title \"Learn wArgs\" --priority high\nAdded task #3: Learn wArgs\n</code></pre>"},{"location":"getting-started/tutorial/#step-6-using-arg-for-fine-control","title":"Step 6: Using Arg for Fine Control","text":"<p>Use <code>Arg</code> with <code>Annotated</code> for more control:</p> <pre><code>from typing import Annotated, Literal\nfrom wArgs import wArgs, Arg\n\n@wArgs(prog=\"tasks\")\nclass Tasks:\n    \"\"\"Manage your tasks from the command line.\"\"\"\n\n    def __init__(\n        self,\n        verbose: Annotated[bool, Arg(\"-v\", help=\"Enable verbose output\")] = False,\n    ) -&gt; None:\n        self.verbose = verbose\n\n    def add(\n        self,\n        title: Annotated[str, Arg(\"-t\", help=\"Task description\")],\n        priority: Annotated[\n            Literal[\"low\", \"medium\", \"high\"],\n            Arg(\"-p\", help=\"Priority level\"),\n        ] = \"medium\",\n    ) -&gt; None:\n        \"\"\"Add a new task.\"\"\"\n        # ...\n</code></pre> <p>Now you can use short flags:</p> <pre><code>$ python tasks.py -v add -t \"Quick task\" -p high\n[DEBUG] Loading tasks...\nAdded task #4: Quick task\n</code></pre>"},{"location":"getting-started/tutorial/#complete-example","title":"Complete Example","text":"<p>See the full working example in the examples/tasks directory.</p>"},{"location":"getting-started/tutorial/#whats-next","title":"What's Next?","text":"<ul> <li>Type System - Learn about all supported types</li> <li>Subcommands - More complex CLI hierarchies</li> <li>Inheritance - Share options with mixins</li> <li>Cookbook - Common patterns and recipes</li> </ul>"},{"location":"guide/advanced/","title":"Advanced Usage","text":"<p>This guide covers advanced wArgs features and patterns.</p>"},{"location":"guide/advanced/#the-arg-class","title":"The Arg Class","text":"<p>Use <code>Arg</code> with <code>Annotated</code> for fine-grained control:</p> <pre><code>from typing import Annotated\nfrom wArgs import wArgs, Arg\n\n@wArgs\ndef process(\n    input_file: Annotated[str, Arg(\"-i\", help=\"Input file path\")],\n    output: Annotated[str, Arg(\"-o\", \"--out\", help=\"Output file\")] = \"out.txt\",\n    verbose: Annotated[bool, Arg(\"-v\")] = False,\n) -&gt; None:\n    \"\"\"Process files.\"\"\"\n    ...\n</code></pre> <pre><code>$ python app.py -i data.txt -o result.txt -v\n$ python app.py --input-file data.txt --out result.txt --verbose\n</code></pre>"},{"location":"guide/advanced/#arg-parameters","title":"Arg Parameters","text":"Parameter Description <code>short</code> Short flag like <code>-n</code> <code>long</code> Long flag override <code>help</code> Help text <code>metavar</code> Placeholder in help <code>choices</code> Valid values <code>action</code> argparse action <code>nargs</code> Number of values <code>default</code> Default value override <code>required</code> Override required status <code>dest</code> Destination attribute <code>group</code> Argument group name <code>mutually_exclusive</code> Exclusive group name <code>positional</code> Make positional <code>hidden</code> Hide from help <code>skip</code> Skip this parameter <code>envvar</code> Environment variable"},{"location":"guide/advanced/#positional-arguments","title":"Positional Arguments","text":"<p>Make arguments positional:</p> <pre><code>@wArgs\ndef copy(\n    source: Annotated[str, Arg(positional=True)],\n    dest: Annotated[str, Arg(positional=True)],\n) -&gt; None:\n    \"\"\"Copy source to dest.\"\"\"\n    print(f\"Copying {source} to {dest}\")\n</code></pre> <pre><code>$ python copy.py source.txt dest.txt\nCopying source.txt to dest.txt\n</code></pre>"},{"location":"guide/advanced/#hidden-arguments","title":"Hidden Arguments","text":"<p>Hide arguments from help (useful for debugging):</p> <pre><code>@wArgs\ndef deploy(\n    env: str,\n    debug_mode: Annotated[bool, Arg(hidden=True)] = False,\n) -&gt; None:\n    \"\"\"Deploy application.\"\"\"\n    if debug_mode:\n        print(\"Debug mode enabled\")\n</code></pre> <pre><code>$ python app.py --help\n# --debug-mode is not shown\n\n$ python app.py --env prod --debug-mode\nDebug mode enabled\n</code></pre>"},{"location":"guide/advanced/#skipping-parameters","title":"Skipping Parameters","text":"<p>Skip parameters that shouldn't become arguments:</p> <pre><code>@wArgs\ndef process(\n    data: str,\n    _internal: Annotated[str, Arg(skip=True)] = \"default\",\n) -&gt; None:\n    \"\"\"Process data.\"\"\"\n    print(f\"Data: {data}, Internal: {_internal}\")\n</code></pre>"},{"location":"guide/advanced/#argument-groups","title":"Argument Groups","text":"<p>Organize arguments into groups:</p> <pre><code>@wArgs\ndef server(\n    host: Annotated[str, Arg(group=\"Network\")] = \"localhost\",\n    port: Annotated[int, Arg(group=\"Network\")] = 8080,\n    debug: Annotated[bool, Arg(group=\"Development\")] = False,\n    reload: Annotated[bool, Arg(group=\"Development\")] = False,\n) -&gt; None:\n    \"\"\"Start the server.\"\"\"\n    ...\n</code></pre> <pre><code>$ python server.py --help\nNetwork:\n  --host HOST\n  --port PORT\n\nDevelopment:\n  --debug\n  --reload\n</code></pre>"},{"location":"guide/advanced/#mutually-exclusive-options","title":"Mutually Exclusive Options","text":"<pre><code>@wArgs\ndef output(\n    json: Annotated[bool, Arg(mutually_exclusive=\"format\")] = False,\n    xml: Annotated[bool, Arg(mutually_exclusive=\"format\")] = False,\n    csv: Annotated[bool, Arg(mutually_exclusive=\"format\")] = False,\n) -&gt; None:\n    \"\"\"Output data in a format.\"\"\"\n    if json:\n        print(\"JSON output\")\n    elif xml:\n        print(\"XML output\")\n    elif csv:\n        print(\"CSV output\")\n</code></pre> <pre><code>$ python app.py --json --xml\n# Error: --json and --xml are mutually exclusive\n</code></pre>"},{"location":"guide/advanced/#custom-metavar","title":"Custom Metavar","text":"<pre><code>@wArgs\ndef download(\n    url: Annotated[str, Arg(metavar=\"URL\")],\n    output: Annotated[str, Arg(\"-o\", metavar=\"FILE\")] = \"output.html\",\n) -&gt; None:\n    \"\"\"Download a file.\"\"\"\n    ...\n</code></pre> <pre><code>$ python app.py --help\n  url URL\n  -o FILE, --output FILE\n</code></pre>"},{"location":"guide/advanced/#custom-converters","title":"Custom Converters","text":"<p>Register converters for custom types:</p> <pre><code>from wArgs import wArgs, converter\n\nclass IPAddress:\n    def __init__(self, address: str) -&gt; None:\n        parts = address.split(\".\")\n        if len(parts) != 4:\n            raise ValueError(\"Invalid IP address\")\n        self.parts = [int(p) for p in parts]\n\n    def __str__(self) -&gt; str:\n        return \".\".join(str(p) for p in self.parts)\n\n@converter(IPAddress)\ndef convert_ip(value: str) -&gt; IPAddress:\n    return IPAddress(value)\n\n@wArgs\ndef ping(host: IPAddress) -&gt; None:\n    \"\"\"Ping a host.\"\"\"\n    print(f\"Pinging {host}\")\n</code></pre>"},{"location":"guide/advanced/#converter-registry","title":"Converter Registry","text":"<pre><code>from wArgs import ConverterRegistry, get_default_registry\n\n# Get the default registry\nregistry = get_default_registry()\n\n# Register a converter\nregistry.register(MyType, my_converter)\n\n# Check if registered\nif registry.has(MyType):\n    ...\n\n# Get a converter\nconv = registry.get(MyType)\n</code></pre>"},{"location":"guide/advanced/#accessing-internal-config","title":"Accessing Internal Config","text":"<pre><code>from wArgs import wArgs, get_config, get_parser\n\n@wArgs\ndef my_command(name: str) -&gt; None:\n    ...\n\n# Get the ParserConfig\nconfig = get_config(my_command)\nfor arg in config.arguments:\n    print(f\"{arg.name}: {arg.flags}\")\n\n# Get the ArgumentParser\nparser = get_parser(my_command)\n</code></pre>"},{"location":"guide/advanced/#environment-variables","title":"Environment Variables","text":"<pre><code>import os\nfrom typing import Annotated\nfrom wArgs import wArgs, Arg\n\n@wArgs\ndef connect(\n    host: Annotated[str, Arg(envvar=\"DB_HOST\")] = \"localhost\",\n    password: Annotated[str, Arg(envvar=\"DB_PASSWORD\")] = \"\",\n) -&gt; None:\n    \"\"\"Connect to database.\"\"\"\n    print(f\"Connecting to {host}\")\n</code></pre> <pre><code>$ DB_HOST=prod.example.com python app.py\nConnecting to prod.example.com\n</code></pre>"},{"location":"guide/advanced/#debugging","title":"Debugging","text":""},{"location":"guide/advanced/#explain-function","title":"explain() Function","text":"<pre><code>from wArgs import explain\n\nprint(explain(my_command))\nprint(explain(my_command, verbose=True))\n</code></pre>"},{"location":"guide/advanced/#wargs_debug-environment-variable","title":"WARGS_DEBUG Environment Variable","text":"<pre><code>$ WARGS_DEBUG=1 python app.py --name test\n[wargs] Building parser for function: app\n[wargs] Parsing args: ['--name', 'test']\n[wargs] Parsed result: Namespace(name='test')\n</code></pre>"},{"location":"guide/advanced/#_wargs_config-attribute","title":"_wargs_config Attribute","text":"<pre><code>@wArgs\ndef my_command(name: str) -&gt; None:\n    ...\n\n# After parser is built\n_ = my_command.parser\nconfig = my_command._wargs_config\n</code></pre>"},{"location":"guide/advanced/#testing-clis","title":"Testing CLIs","text":"<pre><code>import pytest\nfrom wArgs import wArgs\n\n@wArgs\ndef greet(name: str) -&gt; str:\n    return f\"Hello, {name}!\"\n\ndef test_greet_cli():\n    result = greet.run([\"--name\", \"World\"])\n    assert result == \"Hello, World!\"\n\ndef test_greet_direct():\n    result = greet(name=\"Test\")\n    assert result == \"Hello, Test!\"\n\ndef test_greet_parser():\n    args = greet.parse_args([\"--name\", \"Parse\"])\n    assert args.name == \"Parse\"\n</code></pre>"},{"location":"guide/advanced/#best-practices","title":"Best Practices","text":"<ol> <li>Use type hints for automatic conversion</li> <li>Write docstrings for help text</li> <li>Use Arg sparingly - only when needed</li> <li>Keep global options simple in class CLIs</li> <li>Test both CLI and direct call modes</li> </ol>"},{"location":"guide/basic-usage/","title":"Basic Usage","text":"<p>This guide covers the fundamentals of using wArgs to create CLI applications.</p>"},{"location":"guide/basic-usage/#the-wargs-decorator","title":"The @wArgs Decorator","text":"<p>The <code>@wArgs</code> decorator transforms a function or class into a CLI:</p> <pre><code>from wArgs import wArgs\n\n@wArgs\ndef my_command(name: str) -&gt; None:\n    \"\"\"Do something with a name.\"\"\"\n    print(f\"Hello, {name}!\")\n</code></pre>"},{"location":"guide/basic-usage/#with-options","title":"With Options","text":"<p>You can pass options to customize the CLI:</p> <pre><code>@wArgs(\n    prog=\"myapp\",           # Program name in help\n    description=\"My app\",    # Override docstring description\n    add_help=True,          # Add -h/--help (default: True)\n)\ndef my_command(name: str) -&gt; None:\n    ...\n</code></pre>"},{"location":"guide/basic-usage/#parameters-to-arguments","title":"Parameters to Arguments","text":"<p>wArgs converts function parameters to CLI arguments:</p> Parameter CLI Argument <code>name: str</code> <code>--name NAME</code> (required) <code>name: str = \"default\"</code> <code>--name NAME</code> (optional, default: \"default\") <code>verbose: bool = False</code> <code>--verbose</code> (flag) <code>count: int = 1</code> <code>--count COUNT</code> (optional, converted to int)"},{"location":"guide/basic-usage/#naming-conventions","title":"Naming Conventions","text":"<p>Python underscores become CLI hyphens:</p> <pre><code>@wArgs\ndef process(input_file: str, output_dir: str) -&gt; None:\n    ...\n</code></pre> <pre><code>$ python app.py --input-file data.txt --output-dir ./out\n</code></pre>"},{"location":"guide/basic-usage/#required-vs-optional","title":"Required vs Optional","text":"<p>Arguments are required if they have no default value:</p> <pre><code>@wArgs\ndef greet(\n    name: str,              # Required\n    greeting: str = \"Hi\",   # Optional (default: \"Hi\")\n) -&gt; None:\n    print(f\"{greeting}, {name}!\")\n</code></pre> <pre><code>$ python greet.py --name World\nHi, World!\n\n$ python greet.py\n# Error: --name is required\n</code></pre>"},{"location":"guide/basic-usage/#boolean-flags","title":"Boolean Flags","text":"<p>Boolean parameters with <code>False</code> default become flags:</p> <pre><code>@wArgs\ndef build(\n    debug: bool = False,     # --debug flag\n    optimize: bool = False,  # --optimize flag\n) -&gt; None:\n    print(f\"Debug: {debug}, Optimize: {optimize}\")\n</code></pre> <pre><code>$ python build.py\nDebug: False, Optimize: False\n\n$ python build.py --debug\nDebug: True, Optimize: False\n\n$ python build.py --debug --optimize\nDebug: True, Optimize: True\n</code></pre> <p>Note</p> <p>Only <code>bool</code> parameters with <code>False</code> as default become flags. Other boolean parameters work like regular arguments.</p>"},{"location":"guide/basic-usage/#calling-decorated-functions","title":"Calling Decorated Functions","text":"<p>Decorated functions can be called in multiple ways:</p>"},{"location":"guide/basic-usage/#cli-mode-no-arguments","title":"CLI Mode (no arguments)","text":"<p>When called without arguments, parses <code>sys.argv</code>:</p> <pre><code>if __name__ == \"__main__\":\n    my_command()  # Parses CLI arguments\n</code></pre>"},{"location":"guide/basic-usage/#direct-call-with-arguments","title":"Direct Call (with arguments)","text":"<p>When called with arguments, bypasses CLI parsing:</p> <pre><code># Direct call - no CLI parsing\nmy_command(name=\"World\")\n\n# Also works with positional args\nmy_command(\"World\")\n</code></pre>"},{"location":"guide/basic-usage/#explicit-parsing","title":"Explicit Parsing","text":"<p>Use <code>.run()</code> or <code>.parse_args()</code> for explicit control:</p> <pre><code># Parse and execute\nresult = my_command.run([\"--name\", \"World\"])\n\n# Just parse, don't execute\nargs = my_command.parse_args([\"--name\", \"World\"])\nprint(args.name)  # \"World\"\n</code></pre>"},{"location":"guide/basic-usage/#accessing-the-parser","title":"Accessing the Parser","text":"<p>Get the underlying <code>ArgumentParser</code>:</p> <pre><code>from wArgs import wArgs, get_parser\n\n@wArgs\ndef my_command(name: str) -&gt; None:\n    ...\n\n# Get the parser\nparser = get_parser(my_command)\n\n# Or via property\nparser = my_command.parser\n\n# Extend it if needed\nparser.add_argument(\"--extra\", help=\"Extra option\")\n</code></pre>"},{"location":"guide/basic-usage/#debugging-with-explain","title":"Debugging with explain()","text":"<p>Use <code>explain()</code> to see how wArgs interprets your function:</p> <pre><code>from wArgs import wArgs, explain\n\n@wArgs\ndef greet(name: str, count: int = 1) -&gt; None:\n    \"\"\"Greet someone.\n\n    Args:\n        name: Person to greet\n        count: Number of times\n    \"\"\"\n    ...\n\nprint(explain(greet))\n</code></pre> <p>Output:</p> <pre><code>Function: greet\nType: Single-command CLI\n\nArguments:\n  --name (str) [required]\n  --count (int) [default: 1]\n</code></pre> <p>Use <code>verbose=True</code> for more detail:</p> <pre><code>print(explain(greet, verbose=True))\n</code></pre>"},{"location":"guide/basic-usage/#debug-output","title":"Debug Output","text":"<p>Set <code>WARGS_DEBUG=1</code> for debug output:</p> <pre><code>$ WARGS_DEBUG=1 python greet.py --name World\n[wargs] Building parser for function: greet\n[wargs] Parsing args: ['--name', 'World']\n[wargs] Parsed result: Namespace(name='World', count=1)\nHello, World!\n</code></pre>"},{"location":"guide/basic-usage/#next-steps","title":"Next Steps","text":"<ul> <li>Type System - All supported types</li> <li>Docstrings - Help text from docstrings</li> <li>Subcommands - Class-based CLIs</li> </ul>"},{"location":"guide/docstrings/","title":"Docstrings","text":"<p>wArgs extracts help text from docstrings automatically. It supports three major docstring formats.</p>"},{"location":"guide/docstrings/#supported-formats","title":"Supported Formats","text":"<p>wArgs auto-detects and parses:</p> <ul> <li>Google style (recommended)</li> <li>NumPy style</li> <li>Sphinx (reST) style</li> </ul>"},{"location":"guide/docstrings/#google-style","title":"Google Style","text":"<p>The most common format, used by Google and many Python projects:</p> <pre><code>@wArgs\ndef greet(name: str, times: int = 1) -&gt; None:\n    \"\"\"Greet someone multiple times.\n\n    A longer description can go here. It will be used\n    as the epilog in help output.\n\n    Args:\n        name: The name of the person to greet.\n        times: How many times to greet them.\n\n    Returns:\n        None\n\n    Raises:\n        ValueError: If times is negative.\n    \"\"\"\n    for _ in range(times):\n        print(f\"Hello, {name}!\")\n</code></pre> <pre><code>$ python greet.py --help\nusage: greet.py [-h] --name NAME [--times TIMES]\n\nGreet someone multiple times.\n\noptions:\n  -h, --help     show this help message and exit\n  --name NAME    The name of the person to greet.\n  --times TIMES  How many times to greet them. (default: 1)\n</code></pre>"},{"location":"guide/docstrings/#numpy-style","title":"NumPy Style","text":"<p>Popular in scientific Python projects:</p> <pre><code>@wArgs\ndef process(data: str, verbose: bool = False) -&gt; None:\n    \"\"\"Process input data.\n\n    Parameters\n    ----------\n    data : str\n        The input data to process.\n    verbose : bool, optional\n        Enable verbose output.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    ...\n</code></pre>"},{"location":"guide/docstrings/#sphinx-style","title":"Sphinx Style","text":"<p>Used in Sphinx documentation:</p> <pre><code>@wArgs\ndef calculate(x: float, y: float) -&gt; None:\n    \"\"\"Calculate something.\n\n    :param x: The first value.\n    :param y: The second value.\n    :type x: float\n    :type y: float\n    :returns: None\n    :raises ValueError: If values are invalid.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"guide/docstrings/#description-extraction","title":"Description Extraction","text":"<p>The first line or paragraph becomes the CLI description:</p> <pre><code>@wArgs\ndef my_command() -&gt; None:\n    \"\"\"This is the description.\n\n    This is additional detail that may be shown\n    in extended help.\n    \"\"\"\n    ...\n</code></pre> <pre><code>$ python app.py --help\nusage: app.py [-h]\n\nThis is the description.\n</code></pre>"},{"location":"guide/docstrings/#parameter-descriptions","title":"Parameter Descriptions","text":"<p>Parameter descriptions become argument help text:</p> <pre><code>@wArgs\ndef copy(\n    source: str,\n    dest: str,\n    recursive: bool = False,\n) -&gt; None:\n    \"\"\"Copy files.\n\n    Args:\n        source: Source file or directory path.\n        dest: Destination path.\n        recursive: Copy directories recursively.\n    \"\"\"\n    ...\n</code></pre> <pre><code>$ python copy.py --help\n  --source SOURCE      Source file or directory path.\n  --dest DEST          Destination path.\n  --recursive          Copy directories recursively.\n</code></pre>"},{"location":"guide/docstrings/#multi-line-descriptions","title":"Multi-line Descriptions","text":"<p>Long descriptions are preserved:</p> <pre><code>@wArgs\ndef deploy(env: str) -&gt; None:\n    \"\"\"Deploy the application.\n\n    Args:\n        env: Target environment. Valid values are 'dev',\n            'staging', and 'prod'. The deployment process\n            varies based on the environment.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"guide/docstrings/#class-docstrings","title":"Class Docstrings","text":"<p>For class-based CLIs, the class docstring becomes the main description:</p> <pre><code>@wArgs\nclass CLI:\n    \"\"\"File management utility.\n\n    A comprehensive tool for managing files and directories.\n    Supports common operations like copy, move, and delete.\n    \"\"\"\n\n    def copy(self, source: str, dest: str) -&gt; None:\n        \"\"\"Copy a file.\n\n        Args:\n            source: Source file path.\n            dest: Destination path.\n        \"\"\"\n        ...\n\n    def move(self, source: str, dest: str) -&gt; None:\n        \"\"\"Move a file.\n\n        Args:\n            source: Source file path.\n            dest: Destination path.\n        \"\"\"\n        ...\n</code></pre> <pre><code>$ python files.py --help\nusage: files.py [-h] {copy,move} ...\n\nFile management utility.\n\npositional arguments:\n  {copy,move}\n    copy       Copy a file.\n    move       Move a file.\n</code></pre>"},{"location":"guide/docstrings/#combining-with-arg","title":"Combining with Arg","text":"<p>When using <code>Arg</code>, the <code>help</code> parameter overrides the docstring:</p> <pre><code>from typing import Annotated\nfrom wArgs import wArgs, Arg\n\n@wArgs\ndef greet(\n    name: Annotated[str, Arg(help=\"Name to greet (overrides docstring)\")],\n) -&gt; None:\n    \"\"\"Greet someone.\n\n    Args:\n        name: This description is ignored.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"guide/docstrings/#best-practices","title":"Best Practices","text":"<ol> <li>Keep the first line concise - It becomes the CLI description</li> <li>Document all parameters - They become --help text</li> <li>Be consistent - Pick one docstring style and stick with it</li> <li>Include defaults context - Explain what default values mean</li> </ol> <pre><code>@wArgs\ndef backup(\n    path: str,\n    compress: bool = True,\n    level: int = 6,\n) -&gt; None:\n    \"\"\"Backup files to archive.\n\n    Args:\n        path: Directory to backup.\n        compress: Enable compression. Enabled by default for\n            smaller archive sizes.\n        level: Compression level from 1 (fastest) to 9 (smallest).\n            Default of 6 provides good balance.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"guide/inheritance/","title":"Inheritance","text":"<p>wArgs supports inheriting CLI options from parent classes, enabling reusable option sets through mixins.</p>"},{"location":"guide/inheritance/#basic-inheritance","title":"Basic Inheritance","text":"<p>Child classes inherit parent <code>__init__</code> parameters:</p> <pre><code>from wArgs import wArgs\n\nclass BaseOptions:\n    def __init__(self, verbose: bool = False) -&gt; None:\n        self.verbose = verbose\n\n@wArgs\nclass CLI(BaseOptions):\n    def __init__(self, name: str) -&gt; None:\n        super().__init__()\n        self.name = name\n\n    def run(self) -&gt; None:\n        \"\"\"Run the command.\"\"\"\n        if self.verbose:\n            print(f\"Running with name: {self.name}\")\n        print(f\"Hello, {self.name}!\")\n</code></pre> <pre><code>$ python app.py --help\nusage: app.py [-h] --name NAME [--verbose] {run} ...\n\noptions:\n  --name NAME\n  --verbose\n\n$ python app.py --verbose --name World run\nRunning with name: World\nHello, World!\n</code></pre>"},{"location":"guide/inheritance/#mixin-pattern","title":"Mixin Pattern","text":"<p>Create reusable option sets with mixins:</p> <pre><code>from wArgs import wArgs\n\nclass VerboseMixin:\n    \"\"\"Adds --verbose option.\"\"\"\n    def __init__(self, verbose: bool = False, **kwargs) -&gt; None:\n        super().__init__(**kwargs)\n        self.verbose = verbose\n\nclass DryRunMixin:\n    \"\"\"Adds --dry-run option.\"\"\"\n    def __init__(self, dry_run: bool = False, **kwargs) -&gt; None:\n        super().__init__(**kwargs)\n        self.dry_run = dry_run\n\nclass ConfigMixin:\n    \"\"\"Adds --config option.\"\"\"\n    def __init__(self, config: str = \"config.yml\", **kwargs) -&gt; None:\n        super().__init__(**kwargs)\n        self.config = config\n\n@wArgs\nclass CLI(VerboseMixin, DryRunMixin, ConfigMixin):\n    \"\"\"A CLI with multiple inherited options.\"\"\"\n\n    def __init__(self, **kwargs) -&gt; None:\n        super().__init__(**kwargs)\n\n    def deploy(self, env: str) -&gt; None:\n        \"\"\"Deploy to an environment.\"\"\"\n        if self.verbose:\n            print(f\"Using config: {self.config}\")\n            print(f\"Deploying to: {env}\")\n        if self.dry_run:\n            print(\"(dry run)\")\n        else:\n            print(f\"Deployed to {env}!\")\n</code></pre> <pre><code>$ python app.py --help\noptions:\n  --verbose\n  --dry-run\n  --config CONFIG\n\n$ python app.py --verbose --dry-run deploy --env prod\nUsing config: config.yml\nDeploying to: prod\n(dry run)\n</code></pre>"},{"location":"guide/inheritance/#how-mro-traversal-works","title":"How MRO Traversal Works","text":"<p>wArgs traverses the Method Resolution Order (MRO) to collect parameters:</p> <pre><code>class A:\n    def __init__(self, a: str = \"a\") -&gt; None:\n        self.a = a\n\nclass B(A):\n    def __init__(self, b: str = \"b\") -&gt; None:\n        super().__init__()\n        self.b = b\n\n@wArgs\nclass C(B):\n    def __init__(self, c: str = \"c\") -&gt; None:\n        super().__init__()\n        self.c = c\n\n    def run(self) -&gt; None:\n        print(f\"a={self.a}, b={self.b}, c={self.c}\")\n</code></pre> <p>The MRO for <code>C</code> is: <code>[C, B, A, object]</code></p> <p>wArgs collects parameters from all classes, resulting in <code>--a</code>, <code>--b</code>, and <code>--c</code> options.</p>"},{"location":"guide/inheritance/#parameter-override","title":"Parameter Override","text":"<p>Child parameters override parent parameters with the same name:</p> <pre><code>class Base:\n    def __init__(self, level: int = 1) -&gt; None:\n        self.level = level\n\n@wArgs\nclass Child(Base):\n    def __init__(self, level: int = 5) -&gt; None:  # Override default\n        super().__init__(level)\n        self.level = level\n\n    def show(self) -&gt; None:\n        print(f\"Level: {self.level}\")\n</code></pre> <pre><code>$ python app.py show\nLevel: 5  # Uses child's default\n</code></pre>"},{"location":"guide/inheritance/#type-conflict-warning","title":"Type Conflict Warning","text":"<p>wArgs warns when child and parent have conflicting types:</p> <pre><code>class Base:\n    def __init__(self, value: str = \"default\") -&gt; None:\n        self.value = value\n\n@wArgs\nclass Child(Base):\n    def __init__(self, value: int = 0) -&gt; None:  # Different type!\n        super().__init__(str(value))\n        self.value = value\n</code></pre> <pre><code>UserWarning: Parameter 'value' in Child has type int but parent Base\nhas type str. Using child type.\n</code></pre>"},{"location":"guide/inheritance/#disabling-mro-traversal","title":"Disabling MRO Traversal","text":"<p>Use <code>traverse_mro=False</code> to disable inheritance:</p> <pre><code>class Base:\n    def __init__(self, debug: bool = False) -&gt; None:\n        self.debug = debug\n\n@wArgs(traverse_mro=False)\nclass CLI(Base):\n    def __init__(self, name: str) -&gt; None:\n        super().__init__()\n        self.name = name\n\n    def run(self) -&gt; None:\n        print(f\"Name: {self.name}\")\n</code></pre> <pre><code>$ python app.py --help\n# Only shows --name, not --debug\n</code></pre>"},{"location":"guide/inheritance/#cooperative-inheritance","title":"Cooperative Inheritance","text":"<p>For multiple inheritance to work correctly, use <code>**kwargs</code>:</p> <pre><code>class Mixin1:\n    def __init__(self, opt1: bool = False, **kwargs) -&gt; None:\n        super().__init__(**kwargs)\n        self.opt1 = opt1\n\nclass Mixin2:\n    def __init__(self, opt2: bool = False, **kwargs) -&gt; None:\n        super().__init__(**kwargs)\n        self.opt2 = opt2\n\n@wArgs\nclass CLI(Mixin1, Mixin2):\n    def __init__(self, name: str, **kwargs) -&gt; None:\n        super().__init__(**kwargs)\n        self.name = name\n\n    def run(self) -&gt; None:\n        print(f\"name={self.name}, opt1={self.opt1}, opt2={self.opt2}\")\n</code></pre> <p>The <code>**kwargs</code> pattern ensures all parameters are passed through the chain.</p>"},{"location":"guide/inheritance/#best-practices","title":"Best Practices","text":"<ol> <li>Use <code>**kwargs</code> in mixins for cooperative inheritance</li> <li>Keep mixin options optional with sensible defaults</li> <li>Document inherited options in the class docstring</li> <li>Avoid type conflicts between parent and child</li> </ol> <pre><code>class VerboseMixin:\n    \"\"\"Adds verbose output support.\n\n    Inherited Options:\n        --verbose: Enable verbose output\n    \"\"\"\n    def __init__(self, verbose: bool = False, **kwargs) -&gt; None:\n        super().__init__(**kwargs)\n        self.verbose = verbose\n\n    def log(self, message: str) -&gt; None:\n        \"\"\"Print message if verbose mode is enabled.\"\"\"\n        if self.verbose:\n            print(f\"[INFO] {message}\")\n</code></pre>"},{"location":"guide/subcommands/","title":"Subcommands","text":"<p>wArgs supports building complex CLI applications with subcommands using classes.</p>"},{"location":"guide/subcommands/#basic-class-cli","title":"Basic Class CLI","text":"<p>Decorate a class to turn its methods into subcommands:</p> <pre><code>from wArgs import wArgs\n\n@wArgs\nclass Calculator:\n    \"\"\"A simple calculator.\"\"\"\n\n    def add(self, a: int, b: int) -&gt; None:\n        \"\"\"Add two numbers.\"\"\"\n        print(a + b)\n\n    def subtract(self, a: int, b: int) -&gt; None:\n        \"\"\"Subtract two numbers.\"\"\"\n        print(a - b)\n\nif __name__ == \"__main__\":\n    Calculator()\n</code></pre> <pre><code>$ python calc.py --help\nusage: calc.py [-h] {add,subtract} ...\n\nA simple calculator.\n\npositional arguments:\n  {add,subtract}\n    add           Add two numbers.\n    subtract      Subtract two numbers.\n\n$ python calc.py add --a 5 --b 3\n8\n\n$ python calc.py subtract --a 10 --b 4\n6\n</code></pre>"},{"location":"guide/subcommands/#method-naming","title":"Method Naming","text":"<p>Python method names with underscores become hyphenated subcommands:</p> <pre><code>@wArgs\nclass CLI:\n    def list_users(self) -&gt; None:\n        \"\"\"List all users.\"\"\"\n        ...\n\n    def add_user(self, name: str) -&gt; None:\n        \"\"\"Add a new user.\"\"\"\n        ...\n</code></pre> <pre><code>$ python app.py list-users\n$ python app.py add-user --name alice\n</code></pre>"},{"location":"guide/subcommands/#private-methods","title":"Private Methods","text":"<p>Methods starting with <code>_</code> are excluded from subcommands:</p> <pre><code>@wArgs\nclass CLI:\n    def public(self) -&gt; None:\n        \"\"\"This is a subcommand.\"\"\"\n        self._helper()\n\n    def _helper(self) -&gt; None:\n        \"\"\"This is NOT a subcommand.\"\"\"\n        print(\"Helper method\")\n</code></pre> <pre><code>$ python app.py --help\n  {public}\n    public    This is a subcommand.\n# _helper is not listed\n</code></pre>"},{"location":"guide/subcommands/#global-options","title":"Global Options","text":"<p>Parameters in <code>__init__</code> become global options:</p> <pre><code>@wArgs\nclass CLI:\n    \"\"\"File manager with global options.\"\"\"\n\n    def __init__(self, verbose: bool = False, dry_run: bool = False) -&gt; None:\n        \"\"\"Initialize with global options.\n\n        Args:\n            verbose: Enable verbose output.\n            dry_run: Don't actually perform operations.\n        \"\"\"\n        self.verbose = verbose\n        self.dry_run = dry_run\n\n    def delete(self, path: str) -&gt; None:\n        \"\"\"Delete a file.\"\"\"\n        if self.verbose:\n            print(f\"Deleting: {path}\")\n        if not self.dry_run:\n            print(f\"Deleted: {path}\")\n        else:\n            print(\"(dry run - not deleted)\")\n\n    def copy(self, source: str, dest: str) -&gt; None:\n        \"\"\"Copy a file.\"\"\"\n        if self.verbose:\n            print(f\"Copying: {source} -&gt; {dest}\")\n        if not self.dry_run:\n            print(f\"Copied: {source} -&gt; {dest}\")\n</code></pre> <pre><code>$ python files.py --help\nusage: files.py [-h] [--verbose] [--dry-run] {delete,copy} ...\n\nFile manager with global options.\n\noptions:\n  --verbose   Enable verbose output.\n  --dry-run   Don't actually perform operations.\n\n$ python files.py --verbose --dry-run delete --path test.txt\nDeleting: test.txt\n(dry run - not deleted)\n</code></pre> <p>Global options must come before the subcommand:</p> <pre><code>$ python files.py --verbose delete --path test.txt  # Correct\n$ python files.py delete --verbose --path test.txt  # Wrong!\n</code></pre>"},{"location":"guide/subcommands/#subcommand-help","title":"Subcommand Help","text":"<p>Each subcommand has its own help:</p> <pre><code>$ python calc.py add --help\nusage: calc.py add [-h] --a A --b B\n\nAdd two numbers.\n\noptions:\n  -h, --help  show this help message and exit\n  --a A\n  --b B\n</code></pre>"},{"location":"guide/subcommands/#combining-global-and-local-options","title":"Combining Global and Local Options","text":"<pre><code>@wArgs\nclass CLI:\n    def __init__(self, config: str = \"config.yml\") -&gt; None:\n        \"\"\"Global options.\n\n        Args:\n            config: Path to configuration file.\n        \"\"\"\n        self.config = config\n\n    def deploy(self, env: str, force: bool = False) -&gt; None:\n        \"\"\"Deploy the application.\n\n        Args:\n            env: Target environment.\n            force: Force deployment even if checks fail.\n        \"\"\"\n        print(f\"Using config: {self.config}\")\n        print(f\"Deploying to: {env}\")\n        if force:\n            print(\"Force mode enabled\")\n</code></pre> <pre><code>$ python app.py --config prod.yml deploy --env production --force\nUsing config: prod.yml\nDeploying to: production\nForce mode enabled\n</code></pre>"},{"location":"guide/subcommands/#direct-instantiation","title":"Direct Instantiation","text":"<p>You can still create instances directly:</p> <pre><code>@wArgs\nclass Calculator:\n    def add(self, a: int, b: int) -&gt; None:\n        print(a + b)\n\n# CLI mode\nif __name__ == \"__main__\":\n    Calculator()\n\n# Direct use in code\ncalc = Calculator()\ncalc.add(2, 3)  # Prints: 5\n</code></pre>"},{"location":"guide/subcommands/#no-subcommand","title":"No Subcommand","text":"<p>When no subcommand is given, help is shown:</p> <pre><code>$ python calc.py\nusage: calc.py [-h] {add,subtract} ...\n\nA simple calculator.\n\npositional arguments:\n  {add,subtract}\n    add           Add two numbers.\n    subtract      Subtract two numbers.\n</code></pre>"},{"location":"guide/subcommands/#customizing-the-parser","title":"Customizing the Parser","text":"<pre><code>@wArgs(\n    prog=\"myapp\",\n    description=\"Custom description\",\n)\nclass CLI:\n    ...\n</code></pre>"},{"location":"guide/subcommands/#next-steps","title":"Next Steps","text":"<ul> <li>Inheritance - Share options across commands</li> <li>Advanced - Advanced patterns</li> </ul>"},{"location":"guide/type-system/","title":"Type System","text":"<p>wArgs automatically converts CLI string arguments to Python types based on type hints.</p>"},{"location":"guide/type-system/#primitive-types","title":"Primitive Types","text":""},{"location":"guide/type-system/#strings","title":"Strings","text":"<pre><code>@wArgs\ndef greet(name: str) -&gt; None:\n    print(f\"Hello, {name}!\")\n</code></pre> <pre><code>$ python app.py --name \"World\"\nHello, World!\n</code></pre>"},{"location":"guide/type-system/#integers","title":"Integers","text":"<pre><code>@wArgs\ndef repeat(count: int) -&gt; None:\n    print(f\"Count: {count}\")\n</code></pre> <pre><code>$ python app.py --count 42\nCount: 42\n</code></pre>"},{"location":"guide/type-system/#floats","title":"Floats","text":"<pre><code>@wArgs\ndef scale(factor: float) -&gt; None:\n    print(f\"Factor: {factor}\")\n</code></pre> <pre><code>$ python app.py --factor 3.14\nFactor: 3.14\n</code></pre>"},{"location":"guide/type-system/#booleans","title":"Booleans","text":"<p>Boolean with <code>False</code> default becomes a flag:</p> <pre><code>@wArgs\ndef build(debug: bool = False) -&gt; None:\n    print(f\"Debug: {debug}\")\n</code></pre> <pre><code>$ python app.py --debug\nDebug: True\n</code></pre>"},{"location":"guide/type-system/#collection-types","title":"Collection Types","text":""},{"location":"guide/type-system/#lists","title":"Lists","text":"<pre><code>@wArgs\ndef process(files: list[str]) -&gt; None:\n    for f in files:\n        print(f\"Processing: {f}\")\n</code></pre> <pre><code>$ python app.py --files a.txt b.txt c.txt\nProcessing: a.txt\nProcessing: b.txt\nProcessing: c.txt\n</code></pre> <p>With typed elements:</p> <pre><code>@wArgs\ndef sum_numbers(numbers: list[int]) -&gt; None:\n    print(f\"Sum: {sum(numbers)}\")\n</code></pre> <pre><code>$ python app.py --numbers 1 2 3 4 5\nSum: 15\n</code></pre>"},{"location":"guide/type-system/#tuples","title":"Tuples","text":"<p>Fixed-length tuples:</p> <pre><code>@wArgs\ndef point(coords: tuple[int, int]) -&gt; None:\n    x, y = coords\n    print(f\"Point: ({x}, {y})\")\n</code></pre> <pre><code>$ python app.py --coords 10 20\nPoint: (10, 20)\n</code></pre>"},{"location":"guide/type-system/#sets","title":"Sets","text":"<pre><code>@wArgs\ndef tags(items: set[str]) -&gt; None:\n    print(f\"Unique tags: {items}\")\n</code></pre> <pre><code>$ python app.py --items foo bar foo baz\nUnique tags: {'foo', 'bar', 'baz'}\n</code></pre>"},{"location":"guide/type-system/#optional-types","title":"Optional Types","text":""},{"location":"guide/type-system/#union-with-none","title":"Union with None","text":"<pre><code>@wArgs\ndef greet(name: str | None = None) -&gt; None:\n    if name:\n        print(f\"Hello, {name}!\")\n    else:\n        print(\"Hello, stranger!\")\n</code></pre> <pre><code>$ python app.py\nHello, stranger!\n\n$ python app.py --name World\nHello, World!\n</code></pre>"},{"location":"guide/type-system/#optional-typing-module","title":"Optional (typing module)","text":"<pre><code>from typing import Optional\n\n@wArgs\ndef greet(name: Optional[str] = None) -&gt; None:\n    ...\n</code></pre>"},{"location":"guide/type-system/#literal-types","title":"Literal Types","text":"<p>Use <code>Literal</code> for choices:</p> <pre><code>from typing import Literal\n\n@wArgs\ndef export(format: Literal[\"json\", \"xml\", \"csv\"]) -&gt; None:\n    print(f\"Exporting as {format}\")\n</code></pre> <pre><code>$ python app.py --help\n  --format {json,xml,csv}  ...\n\n$ python app.py --format json\nExporting as json\n\n$ python app.py --format yaml\n# Error: invalid choice\n</code></pre>"},{"location":"guide/type-system/#enum-types","title":"Enum Types","text":"<p>Enums provide named choices:</p> <pre><code>from enum import Enum\nfrom wArgs import wArgs\n\nclass Color(Enum):\n    RED = \"red\"\n    GREEN = \"green\"\n    BLUE = \"blue\"\n\n@wArgs\ndef paint(color: Color) -&gt; None:\n    print(f\"Painting with {color.value}\")\n</code></pre> <pre><code>$ python app.py --help\n  --color {RED,GREEN,BLUE}  ...\n\n$ python app.py --color RED\nPainting with red\n</code></pre>"},{"location":"guide/type-system/#path-types","title":"Path Types","text":"<pre><code>from pathlib import Path\n\n@wArgs\ndef process(input_file: Path, output_dir: Path) -&gt; None:\n    print(f\"Input: {input_file}\")\n    print(f\"Output dir: {output_dir}\")\n    print(f\"Exists: {input_file.exists()}\")\n</code></pre> <pre><code>$ python app.py --input-file data.txt --output-dir ./out\nInput: data.txt\nOutput dir: out\nExists: True\n</code></pre>"},{"location":"guide/type-system/#date-and-time-types","title":"Date and Time Types","text":""},{"location":"guide/type-system/#datetime","title":"datetime","text":"<pre><code>from datetime import datetime\n\n@wArgs\ndef schedule(when: datetime) -&gt; None:\n    print(f\"Scheduled for: {when}\")\n</code></pre> <pre><code>$ python app.py --when \"2024-01-15T10:30:00\"\nScheduled for: 2024-01-15 10:30:00\n</code></pre>"},{"location":"guide/type-system/#date","title":"date","text":"<pre><code>from datetime import date\n\n@wArgs\ndef birthday(day: date) -&gt; None:\n    print(f\"Birthday: {day}\")\n</code></pre> <pre><code>$ python app.py --day 2024-01-15\nBirthday: 2024-01-15\n</code></pre>"},{"location":"guide/type-system/#time","title":"time","text":"<pre><code>from datetime import time\n\n@wArgs\ndef alarm(at: time) -&gt; None:\n    print(f\"Alarm at: {at}\")\n</code></pre> <pre><code>$ python app.py --at 07:30:00\nAlarm at: 07:30:00\n</code></pre>"},{"location":"guide/type-system/#other-types","title":"Other Types","text":""},{"location":"guide/type-system/#uuid","title":"UUID","text":"<pre><code>from uuid import UUID\n\n@wArgs\ndef lookup(id: UUID) -&gt; None:\n    print(f\"Looking up: {id}\")\n</code></pre> <pre><code>$ python app.py --id \"123e4567-e89b-12d3-a456-426614174000\"\nLooking up: 123e4567-e89b-12d3-a456-426614174000\n</code></pre>"},{"location":"guide/type-system/#decimal","title":"Decimal","text":"<pre><code>from decimal import Decimal\n\n@wArgs\ndef price(amount: Decimal) -&gt; None:\n    print(f\"Price: ${amount}\")\n</code></pre> <pre><code>$ python app.py --amount 19.99\nPrice: $19.99\n</code></pre>"},{"location":"guide/type-system/#custom-type-converters","title":"Custom Type Converters","text":"<p>Register custom converters for your types:</p> <pre><code>from wArgs import wArgs, converter\n\nclass EmailAddress:\n    def __init__(self, address: str) -&gt; None:\n        if \"@\" not in address:\n            raise ValueError(\"Invalid email\")\n        self.address = address\n\n@converter(EmailAddress)\ndef convert_email(value: str) -&gt; EmailAddress:\n    return EmailAddress(value)\n\n@wArgs\ndef send(to: EmailAddress) -&gt; None:\n    print(f\"Sending to: {to.address}\")\n</code></pre> <pre><code>$ python app.py --to user@example.com\nSending to: user@example.com\n\n$ python app.py --to invalid\n# Error: Invalid email\n</code></pre>"},{"location":"guide/type-system/#type-summary","title":"Type Summary","text":"Type CLI Representation <code>str</code> String value <code>int</code> Integer value <code>float</code> Float value <code>bool</code> (default False) Flag (<code>--name</code>) <code>list[T]</code> Multiple values <code>tuple[T, ...]</code> Fixed number of values <code>set[T]</code> Multiple unique values <code>T \\| None</code> Optional value <code>Literal[\"a\", \"b\"]</code> Choices <code>Enum</code> Enum member names <code>Path</code> File system path <code>datetime</code> ISO 8601 datetime <code>date</code> ISO 8601 date <code>time</code> ISO 8601 time <code>UUID</code> UUID string <code>Decimal</code> Decimal number"},{"location":"integrations/","title":"Framework Integrations","text":"<p>Learn how to integrate wArgs with popular Python frameworks and tools.</p>"},{"location":"integrations/#available-integrations","title":"Available Integrations","text":""},{"location":"integrations/#django","title":"\ud83c\udfaf Django","text":"<p>Create custom Django management commands with wArgs. Features: - Type-safe command arguments - Auto-generated help from docstrings - Less boilerplate than BaseCommand - Full Django ORM access - Database migrations and seeding - Cache management</p> <p>Use cases: Data migration, database maintenance, cache management, custom admin tools</p>"},{"location":"integrations/#flask","title":"\ud83c\udf36\ufe0f Flask","text":"<p>Build Flask CLI commands with wArgs integration. Includes: - Flask app context handling - Database initialization and seeding - Route inspection - Configuration management</p> <p>Use cases: Database setup, seeding, admin tasks, deployment scripts</p>"},{"location":"integrations/#coming-soon","title":"Coming Soon","text":""},{"location":"integrations/#fastapi","title":"\u26a1 FastAPI","text":"<p>Create CLI tools for FastAPI applications: - Database migrations - API testing utilities - Data seeding - Admin commands</p>"},{"location":"integrations/#sqlalchemy","title":"\ud83d\uddc4\ufe0f SQLAlchemy","text":"<p>Advanced database schema management: - Schema inspection - Migration generation - Data validation - Multi-database support</p>"},{"location":"integrations/#pydantic","title":"\ud83d\udcca Pydantic","text":"<p>Enhanced data validation and configuration: - Config file validation - API request testing - Data transformation - Schema generation</p>"},{"location":"integrations/#integration-patterns","title":"Integration Patterns","text":""},{"location":"integrations/#app-context-pattern","title":"App Context Pattern","text":"<pre><code>@wArgs\nclass AppCLI:\n    def __init__(self, app_context: bool = True):\n        if app_context:\n            with app.app_context():\n                # Commands run in app context\n                pass\n</code></pre>"},{"location":"integrations/#database-pattern","title":"Database Pattern","text":"<pre><code>def init_db(self):\n    \"\"\"Initialize database.\"\"\"\n    with app.app_context():\n        db.create_all()\n</code></pre>"},{"location":"integrations/#configuration-pattern","title":"Configuration Pattern","text":"<pre><code>def __init__(self, config: Path = Path(\"config.py\")):\n    app.config.from_pyfile(config)\n</code></pre>"},{"location":"integrations/#best-practices","title":"Best Practices","text":"<ol> <li>App Context - Run commands in the app context when needed</li> <li>Environment Variables - Use environment-specific configs</li> <li>Error Handling - Gracefully handle database/network errors</li> <li>Testing - Test CLI commands like regular code</li> <li>Documentation - Use docstrings for auto-generated help</li> </ol>"},{"location":"integrations/#related","title":"Related","text":"<ul> <li>User Guide - wArgs fundamentals</li> <li>API Reference - Decorator documentation</li> <li>Tutorials - Step-by-step guides</li> </ul>"},{"location":"integrations/#contributing","title":"Contributing","text":"<p>Have an integration guide to share? We welcome contributions for: - Other web frameworks (Tornado, Pyramid, etc.) - ORMs (Peewee, Tortoise, etc.) - Task queues (Celery, RQ, etc.) - Testing frameworks (pytest plugins, etc.)</p> <p>See CONTRIBUTING.md for guidelines.</p>"},{"location":"integrations/django/","title":"Django Management Commands with wArgs","text":"<p>Integrate wArgs with Django to create powerful custom management commands.</p>"},{"location":"integrations/django/#why-wargs-for-django","title":"Why wArgs for Django?","text":"<p>Django's built-in <code>BaseCommand</code> is verbose and requires lots of boilerplate. With wArgs: - \u2705 Type-safe arguments from type hints - \u2705 Auto-generated help from docstrings - \u2705 Less code - just decorate and go - \u2705 Full Django ORM access in your functions</p>"},{"location":"integrations/django/#basic-integration","title":"Basic Integration","text":""},{"location":"integrations/django/#step-1-create-management-command","title":"Step 1: Create Management Command","text":"<p>Create <code>myapp/management/commands/process_users.py</code>:</p> <pre><code>from django.core.management.base import BaseCommand\nfrom wArgs import wArgs\nfrom myapp.models import User\nfrom typing import Literal\n\n@wArgs\ndef process_users(\n    status: Literal[\"active\", \"inactive\", \"all\"] = \"all\",\n    limit: int = 100,\n    dry_run: bool = False,\n):\n    \"\"\"Process user accounts.\n\n    Args:\n        status: Filter users by status\n        limit: Maximum number of users to process\n        dry_run: Preview changes without committing\n    \"\"\"\n    # Query users\n    users = User.objects.all()\n\n    if status != \"all\":\n        users = users.filter(status=status)\n\n    users = users[:limit]\n\n    print(f\"Processing {users.count()} users...\")\n\n    for user in users:\n        print(f\"  \u2022 {user.username} ({user.email})\")\n\n        if not dry_run:\n            # Perform actual processing\n            user.last_processed = timezone.now()\n            user.save()\n\n    if dry_run:\n        print(\"\\n[DRY RUN] No changes committed\")\n    else:\n        print(f\"\\n\u2713 Processed {users.count()} users\")\n\nclass Command(BaseCommand):\n    help = \"Process user accounts\"\n\n    def handle(self, *args, **options):\n        # Let wArgs handle argument parsing\n        process_users()\n</code></pre>"},{"location":"integrations/django/#step-2-run-command","title":"Step 2: Run Command","text":"<pre><code>python manage.py process_users --help\npython manage.py process_users --process_users-status active --process_users-limit 50\npython manage.py process_users --process_users-dry-run\n</code></pre>"},{"location":"integrations/django/#advanced-pattern-direct-django-integration","title":"Advanced Pattern: Direct Django Integration","text":"<p>For better integration, create a base class:</p> <pre><code># myapp/management/base.py\nfrom django.core.management.base import BaseCommand\nfrom wArgs import wArgs\nimport sys\n\nclass WargsCommand(BaseCommand):\n    \"\"\"Base class for wArgs-powered Django commands.\"\"\"\n\n    # Override in subclass\n    cli_function = None\n\n    def handle(self, *args, **options):\n        if self.cli_function is None:\n            raise NotImplementedError(\"cli_function must be set\")\n\n        # Run the wArgs function\n        self.cli_function()\n</code></pre> <p>Now create commands more easily:</p> <pre><code># myapp/management/commands/export_data.py\nfrom myapp.management.base import WargsCommand\nfrom wArgs import wArgs\nfrom pathlib import Path\nimport json\n\n@wArgs\ndef export_data(\n    model: str,\n    output: Path,\n    format: str = \"json\",\n):\n    \"\"\"Export model data to file.\n\n    Args:\n        model: Model name to export (e.g., 'User', 'Article')\n        output: Output file path\n        format: Export format (json, csv)\n    \"\"\"\n    from django.apps import apps\n\n    # Get model class\n    try:\n        Model = apps.get_model('myapp', model)\n    except LookupError:\n        print(f\"Error: Model '{model}' not found\")\n        return\n\n    # Export data\n    data = list(Model.objects.values())\n\n    if format == \"json\":\n        output.write_text(json.dumps(data, indent=2, default=str))\n    elif format == \"csv\":\n        import csv\n        if data:\n            with output.open('w', newline='') as f:\n                writer = csv.DictWriter(f, fieldnames=data[0].keys())\n                writer.writeheader()\n                writer.writerows(data)\n\n    print(f\"\u2713 Exported {len(data)} {model} records to {output}\")\n\nclass Command(WargsCommand):\n    help = \"Export model data\"\n    cli_function = export_data\n</code></pre>"},{"location":"integrations/django/#real-world-examples","title":"Real-World Examples","text":""},{"location":"integrations/django/#data-migration-command","title":"Data Migration Command","text":"<pre><code>@wArgs\ndef migrate_data(\n    source_db: str,\n    batch_size: int = 1000,\n    skip_validation: bool = False,\n):\n    \"\"\"Migrate data from legacy database.\n\n    Args:\n        source_db: Source database alias (in settings.DATABASES)\n        batch_size: Number of records per batch\n        skip_validation: Skip data validation\n    \"\"\"\n    from django.db import connections\n    from myapp.models import Product\n\n    cursor = connections[source_db].cursor()\n    cursor.execute(\"SELECT * FROM legacy_products\")\n\n    batch = []\n    total = 0\n\n    for row in cursor.fetchall():\n        product = Product(\n            name=row[1],\n            price=row[2],\n            # ... map fields\n        )\n\n        if not skip_validation:\n            product.full_clean()\n\n        batch.append(product)\n\n        if len(batch) &gt;= batch_size:\n            Product.objects.bulk_create(batch)\n            total += len(batch)\n            print(f\"Migrated {total} products...\")\n            batch = []\n\n    # Final batch\n    if batch:\n        Product.objects.bulk_create(batch)\n        total += len(batch)\n\n    print(f\"\u2713 Migrated {total} products total\")\n\nclass Command(WargsCommand):\n    help = \"Migrate data from legacy database\"\n    cli_function = migrate_data\n</code></pre>"},{"location":"integrations/django/#cache-management-command","title":"Cache Management Command","text":"<pre><code>from django.core.cache import cache\n\n@wArgs\nclass CacheManager:\n    \"\"\"Django cache management.\"\"\"\n\n    def clear(self, pattern: str = \"*\"):\n        \"\"\"Clear cache keys matching pattern.\n\n        Args:\n            pattern: Key pattern to match (supports wildcards)\n        \"\"\"\n        # Implementation depends on cache backend\n        cache.clear()\n        print(f\"\u2713 Cleared cache (pattern: {pattern})\")\n\n    def stats(self):\n        \"\"\"Show cache statistics.\"\"\"\n        # Get cache stats (backend-specific)\n        print(\"Cache Statistics:\")\n        print(f\"  Backend: {cache.__class__.__name__}\")\n        # ... show stats\n\n    def warm(self, model: str):\n        \"\"\"Warm cache for a model.\n\n        Args:\n            model: Model to cache\n        \"\"\"\n        from django.apps import apps\n\n        Model = apps.get_model('myapp', model)\n        objects = Model.objects.all()\n\n        for obj in objects:\n            cache_key = f\"{model}:{obj.pk}\"\n            cache.set(cache_key, obj, timeout=3600)\n\n        print(f\"\u2713 Warmed cache for {objects.count()} {model} objects\")\n\nclass Command(BaseCommand):\n    help = \"Manage Django cache\"\n\n    def handle(self, *args, **options):\n        CacheManager()\n</code></pre> <p>Usage: <pre><code>python manage.py cache_manager clear --clear-pattern \"user:*\"\npython manage.py cache_manager stats\npython manage.py cache_manager warm --warm-model User\n</code></pre></p>"},{"location":"integrations/django/#database-maintenance-command","title":"Database Maintenance Command","text":"<pre><code>@wArgs\nclass DBMaintenance:\n    \"\"\"Database maintenance tasks.\"\"\"\n\n    def vacuum(self, tables: list[str] | None = None):\n        \"\"\"Vacuum database tables (PostgreSQL).\n\n        Args:\n            tables: Specific tables to vacuum (default: all)\n        \"\"\"\n        from django.db import connection\n\n        with connection.cursor() as cursor:\n            if tables:\n                for table in tables:\n                    cursor.execute(f\"VACUUM ANALYZE {table}\")\n                    print(f\"\u2713 Vacuumed table: {table}\")\n            else:\n                cursor.execute(\"VACUUM ANALYZE\")\n                print(\"\u2713 Vacuumed all tables\")\n\n    def reindex(self, models: list[str] | None = None):\n        \"\"\"Rebuild database indexes.\n\n        Args:\n            models: Models to reindex (default: all)\n        \"\"\"\n        from django.apps import apps\n        from django.db import connection\n\n        if models:\n            model_classes = [apps.get_model('myapp', m) for m in models]\n        else:\n            model_classes = apps.get_models()\n\n        with connection.cursor() as cursor:\n            for Model in model_classes:\n                table = Model._meta.db_table\n                cursor.execute(f\"REINDEX TABLE {table}\")\n                print(f\"\u2713 Reindexed: {table}\")\n\n    def analyze(self):\n        \"\"\"Analyze database and show statistics.\"\"\"\n        from django.db import connection\n\n        with connection.cursor() as cursor:\n            cursor.execute(\"\"\"\n                SELECT schemaname, tablename, pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename))\n                FROM pg_tables\n                WHERE schemaname = 'public'\n                ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC\n            \"\"\")\n\n            print(\"\\nTable Sizes:\")\n            for schema, table, size in cursor.fetchall():\n                print(f\"  {table}: {size}\")\n</code></pre>"},{"location":"integrations/django/#best-practices","title":"Best Practices","text":""},{"location":"integrations/django/#1-use-type-hints","title":"1. Use Type Hints","text":"<pre><code>from typing import Literal\nfrom pathlib import Path\n\n@wArgs\ndef my_command(\n    mode: Literal[\"create\", \"update\", \"delete\"],  # Constrained choices\n    file: Path,  # Automatic Path conversion\n    count: int = 10,  # Type-safe integers\n):\n    ...\n</code></pre>"},{"location":"integrations/django/#2-add-docstrings","title":"2. Add Docstrings","text":"<pre><code>@wArgs\ndef my_command(name: str, count: int = 1):\n    \"\"\"Short description.\n\n    Longer description with more details about what\n    this command does and when to use it.\n\n    Args:\n        name: Description of name parameter\n        count: Description of count parameter\n    \"\"\"\n</code></pre>"},{"location":"integrations/django/#3-handle-django-setup","title":"3. Handle Django Setup","text":"<pre><code>import django\nimport os\n\n# Ensure Django is configured before importing models\nos.environ.setdefault('DJANGO_SETTINGS_MODULE', 'myproject.settings')\ndjango.setup()\n\n@wArgs\ndef my_command():\n    from myapp.models import User  # Import after django.setup()\n    ...\n</code></pre>"},{"location":"integrations/django/#4-add-progress-indication","title":"4. Add Progress Indication","text":"<pre><code>from django.db.models import Count\n\n@wArgs\ndef process_items(batch_size: int = 100):\n    \"\"\"Process items in batches.\"\"\"\n    total = Item.objects.count()\n    processed = 0\n\n    for batch in Item.objects.iterator(chunk_size=batch_size):\n        # Process batch\n        processed += 1\n        print(f\"Progress: {processed}/{total} ({processed/total*100:.1f}%)\")\n</code></pre>"},{"location":"integrations/django/#testing-commands","title":"Testing Commands","text":"<pre><code># tests/test_commands.py\nfrom django.test import TestCase\nfrom django.core.management import call_command\nfrom io import StringIO\n\nclass CommandTests(TestCase):\n    def test_process_users_command(self):\n        # Create test data\n        User.objects.create(username=\"test\", status=\"active\")\n\n        # Capture output\n        out = StringIO()\n        call_command('process_users', '--process_users-status', 'active', stdout=out)\n\n        self.assertIn('Processing', out.getvalue())\n</code></pre>"},{"location":"integrations/django/#complete-example","title":"Complete Example","text":"<p>See Django CLI example for a complete Django project with: - Model export/import - Database migrations - Cache management - User management - Data validation - Background tasks</p>"},{"location":"integrations/django/#related","title":"Related","text":"<ul> <li>[[SQLAlchemy Schema Tools]]</li> <li>[[Flask CLI Integration]]</li> <li>wArgs Documentation</li> </ul>"},{"location":"integrations/flask/","title":"Flask CLI Integration with wArgs","text":"<p>Integrate wArgs with Flask to create powerful custom CLI commands for your Flask applications.</p>"},{"location":"integrations/flask/#quick-start","title":"Quick Start","text":"<pre><code>from flask import Flask\nfrom wArgs import wArgs\n\napp = Flask(__name__)\n\n@wArgs\nclass FlaskCLI:\n    \"\"\"Flask application commands.\"\"\"\n\n    def __init__(self, app_context: bool = True):\n        \"\"\"Initialize Flask CLI.\n\n        Args:\n            app_context: Run commands in Flask app context\n        \"\"\"\n        self.app_context = app_context\n        if app_context:\n            with app.app_context():\n                pass  # Commands run in context\n\n    def init_db(self):\n        \"\"\"Initialize the database.\"\"\"\n        with app.app_context():\n            from models import db\n            db.create_all()\n            print(\"\u2713 Database initialized\")\n\n    def seed(self, count: int = 10):\n        \"\"\"Seed database with sample data.\n\n        Args:\n            count: Number of records to create\n        \"\"\"\n        with app.app_context():\n            from models import db, User\n\n            for i in range(count):\n                user = User(\n                    username=f\"user{i}\",\n                    email=f\"user{i}@example.com\"\n                )\n                db.session.add(user)\n\n            db.session.commit()\n            print(f\"\u2713 Created {count} users\")\n\n    def routes(self):\n        \"\"\"List all registered routes.\"\"\"\n        with app.app_context():\n            for rule in app.url_map.iter_rules():\n                print(f\"{rule.endpoint:30s} {rule.rule}\")\n\nif __name__ == \"__main__\":\n    FlaskCLI()\n</code></pre>"},{"location":"integrations/flask/#-help-output","title":"--help Output","text":"<pre><code>$ python cli.py --help\nusage: cli.py [-h] [--FlaskCLI-app-context] {init_db,seed,routes} ...\n\nFlask application commands.\n\npositional arguments:\n  {init_db,seed,routes}\n    init_db             Initialize the database\n    seed                Seed database with sample data\n    routes              List all registered routes\n\noptions:\n  -h, --help            show this help message and exit\n  --FlaskCLI-app-context\n                        Run commands in Flask app context (default: True)\n</code></pre>"},{"location":"integrations/flask/#usage","title":"Usage","text":"<pre><code># Initialize database\npython cli.py init_db\n\n# Seed with data\npython cli.py seed --seed-count 100\n\n# List routes\npython cli.py routes\n</code></pre>"},{"location":"integrations/flask/#integration-with-flask-cli","title":"Integration with Flask CLI","text":"<pre><code>import click\nfrom flask.cli import with_appcontext\n\n@app.cli.command()\n@click.argument('count', default=10)\ndef wargs_seed(count):\n    \"\"\"Seed using wArgs (called via flask command).\"\"\"\n    # Import and use wArgs function\n    pass\n</code></pre>"},{"location":"integrations/flask/#related","title":"Related","text":"<ul> <li>[[Django Management Commands]]</li> <li>[[FastAPI CLI Tools]]</li> </ul>"},{"location":"tutorials/","title":"Tutorials","text":"<p>Step-by-step guides for building real-world CLI applications with wArgs.</p>"},{"location":"tutorials/#available-tutorials","title":"Available Tutorials","text":""},{"location":"tutorials/#database-cli","title":"\ud83d\uddc4\ufe0f Database CLI","text":"<p>Build a complete database administration tool for PostgreSQL and MySQL. Learn to: - Connect to databases with SQLAlchemy - Inspect tables and schemas - Run queries and export results - Backup and restore databases - Manage migrations</p> <p>Difficulty: Intermediate | Time: 30-45 minutes</p>"},{"location":"tutorials/#file-manager-cli","title":"\ud83d\udcc1 File Manager CLI","text":"<p>Create a powerful file management tool with search, organization, and batch operations. Features: - List, search, and find files - Copy, move, and delete operations - Duplicate file detection - Directory size calculation - Batch renaming</p> <p>Difficulty: Beginner | Time: 20-30 minutes</p>"},{"location":"tutorials/#web-scraper-cli","title":"\ud83c\udf10 Web Scraper CLI","text":"<p>Extract data from websites with a flexible scraping tool. Build capabilities for: - Page scraping with CSS selectors - Link and image extraction - Table data export - Pagination handling - Rate limiting and robots.txt</p> <p>Difficulty: Intermediate | Time: 30-40 minutes</p>"},{"location":"tutorials/#system-monitor-cli","title":"\ud83d\udcca System Monitor CLI","text":"<p>Monitor system resources and processes. Track: - CPU and memory usage - Disk space and I/O - Network statistics - Process management - Alerts and logging</p> <p>Difficulty: Beginner | Time: 25-35 minutes</p>"},{"location":"tutorials/#coming-soon","title":"Coming Soon","text":"<ul> <li>Git Helper CLI - Custom git workflows</li> <li>DevOps Automation CLI - Deployment tools</li> <li>Testing Framework CLI - Custom test runner</li> <li>API Client CLI - REST API interaction</li> </ul>"},{"location":"tutorials/#tutorial-format","title":"Tutorial Format","text":"<p>Each tutorial includes: - \u2705 Complete working code - \u2705 Step-by-step explanation - \u2705 <code>--help</code> output examples - \u2705 Usage examples with real commands - \u2705 Advanced features and extensions - \u2705 Best practices</p>"},{"location":"tutorials/#prerequisites","title":"Prerequisites","text":"<p>All tutorials assume: - Python 3.8 or higher - wArgs installed: <code>pip install git+https://github.com/cmoxiv/wArgs.git</code> - Basic Python knowledge - Command line familiarity</p>"},{"location":"tutorials/#getting-help","title":"Getting Help","text":"<ul> <li>Questions: GitHub Discussions</li> <li>Issues: Report bugs</li> <li>FAQ: Common questions</li> <li>API Reference: Full documentation</li> </ul>"},{"location":"tutorials/#contributing-tutorials","title":"Contributing Tutorials","text":"<p>Want to add a tutorial? See our contribution guide for details on: - Tutorial structure and templates - Code standards - Testing requirements - Submission process</p> <p>Ready to start building? Pick a tutorial above and begin your wArgs journey!</p>"},{"location":"tutorials/database-cli/","title":"Building a Database CLI","text":"<p>Learn how to build a powerful database administration CLI using wArgs and SQLAlchemy.</p>"},{"location":"tutorials/database-cli/#overview","title":"Overview","text":"<p>In this tutorial, you'll build a CLI tool that can: - Connect to PostgreSQL/MySQL databases - List tables and inspect schemas - Run queries and export results - Backup and restore databases - Manage database migrations</p> <p>Prerequisites: - Python 3.8+ - Basic SQL knowledge - wArgs installed: <code>pip install git+https://github.com/cmoxiv/wArgs.git</code></p>"},{"location":"tutorials/database-cli/#step-1-project-setup","title":"Step 1: Project Setup","text":"<pre><code>mkdir dbcli\ncd dbcli\npython -m venv .venv\nsource .venv/bin/activate  # Windows: .venv\\Scripts\\activate\n\n# Install dependencies\npip install git+https://github.com/cmoxiv/wArgs.git\npip install sqlalchemy psycopg2-binary  # For PostgreSQL\npip install pymysql  # For MySQL (optional)\n</code></pre>"},{"location":"tutorials/database-cli/#step-2-basic-structure","title":"Step 2: Basic Structure","text":"<p>Create <code>dbcli.py</code>:</p> <pre><code>from wArgs import wArgs\nfrom typing import Literal\nfrom pathlib import Path\nfrom sqlalchemy import create_engine, inspect, text\nfrom sqlalchemy.engine import Engine\nimport json\n\n@wArgs\nclass DBCLI:\n    \"\"\"Database CLI for PostgreSQL and MySQL.\"\"\"\n\n    def __init__(\n        self,\n        db_type: Literal[\"postgres\", \"mysql\"] = \"postgres\",\n        host: str = \"localhost\",\n        port: int = 5432,\n        database: str = \"postgres\",\n        user: str = \"postgres\",\n        password: str = \"\",\n    ):\n        \"\"\"Initialize database connection.\n\n        Args:\n            db_type: Database type (postgres or mysql)\n            host: Database host\n            port: Database port\n            database: Database name\n            user: Database user\n            password: Database password\n        \"\"\"\n        self.db_type = db_type\n\n        # Build connection string\n        if db_type == \"postgres\":\n            url = f\"postgresql://{user}:{password}@{host}:{port}/{database}\"\n        else:\n            url = f\"mysql+pymysql://{user}:{password}@{host}:{port}/{database}\"\n\n        self.engine = create_engine(url)\n        self.inspector = inspect(self.engine)\n\n    def tables(self):\n        \"\"\"List all tables in the database.\"\"\"\n        tables = self.inspector.get_table_names()\n\n        if not tables:\n            print(\"No tables found.\")\n            return\n\n        print(f\"\\nFound {len(tables)} tables:\\n\")\n        for table in sorted(tables):\n            print(f\"  \u2022 {table}\")\n\n    def schema(self, table: str):\n        \"\"\"Show schema for a specific table.\n\n        Args:\n            table: Table name to inspect\n        \"\"\"\n        if table not in self.inspector.get_table_names():\n            print(f\"Error: Table '{table}' not found\")\n            return\n\n        columns = self.inspector.get_columns(table)\n        pk = self.inspector.get_pk_constraint(table)\n        indexes = self.inspector.get_indexes(table)\n\n        print(f\"\\nTable: {table}\")\n        print(\"=\" * 60)\n\n        # Show columns\n        print(\"\\nColumns:\")\n        for col in columns:\n            nullable = \"NULL\" if col[\"nullable\"] else \"NOT NULL\"\n            default = f\"DEFAULT {col['default']}\" if col.get(\"default\") else \"\"\n            pk_marker = \"\ud83d\udd11\" if col[\"name\"] in pk.get(\"constrained_columns\", []) else \"  \"\n\n            print(f\"  {pk_marker} {col['name']:&lt;20} {str(col['type']):&lt;15} {nullable:&lt;10} {default}\")\n\n        # Show indexes\n        if indexes:\n            print(\"\\nIndexes:\")\n            for idx in indexes:\n                unique = \"UNIQUE\" if idx[\"unique\"] else \"\"\n                cols = \", \".join(idx[\"column_names\"])\n                print(f\"  \u2022 {idx['name']}: ({cols}) {unique}\")\n\n    def query(self, sql: str, output: Path | None = None):\n        \"\"\"Execute a SQL query and show results.\n\n        Args:\n            sql: SQL query to execute\n            output: Optional JSON file to save results\n        \"\"\"\n        with self.engine.connect() as conn:\n            result = conn.execute(text(sql))\n\n            if result.returns_rows:\n                rows = result.fetchall()\n                keys = result.keys()\n\n                # Convert to list of dicts\n                data = [dict(zip(keys, row)) for row in rows]\n\n                # Print to console\n                print(f\"\\nQuery returned {len(data)} rows:\\n\")\n\n                if data:\n                    # Print as table\n                    widths = {k: max(len(k), max(len(str(row[k])) for row in data))\n                             for k in keys}\n\n                    # Header\n                    header = \" | \".join(k.ljust(widths[k]) for k in keys)\n                    print(header)\n                    print(\"-\" * len(header))\n\n                    # Rows\n                    for row in data[:10]:  # Limit to 10 rows in console\n                        print(\" | \".join(str(row[k]).ljust(widths[k]) for k in keys))\n\n                    if len(data) &gt; 10:\n                        print(f\"\\n... and {len(data) - 10} more rows\")\n\n                # Save to file if requested\n                if output:\n                    output.write_text(json.dumps(data, indent=2, default=str))\n                    print(f\"\\n\u2713 Results saved to {output}\")\n            else:\n                print(\"Query executed successfully (no rows returned)\")\n\n    def backup(self, output: Path):\n        \"\"\"Backup database schema to SQL file.\n\n        Args:\n            output: Output SQL file path\n        \"\"\"\n        # This is a simplified version - in production, use pg_dump or mysqldump\n        tables = self.inspector.get_table_names()\n\n        sql_statements = []\n\n        for table in tables:\n            # Get table definition\n            columns = self.inspector.get_columns(table)\n            pk = self.inspector.get_pk_constraint(table)\n\n            # Build CREATE TABLE statement\n            col_defs = []\n            for col in columns:\n                nullable = \"NULL\" if col[\"nullable\"] else \"NOT NULL\"\n                col_def = f\"  {col['name']} {col['type']} {nullable}\"\n                col_defs.append(col_def)\n\n            # Add primary key\n            if pk.get(\"constrained_columns\"):\n                pk_cols = \", \".join(pk[\"constrained_columns\"])\n                col_defs.append(f\"  PRIMARY KEY ({pk_cols})\")\n\n            create_stmt = f\"CREATE TABLE {table} (\\n\" + \",\\n\".join(col_defs) + \"\\n);\"\n            sql_statements.append(create_stmt)\n\n        # Write to file\n        output.write_text(\"\\n\\n\".join(sql_statements))\n        print(f\"\u2713 Backed up {len(tables)} tables to {output}\")\n\nif __name__ == \"__main__\":\n    DBCLI()\n</code></pre>"},{"location":"tutorials/database-cli/#cli-help-output","title":"CLI Help Output","text":""},{"location":"tutorials/database-cli/#main-command","title":"Main Command","text":"<pre><code>$ python dbcli.py --help\nusage: dbcli.py [-h] [--db-type {postgres,mysql}] [--host HOST] [--port PORT]\n                [--database DATABASE] [--user USER] [--password PASSWORD]\n                {backup,query,schema,tables} ...\n\nDatabase CLI for PostgreSQL and MySQL.\n\npositional arguments:\n  {backup,query,schema,tables}\n    backup              Backup database schema to SQL file.\n    query               Execute a SQL query and show results.\n    schema              Show schema for a specific table.\n    tables              List all tables in the database.\n\noptions:\n  -h, --help            show this help message and exit\n  --db-type {postgres,mysql}\n                        Database type (postgres or mysql) (default: 'postgres')\n  --host HOST           Database host (default: 'localhost')\n  --port PORT           Database port (default: 5432)\n  --database DATABASE   Database name (default: 'postgres')\n  --user USER           Database user (default: 'postgres')\n  --password PASSWORD   Database password (default: '')\n</code></pre>"},{"location":"tutorials/database-cli/#query-subcommand","title":"Query Subcommand","text":"<pre><code>$ python dbcli.py query --help\nusage: dbcli.py query [-h] --sql SQL [--output OUTPUT]\n\nExecute a SQL query and show results.\n\noptions:\n  -h, --help       show this help message and exit\n  --sql SQL        SQL query to execute\n  --output OUTPUT  Optional JSON file to save results\n</code></pre>"},{"location":"tutorials/database-cli/#step-3-usage-examples","title":"Step 3: Usage Examples","text":""},{"location":"tutorials/database-cli/#list-all-tables","title":"List all tables","text":"<pre><code>python dbcli.py --DBCLI-host localhost --DBCLI-database mydb --DBCLI-user admin --DBCLI-password secret tables\n</code></pre>"},{"location":"tutorials/database-cli/#show-table-schema","title":"Show table schema","text":"<pre><code>python dbcli.py --DBCLI-database mydb --DBCLI-user admin schema --schema-table users\n</code></pre>"},{"location":"tutorials/database-cli/#run-a-query","title":"Run a query","text":"<pre><code>python dbcli.py --DBCLI-database mydb --DBCLI-user admin query --query-sql \"SELECT * FROM users LIMIT 10\"\n</code></pre>"},{"location":"tutorials/database-cli/#save-query-results-to-json","title":"Save query results to JSON","text":"<pre><code>python dbcli.py --DBCLI-database mydb --DBCLI-user admin query \\\n  --query-sql \"SELECT * FROM users WHERE active = true\" \\\n  --query-output active_users.json\n</code></pre>"},{"location":"tutorials/database-cli/#backup-database-schema","title":"Backup database schema","text":"<pre><code>python dbcli.py --DBCLI-database mydb --DBCLI-user admin backup --backup-output schema.sql\n</code></pre>"},{"location":"tutorials/database-cli/#step-4-add-configuration-file-support","title":"Step 4: Add Configuration File Support","text":"<p>Create <code>.dbcli.json</code>:</p> <pre><code>{\n  \"db_type\": \"postgres\",\n  \"host\": \"localhost\",\n  \"port\": 5432,\n  \"database\": \"mydb\",\n  \"user\": \"admin\",\n  \"password\": \"secret\"\n}\n</code></pre> <p>Update the CLI to load config:</p> <pre><code>import os\nfrom pathlib import Path\n\n# At the top of DBCLI.__init__\nconfig_file = Path.home() / \".dbcli.json\"\nif config_file.exists():\n    config = json.loads(config_file.read_text())\n    # Use config values as defaults\n    db_type = config.get(\"db_type\", db_type)\n    host = config.get(\"host\", host)\n    # ... etc\n</code></pre>"},{"location":"tutorials/database-cli/#step-5-enhancements","title":"Step 5: Enhancements","text":""},{"location":"tutorials/database-cli/#add-transaction-support","title":"Add transaction support","text":"<pre><code>def execute(self, sql: str, commit: bool = True):\n    \"\"\"Execute SQL with transaction control.\n\n    Args:\n        sql: SQL to execute\n        commit: Whether to commit the transaction\n    \"\"\"\n    with self.engine.connect() as conn:\n        trans = conn.begin()\n        try:\n            result = conn.execute(text(sql))\n            if commit:\n                trans.commit()\n                print(\"\u2713 Transaction committed\")\n            else:\n                trans.rollback()\n                print(\"\u2713 Transaction rolled back\")\n        except Exception as e:\n            trans.rollback()\n            print(f\"\u2717 Error: {e}\")\n            raise\n</code></pre>"},{"location":"tutorials/database-cli/#add-migration-support","title":"Add migration support","text":"<pre><code>def migrate(self, migrations_dir: Path):\n    \"\"\"Run database migrations.\n\n    Args:\n        migrations_dir: Directory containing .sql migration files\n    \"\"\"\n    # Create migrations table if not exists\n    with self.engine.connect() as conn:\n        conn.execute(text(\"\"\"\n            CREATE TABLE IF NOT EXISTS migrations (\n                id SERIAL PRIMARY KEY,\n                filename VARCHAR(255) UNIQUE NOT NULL,\n                applied_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n            )\n        \"\"\"))\n        conn.commit()\n\n    # Get applied migrations\n    with self.engine.connect() as conn:\n        result = conn.execute(text(\"SELECT filename FROM migrations\"))\n        applied = {row[0] for row in result}\n\n    # Run pending migrations\n    for migration_file in sorted(migrations_dir.glob(\"*.sql\")):\n        if migration_file.name not in applied:\n            print(f\"Applying {migration_file.name}...\")\n            sql = migration_file.read_text()\n\n            with self.engine.connect() as conn:\n                conn.execute(text(sql))\n                conn.execute(\n                    text(\"INSERT INTO migrations (filename) VALUES (:name)\"),\n                    {\"name\": migration_file.name}\n                )\n                conn.commit()\n\n            print(f\"\u2713 Applied {migration_file.name}\")\n</code></pre>"},{"location":"tutorials/database-cli/#complete-example","title":"Complete Example","text":"<p>See the complete example on GitHub for a full-featured database CLI with: - Connection pooling - Multiple database support (Postgres, MySQL, SQLite) - Data export to CSV/JSON/Excel - Query history - Interactive mode - Password encryption</p>"},{"location":"tutorials/database-cli/#next-steps","title":"Next Steps","text":"<ul> <li>Add support for database dumps using <code>pg_dump</code>/<code>mysqldump</code></li> <li>Implement interactive query mode</li> <li>Add query result pagination</li> <li>Create data import commands</li> <li>Add database comparison tools</li> </ul>"},{"location":"tutorials/database-cli/#related","title":"Related","text":"<ul> <li>[[SQLAlchemy Schema Tools]] - Advanced schema management</li> <li>[[Django Management Commands]] - Integrate with Django ORM</li> <li>Official docs: Type System</li> </ul>"},{"location":"tutorials/file-manager-cli/","title":"Building a File Manager CLI","text":"<p>Create a powerful file management CLI tool with wArgs for common file operations, search, and organization.</p>"},{"location":"tutorials/file-manager-cli/#overview","title":"Overview","text":"<p>Build a CLI that can: - List and search files - Copy, move, and delete files safely - Find duplicates - Organize files by type/date - Calculate directory sizes - Batch rename files</p>"},{"location":"tutorials/file-manager-cli/#quick-start","title":"Quick Start","text":"<pre><code>from wArgs import wArgs\nfrom pathlib import Path\nimport shutil\nimport hashlib\nfrom typing import Literal\nfrom datetime import datetime\n\n@wArgs\nclass FileManager:\n    \"\"\"File management CLI tool.\"\"\"\n\n    def __init__(self, verbose: bool = False, dry_run: bool = False):\n        \"\"\"Initialize file manager.\n\n        Args:\n            verbose: Show detailed output\n            dry_run: Preview changes without executing\n        \"\"\"\n        self.verbose = verbose\n        self.dry_run = dry_run\n\n    def ls(\n        self,\n        directory: Path = Path(\".\"),\n        recursive: bool = False,\n        pattern: str = \"*\",\n        show_size: bool = False,\n    ):\n        \"\"\"List files in a directory.\n\n        Args:\n            directory: Directory to list\n            recursive: Search recursively\n            pattern: File pattern (e.g., \"*.py\")\n            show_size: Show file sizes\n        \"\"\"\n        if not directory.exists():\n            print(f\"Error: {directory} does not exist\")\n            return\n\n        # Get files\n        if recursive:\n            files = list(directory.rglob(pattern))\n        else:\n            files = list(directory.glob(pattern))\n\n        # Sort by path\n        files.sort()\n\n        print(f\"\\nFound {len(files)} file(s) in {directory}\\n\")\n\n        for file in files:\n            if show_size and file.is_file():\n                size = file.stat().st_size\n                size_str = self._format_size(size)\n                print(f\"{size_str:&gt;10}  {file.relative_to(directory)}\")\n            else:\n                marker = \"\ud83d\udcc1\" if file.is_dir() else \"\ud83d\udcc4\"\n                print(f\"{marker} {file.relative_to(directory)}\")\n\n    def find(\n        self,\n        pattern: str,\n        directory: Path = Path(\".\"),\n        case_sensitive: bool = False,\n        file_type: Literal[\"all\", \"file\", \"dir\"] = \"all\",\n    ):\n        \"\"\"Find files by name pattern.\n\n        Args:\n            pattern: Search pattern (supports wildcards)\n            directory: Directory to search in\n            case_sensitive: Case-sensitive search\n            file_type: Filter by type (all, file, dir)\n        \"\"\"\n        if not case_sensitive:\n            pattern = pattern.lower()\n\n        matches = []\n        for item in directory.rglob(\"*\"):\n            name = item.name if case_sensitive else item.name.lower()\n\n            # Check pattern match\n            if pattern in name or Path(name).match(pattern):\n                # Filter by type\n                if file_type == \"file\" and not item.is_file():\n                    continue\n                if file_type == \"dir\" and not item.is_dir():\n                    continue\n\n                matches.append(item)\n\n        print(f\"\\nFound {len(matches)} match(es):\\n\")\n        for match in sorted(matches):\n            print(f\"  {match}\")\n\n    def copy(self, source: Path, destination: Path):\n        \"\"\"Copy file or directory.\n\n        Args:\n            source: Source path\n            destination: Destination path\n        \"\"\"\n        if not source.exists():\n            print(f\"Error: {source} does not exist\")\n            return\n\n        if self.dry_run:\n            print(f\"[DRY RUN] Would copy: {source} \u2192 {destination}\")\n            return\n\n        if source.is_file():\n            destination.parent.mkdir(parents=True, exist_ok=True)\n            shutil.copy2(source, destination)\n        else:\n            shutil.copytree(source, destination, dirs_exist_ok=True)\n\n        if self.verbose:\n            print(f\"\u2713 Copied: {source} \u2192 {destination}\")\n\n    def move(self, source: Path, destination: Path):\n        \"\"\"Move file or directory.\n\n        Args:\n            source: Source path\n            destination: Destination path\n        \"\"\"\n        if not source.exists():\n            print(f\"Error: {source} does not exist\")\n            return\n\n        if self.dry_run:\n            print(f\"[DRY RUN] Would move: {source} \u2192 {destination}\")\n            return\n\n        destination.parent.mkdir(parents=True, exist_ok=True)\n        shutil.move(str(source), str(destination))\n\n        if self.verbose:\n            print(f\"\u2713 Moved: {source} \u2192 {destination}\")\n\n    def delete(self, path: Path, confirm: bool = True):\n        \"\"\"Delete file or directory.\n\n        Args:\n            path: Path to delete\n            confirm: Ask for confirmation\n        \"\"\"\n        if not path.exists():\n            print(f\"Error: {path} does not exist\")\n            return\n\n        if confirm and not self.dry_run:\n            response = input(f\"Delete {path}? [y/N]: \")\n            if response.lower() != \"y\":\n                print(\"Cancelled\")\n                return\n\n        if self.dry_run:\n            print(f\"[DRY RUN] Would delete: {path}\")\n            return\n\n        if path.is_file():\n            path.unlink()\n        else:\n            shutil.rmtree(path)\n\n        if self.verbose:\n            print(f\"\u2713 Deleted: {path}\")\n\n    def size(self, directory: Path = Path(\".\")):\n        \"\"\"Calculate directory size.\n\n        Args:\n            directory: Directory to analyze\n        \"\"\"\n        if not directory.exists():\n            print(f\"Error: {directory} does not exist\")\n            return\n\n        total_size = 0\n        file_count = 0\n\n        for file in directory.rglob(\"*\"):\n            if file.is_file():\n                total_size += file.stat().st_size\n                file_count += 1\n\n        print(f\"\\nDirectory: {directory}\")\n        print(f\"Files: {file_count:,}\")\n        print(f\"Total size: {self._format_size(total_size)}\")\n\n    def duplicates(self, directory: Path = Path(\".\")):\n        \"\"\"Find duplicate files by content hash.\n\n        Args:\n            directory: Directory to scan\n        \"\"\"\n        print(\"Scanning for duplicates...\")\n\n        hashes = {}\n        for file in directory.rglob(\"*\"):\n            if file.is_file():\n                file_hash = self._hash_file(file)\n\n                if file_hash in hashes:\n                    hashes[file_hash].append(file)\n                else:\n                    hashes[file_hash] = [file]\n\n        # Find duplicates\n        duplicates = {h: files for h, files in hashes.items() if len(files) &gt; 1}\n\n        if not duplicates:\n            print(\"\\n\u2713 No duplicates found\")\n            return\n\n        print(f\"\\nFound {len(duplicates)} duplicate set(s):\\n\")\n\n        for file_hash, files in duplicates.items():\n            size = files[0].stat().st_size\n            print(f\"\\nDuplicates ({self._format_size(size)}):\")\n            for file in files:\n                print(f\"  \u2022 {file}\")\n\n    def organize(\n        self,\n        directory: Path = Path(\".\"),\n        by: Literal[\"type\", \"date\"] = \"type\",\n    ):\n        \"\"\"Organize files into subdirectories.\n\n        Args:\n            directory: Directory to organize\n            by: Organization method (type or date)\n        \"\"\"\n        files = [f for f in directory.iterdir() if f.is_file()]\n\n        print(f\"Organizing {len(files)} files by {by}...\")\n\n        for file in files:\n            if by == \"type\":\n                # Organize by extension\n                ext = file.suffix.lower() or \"no_extension\"\n                target_dir = directory / ext.lstrip(\".\")\n            else:\n                # Organize by modification date (year/month)\n                mtime = datetime.fromtimestamp(file.stat().st_mtime)\n                target_dir = directory / f\"{mtime.year}\" / f\"{mtime.month:02d}\"\n\n            if self.dry_run:\n                print(f\"[DRY RUN] Would move: {file.name} \u2192 {target_dir / file.name}\")\n            else:\n                target_dir.mkdir(parents=True, exist_ok=True)\n                file.rename(target_dir / file.name)\n\n                if self.verbose:\n                    print(f\"\u2713 Moved: {file.name} \u2192 {target_dir.name}/\")\n\n    def rename(\n        self,\n        directory: Path = Path(\".\"),\n        pattern: str = \"*\",\n        replace: str = \"\",\n        with_text: str = \"\",\n    ):\n        \"\"\"Batch rename files.\n\n        Args:\n            directory: Directory containing files\n            pattern: File pattern to match\n            replace: Text to replace in filenames\n            with_text: Replacement text\n        \"\"\"\n        files = list(directory.glob(pattern))\n\n        print(f\"Renaming {len(files)} file(s)...\\n\")\n\n        for file in files:\n            new_name = file.name.replace(replace, with_text)\n\n            if new_name == file.name:\n                continue\n\n            new_path = file.parent / new_name\n\n            if self.dry_run:\n                print(f\"[DRY RUN] {file.name} \u2192 {new_name}\")\n            else:\n                file.rename(new_path)\n                if self.verbose:\n                    print(f\"\u2713 {file.name} \u2192 {new_name}\")\n\n    def _format_size(self, size: int) -&gt; str:\n        \"\"\"Format bytes to human-readable size.\"\"\"\n        for unit in [\"B\", \"KB\", \"MB\", \"GB\", \"TB\"]:\n            if size &lt; 1024.0:\n                return f\"{size:.1f} {unit}\"\n            size /= 1024.0\n        return f\"{size:.1f} PB\"\n\n    def _hash_file(self, path: Path) -&gt; str:\n        \"\"\"Calculate MD5 hash of file.\"\"\"\n        hasher = hashlib.md5()\n        with path.open(\"rb\") as f:\n            for chunk in iter(lambda: f.read(8192), b\"\"):\n                hasher.update(chunk)\n        return hasher.hexdigest()\n\nif __name__ == \"__main__\":\n    FileManager()\n</code></pre>"},{"location":"tutorials/file-manager-cli/#cli-help-output","title":"CLI Help Output","text":"<pre><code>$ python filemanager.py --help\nusage: filemanager.py [-h] [--verbose] [--dry-run]\n                      {copy,delete,duplicates,find,ls,move,organize,rename,size}\n                      ...\n\nFile management CLI tool.\n\npositional arguments:\n  {copy,delete,duplicates,find,ls,move,organize,rename,size}\n    copy                Copy file or directory.\n    delete              Delete file or directory.\n    duplicates          Find duplicate files by content hash.\n    find                Find files by name pattern.\n    ls                  List files in a directory.\n    move                Move file or directory.\n    organize            Organize files into subdirectories.\n    rename              Batch rename files.\n    size                Calculate directory size.\n\noptions:\n  -h, --help            show this help message and exit\n  --verbose             Show detailed output (default: False)\n  --dry-run             Preview changes without executing (default: False)\n</code></pre>"},{"location":"tutorials/file-manager-cli/#usage-examples","title":"Usage Examples","text":""},{"location":"tutorials/file-manager-cli/#list-files","title":"List files","text":"<pre><code># List current directory\npython fm.py ls\n\n# List with sizes\npython fm.py ls --ls-show-size\n\n# List recursively with pattern\npython fm.py ls --ls-recursive --ls-pattern \"*.py\"\n</code></pre>"},{"location":"tutorials/file-manager-cli/#find-files","title":"Find files","text":"<pre><code># Find all Python files\npython fm.py find --find-pattern \"*.py\"\n\n# Case-sensitive search\npython fm.py find --find-pattern \"Test\" --find-case-sensitive\n\n# Find only directories\npython fm.py find --find-pattern \"lib\" --find-file-type dir\n</code></pre>"},{"location":"tutorials/file-manager-cli/#file-operations","title":"File operations","text":"<pre><code># Copy file (dry run first)\npython fm.py --FileManager-dry-run copy --copy-source old.txt --copy-destination new.txt\n\n# Move files\npython fm.py --FileManager-verbose move --move-source temp/ --move-destination archive/\n\n# Delete with confirmation\npython fm.py delete --delete-path old_file.txt\n</code></pre>"},{"location":"tutorials/file-manager-cli/#analysis","title":"Analysis","text":"<pre><code># Calculate directory size\npython fm.py size --size-directory /path/to/dir\n\n# Find duplicates\npython fm.py duplicates --duplicates-directory /path/to/dir\n</code></pre>"},{"location":"tutorials/file-manager-cli/#organization","title":"Organization","text":"<pre><code># Organize by file type (dry run)\npython fm.py --FileManager-dry-run organize --organize-by type\n\n# Organize by date\npython fm.py organize --organize-by date\n\n# Batch rename\npython fm.py rename --rename-pattern \"*.txt\" --rename-replace \" \" --rename-with-text \"_\"\n</code></pre>"},{"location":"tutorials/file-manager-cli/#advanced-features","title":"Advanced Features","text":"<p>Add these methods for more functionality:</p>"},{"location":"tutorials/file-manager-cli/#search-file-contents","title":"Search file contents","text":"<pre><code>def grep(self, pattern: str, directory: Path = Path(\".\"), file_pattern: str = \"*\"):\n    \"\"\"Search file contents.\n\n    Args:\n        pattern: Text pattern to search for\n        directory: Directory to search in\n        file_pattern: File pattern filter\n    \"\"\"\n    import re\n\n    matches = []\n    for file in directory.rglob(file_pattern):\n        if file.is_file():\n            try:\n                content = file.read_text()\n                if re.search(pattern, content):\n                    matches.append(file)\n            except (UnicodeDecodeError, PermissionError):\n                continue\n\n    print(f\"\\nFound pattern in {len(matches)} file(s):\\n\")\n    for match in matches:\n        print(f\"  {match}\")\n</code></pre>"},{"location":"tutorials/file-manager-cli/#create-file-archive","title":"Create file archive","text":"<pre><code>def archive(self, source: Path, output: Path, format: Literal[\"zip\", \"tar\", \"tgz\"] = \"zip\"):\n    \"\"\"Create archive of directory.\n\n    Args:\n        source: Source directory\n        output: Output archive path\n        format: Archive format\n    \"\"\"\n    import tarfile\n    import zipfile\n\n    if format == \"zip\":\n        with zipfile.ZipFile(output, \"w\", zipfile.ZIP_DEFLATED) as zf:\n            for file in source.rglob(\"*\"):\n                if file.is_file():\n                    zf.write(file, file.relative_to(source.parent))\n    else:\n        mode = \"w:gz\" if format == \"tgz\" else \"w\"\n        with tarfile.open(output, mode) as tf:\n            tf.add(source, arcname=source.name)\n\n    print(f\"\u2713 Created archive: {output}\")\n</code></pre>"},{"location":"tutorials/file-manager-cli/#complete-example","title":"Complete Example","text":"<p>See complete example with: - Progress bars for long operations - File filtering by size/date - Watch mode for monitoring changes - Trash/recycle bin instead of permanent delete - Undo functionality</p>"},{"location":"tutorials/file-manager-cli/#related","title":"Related","text":"<ul> <li>[[Building a System Monitor CLI]]</li> <li>Official Examples</li> </ul>"},{"location":"tutorials/system-monitor-cli/","title":"Building a System Monitor CLI","text":"<p>Create a system monitoring tool with wArgs for tracking CPU, memory, disk, network, and processes.</p>"},{"location":"tutorials/system-monitor-cli/#overview","title":"Overview","text":"<p>Build a CLI that can: - Monitor CPU and memory usage - Track disk space and I/O - Monitor network statistics - List and manage processes - Show system information - Log metrics to file - Send alerts on thresholds</p> <p>Prerequisites: - Python 3.8+ - wArgs: <code>pip install git+https://github.com/cmoxiv/wArgs.git</code> - psutil: <code>pip install psutil</code></p>"},{"location":"tutorials/system-monitor-cli/#complete-implementation","title":"Complete Implementation","text":"<pre><code>from wArgs import wArgs\nfrom pathlib import Path\nfrom typing import Literal\nimport psutil\nimport time\nimport json\nfrom datetime import datetime\nfrom dataclasses import dataclass, asdict\n\n@dataclass\nclass SystemMetrics:\n    \"\"\"System metrics snapshot.\"\"\"\n    timestamp: str\n    cpu_percent: float\n    memory_percent: float\n    disk_percent: float\n    network_sent: int\n    network_recv: int\n\n@wArgs\nclass SystemMonitor:\n    \"\"\"System monitoring and management CLI.\"\"\"\n\n    def __init__(self, verbose: bool = False):\n        \"\"\"Initialize system monitor.\n\n        Args:\n            verbose: Show detailed output\n        \"\"\"\n        self.verbose = verbose\n\n    def status(self):\n        \"\"\"Show current system status.\"\"\"\n        print(\"\\n=== System Status ===\\n\")\n\n        # CPU\n        cpu_percent = psutil.cpu_percent(interval=1)\n        cpu_count = psutil.cpu_count()\n        print(f\"CPU:\")\n        print(f\"  Usage: {cpu_percent}%\")\n        print(f\"  Cores: {cpu_count}\")\n        print(f\"  Frequency: {psutil.cpu_freq().current:.0f} MHz\")\n\n        # Memory\n        mem = psutil.virtual_memory()\n        print(f\"\\nMemory:\")\n        print(f\"  Total: {self._format_bytes(mem.total)}\")\n        print(f\"  Used: {self._format_bytes(mem.used)} ({mem.percent}%)\")\n        print(f\"  Available: {self._format_bytes(mem.available)}\")\n\n        # Disk\n        disk = psutil.disk_usage(\"/\")\n        print(f\"\\nDisk (/):\")\n        print(f\"  Total: {self._format_bytes(disk.total)}\")\n        print(f\"  Used: {self._format_bytes(disk.used)} ({disk.percent}%)\")\n        print(f\"  Free: {self._format_bytes(disk.free)}\")\n\n        # Network\n        net = psutil.net_io_counters()\n        print(f\"\\nNetwork:\")\n        print(f\"  Sent: {self._format_bytes(net.bytes_sent)}\")\n        print(f\"  Received: {self._format_bytes(net.bytes_recv)}\")\n\n    def cpu(self, per_cpu: bool = False, interval: int = 1):\n        \"\"\"Show CPU information and usage.\n\n        Args:\n            per_cpu: Show per-CPU statistics\n            interval: Measurement interval in seconds\n        \"\"\"\n        print(\"\\n=== CPU Information ===\\n\")\n\n        # Overall usage\n        cpu_percent = psutil.cpu_percent(interval=interval)\n        print(f\"Overall Usage: {cpu_percent}%\")\n\n        # Per-CPU usage\n        if per_cpu:\n            per_cpu_percent = psutil.cpu_percent(interval=interval, percpu=True)\n            print(f\"\\nPer-CPU Usage:\")\n            for i, percent in enumerate(per_cpu_percent):\n                bar = self._make_bar(percent, 20)\n                print(f\"  CPU {i}: {bar} {percent}%\")\n\n        # CPU times\n        cpu_times = psutil.cpu_times()\n        print(f\"\\nCPU Times:\")\n        print(f\"  User: {cpu_times.user:.2f}s\")\n        print(f\"  System: {cpu_times.system:.2f}s\")\n        print(f\"  Idle: {cpu_times.idle:.2f}s\")\n\n        # CPU frequency\n        freq = psutil.cpu_freq()\n        if freq:\n            print(f\"\\nFrequency:\")\n            print(f\"  Current: {freq.current:.0f} MHz\")\n            print(f\"  Min: {freq.min:.0f} MHz\")\n            print(f\"  Max: {freq.max:.0f} MHz\")\n\n    def memory(self):\n        \"\"\"Show memory information and usage.\"\"\"\n        print(\"\\n=== Memory Information ===\\n\")\n\n        # Virtual memory\n        mem = psutil.virtual_memory()\n        print(\"Virtual Memory:\")\n        print(f\"  Total: {self._format_bytes(mem.total)}\")\n        print(f\"  Available: {self._format_bytes(mem.available)}\")\n        print(f\"  Used: {self._format_bytes(mem.used)} ({mem.percent}%)\")\n        print(f\"  Free: {self._format_bytes(mem.free)}\")\n\n        # Memory bar\n        bar = self._make_bar(mem.percent, 40)\n        print(f\"\\n  Usage: {bar} {mem.percent}%\")\n\n        # Swap memory\n        swap = psutil.swap_memory()\n        if swap.total &gt; 0:\n            print(f\"\\nSwap Memory:\")\n            print(f\"  Total: {self._format_bytes(swap.total)}\")\n            print(f\"  Used: {self._format_bytes(swap.used)} ({swap.percent}%)\")\n            print(f\"  Free: {self._format_bytes(swap.free)}\")\n\n    def disk(self, path: Path = Path(\"/\")):\n        \"\"\"Show disk information and usage.\n\n        Args:\n            path: Disk path to check\n        \"\"\"\n        print(f\"\\n=== Disk Information ({path}) ===\\n\")\n\n        # Disk usage\n        usage = psutil.disk_usage(str(path))\n        print(\"Usage:\")\n        print(f\"  Total: {self._format_bytes(usage.total)}\")\n        print(f\"  Used: {self._format_bytes(usage.used)} ({usage.percent}%)\")\n        print(f\"  Free: {self._format_bytes(usage.free)}\")\n\n        # Usage bar\n        bar = self._make_bar(usage.percent, 40)\n        print(f\"\\n  {bar} {usage.percent}%\")\n\n        # Disk partitions\n        print(\"\\nAll Partitions:\")\n        for partition in psutil.disk_partitions():\n            try:\n                part_usage = psutil.disk_usage(partition.mountpoint)\n                print(f\"\\n  {partition.device}\")\n                print(f\"    Mountpoint: {partition.mountpoint}\")\n                print(f\"    Type: {partition.fstype}\")\n                print(f\"    Usage: {part_usage.percent}%\")\n            except PermissionError:\n                continue\n\n    def network(self, interval: int = 1):\n        \"\"\"Show network information and statistics.\n\n        Args:\n            interval: Measurement interval for speed\n        \"\"\"\n        print(\"\\n=== Network Information ===\\n\")\n\n        # Network interfaces\n        print(\"Interfaces:\")\n        for interface, addrs in psutil.net_if_addrs().items():\n            print(f\"\\n  {interface}:\")\n            for addr in addrs:\n                if addr.family == 2:  # IPv4\n                    print(f\"    IPv4: {addr.address}\")\n                elif addr.family == 30:  # IPv6\n                    print(f\"    IPv6: {addr.address}\")\n\n        # Network I/O\n        net1 = psutil.net_io_counters()\n        time.sleep(interval)\n        net2 = psutil.net_io_counters()\n\n        sent_per_sec = (net2.bytes_sent - net1.bytes_sent) / interval\n        recv_per_sec = (net2.bytes_recv - net1.bytes_recv) / interval\n\n        print(f\"\\nTotal Transfer:\")\n        print(f\"  Sent: {self._format_bytes(net2.bytes_sent)}\")\n        print(f\"  Received: {self._format_bytes(net2.bytes_recv)}\")\n\n        print(f\"\\nCurrent Speed:\")\n        print(f\"  Upload: {self._format_bytes(sent_per_sec)}/s\")\n        print(f\"  Download: {self._format_bytes(recv_per_sec)}/s\")\n\n    def processes(\n        self,\n        sort_by: Literal[\"cpu\", \"memory\", \"name\"] = \"cpu\",\n        limit: int = 10,\n    ):\n        \"\"\"Show running processes.\n\n        Args:\n            sort_by: Sort processes by metric\n            limit: Number of processes to show\n        \"\"\"\n        print(f\"\\n=== Top {limit} Processes (by {sort_by}) ===\\n\")\n\n        # Get all processes\n        processes = []\n        for proc in psutil.process_iter([\"pid\", \"name\", \"cpu_percent\", \"memory_percent\"]):\n            try:\n                processes.append(proc.info)\n            except (psutil.NoSuchProcess, psutil.AccessDenied):\n                pass\n\n        # Sort processes\n        if sort_by == \"cpu\":\n            processes.sort(key=lambda p: p[\"cpu_percent\"] or 0, reverse=True)\n        elif sort_by == \"memory\":\n            processes.sort(key=lambda p: p[\"memory_percent\"] or 0, reverse=True)\n        else:\n            processes.sort(key=lambda p: p[\"name\"] or \"\")\n\n        # Print table\n        print(f\"{'PID':&lt;8} {'Name':&lt;30} {'CPU%':&lt;8} {'Memory%':&lt;8}\")\n        print(\"-\" * 60)\n\n        for proc in processes[:limit]:\n            print(\n                f\"{proc['pid']:&lt;8} \"\n                f\"{proc['name'][:30]:&lt;30} \"\n                f\"{proc['cpu_percent'] or 0:&lt;8.1f} \"\n                f\"{proc['memory_percent'] or 0:&lt;8.1f}\"\n            )\n\n    def kill(self, pid: int, force: bool = False):\n        \"\"\"Kill a process by PID.\n\n        Args:\n            pid: Process ID to kill\n            force: Use SIGKILL instead of SIGTERM\n        \"\"\"\n        try:\n            proc = psutil.Process(pid)\n            name = proc.name()\n\n            if force:\n                proc.kill()\n                print(f\"\u2713 Killed process {pid} ({name})\")\n            else:\n                proc.terminate()\n                print(f\"\u2713 Terminated process {pid} ({name})\")\n\n        except psutil.NoSuchProcess:\n            print(f\"Error: Process {pid} not found\")\n        except psutil.AccessDenied:\n            print(f\"Error: Permission denied to kill process {pid}\")\n\n    def monitor(\n        self,\n        interval: int = 5,\n        duration: int = 60,\n        output: Path | None = None,\n    ):\n        \"\"\"Monitor system metrics over time.\n\n        Args:\n            interval: Seconds between measurements\n            duration: Total monitoring duration in seconds\n            output: Optional JSON file to save metrics\n        \"\"\"\n        print(f\"\\nMonitoring system for {duration}s (interval: {interval}s)...\")\n        print(\"Press Ctrl+C to stop\\n\")\n\n        metrics_log = []\n        start_time = time.time()\n\n        try:\n            while time.time() - start_time &lt; duration:\n                # Collect metrics\n                net = psutil.net_io_counters()\n                metrics = SystemMetrics(\n                    timestamp=datetime.now().isoformat(),\n                    cpu_percent=psutil.cpu_percent(interval=0.1),\n                    memory_percent=psutil.virtual_memory().percent,\n                    disk_percent=psutil.disk_usage(\"/\").percent,\n                    network_sent=net.bytes_sent,\n                    network_recv=net.bytes_recv,\n                )\n\n                metrics_log.append(metrics)\n\n                # Display\n                print(\n                    f\"[{metrics.timestamp}] \"\n                    f\"CPU: {metrics.cpu_percent:5.1f}% | \"\n                    f\"Mem: {metrics.memory_percent:5.1f}% | \"\n                    f\"Disk: {metrics.disk_percent:5.1f}%\"\n                )\n\n                time.sleep(interval)\n\n        except KeyboardInterrupt:\n            print(\"\\n\\nMonitoring stopped by user\")\n\n        # Save to file\n        if output and metrics_log:\n            data = [asdict(m) for m in metrics_log]\n            output.write_text(json.dumps(data, indent=2))\n            print(f\"\\n\u2713 Saved {len(metrics_log)} measurements to {output}\")\n\n    def alert(\n        self,\n        metric: Literal[\"cpu\", \"memory\", \"disk\"] = \"cpu\",\n        threshold: float = 80.0,\n        interval: int = 5,\n    ):\n        \"\"\"Alert when metric exceeds threshold.\n\n        Args:\n            metric: Metric to monitor\n            threshold: Alert threshold percentage\n            interval: Check interval in seconds\n        \"\"\"\n        print(f\"\\nMonitoring {metric} (alert at {threshold}%)...\")\n        print(\"Press Ctrl+C to stop\\n\")\n\n        try:\n            while True:\n                # Get current value\n                if metric == \"cpu\":\n                    value = psutil.cpu_percent(interval=1)\n                elif metric == \"memory\":\n                    value = psutil.virtual_memory().percent\n                elif metric == \"disk\":\n                    value = psutil.disk_usage(\"/\").percent\n\n                # Check threshold\n                if value &gt;= threshold:\n                    print(f\"\ud83d\udea8 ALERT: {metric.upper()} at {value:.1f}% (threshold: {threshold}%)\")\n                else:\n                    print(f\"\u2713 {metric.upper()}: {value:.1f}%\")\n\n                time.sleep(interval)\n\n        except KeyboardInterrupt:\n            print(\"\\n\\nMonitoring stopped\")\n\n    def _format_bytes(self, bytes: int) -&gt; str:\n        \"\"\"Format bytes to human-readable string.\"\"\"\n        for unit in [\"B\", \"KB\", \"MB\", \"GB\", \"TB\"]:\n            if bytes &lt; 1024.0:\n                return f\"{bytes:.1f} {unit}\"\n            bytes /= 1024.0\n        return f\"{bytes:.1f} PB\"\n\n    def _make_bar(self, percent: float, width: int = 20) -&gt; str:\n        \"\"\"Create a text progress bar.\"\"\"\n        filled = int(width * percent / 100)\n        bar = \"\u2588\" * filled + \"\u2591\" * (width - filled)\n        return f\"[{bar}]\"\n\nif __name__ == \"__main__\":\n    SystemMonitor()\n</code></pre>"},{"location":"tutorials/system-monitor-cli/#cli-help-output","title":"CLI Help Output","text":"<pre><code>$ python sysmonitor.py --help\nusage: sysmonitor.py [-h] [--verbose]\n                     {alert,cpu,disk,kill,memory,monitor,network,processes,status}\n                     ...\n\nSystem monitoring and management CLI.\n\npositional arguments:\n  {alert,cpu,disk,kill,memory,monitor,network,processes,status}\n    alert               Alert when metric exceeds threshold.\n    cpu                 Show CPU information and usage.\n    disk                Show disk information and usage.\n    kill                Kill a process by PID.\n    memory              Show memory information and usage.\n    monitor             Monitor system metrics over time.\n    network             Show network information and statistics.\n    processes           Show running processes.\n    status              Show current system status.\n\noptions:\n  -h, --help            show this help message and exit\n  --verbose             Show detailed output (default: False)\n</code></pre>"},{"location":"tutorials/system-monitor-cli/#usage-examples","title":"Usage Examples","text":""},{"location":"tutorials/system-monitor-cli/#show-system-status","title":"Show system status","text":"<pre><code>$ python monitor.py status\n\n=== System Status ===\n\nCPU:\n  Usage: 15.2%\n  Cores: 8\n  Frequency: 2400 MHz\n\nMemory:\n  Total: 16.0 GB\n  Used: 8.5 GB (53.1%)\n  Available: 7.5 GB\n\nDisk (/):\n  Total: 500.0 GB\n  Used: 250.0 GB (50.0%)\n  Free: 250.0 GB\n\nNetwork:\n  Sent: 1.2 GB\n  Received: 5.3 GB\n</code></pre>"},{"location":"tutorials/system-monitor-cli/#monitor-cpu-usage","title":"Monitor CPU usage","text":"<pre><code>$ python monitor.py cpu --cpu-per-cpu\n\n=== CPU Information ===\n\nOverall Usage: 18.5%\n\nPer-CPU Usage:\n  CPU 0: [\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591] 42.1%\n  CPU 1: [\u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591] 15.3%\n  CPU 2: [\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591] 28.7%\n  CPU 3: [\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591] 9.2%\n  ...\n</code></pre>"},{"location":"tutorials/system-monitor-cli/#show-top-processes","title":"Show top processes","text":"<pre><code>$ python monitor.py processes --processes-sort-by memory --processes-limit 5\n\n=== Top 5 Processes (by memory) ===\n\nPID      Name                           CPU%     Memory%\n------------------------------------------------------------\n1234     Google Chrome                  12.5     15.3\n5678     Python                         45.2     8.7\n9012     VSCode                         8.1      7.2\n3456     Terminal                       2.3      3.1\n7890     Safari                         5.4      2.9\n</code></pre>"},{"location":"tutorials/system-monitor-cli/#monitor-metrics-over-time","title":"Monitor metrics over time","text":"<pre><code>$ python monitor.py monitor \\\n  --monitor-interval 10 \\\n  --monitor-duration 300 \\\n  --monitor-output metrics.json\n\nMonitoring system for 300s (interval: 10s)...\nPress Ctrl+C to stop\n\n[2024-02-07T12:00:00] CPU:  15.2% | Mem:  53.1% | Disk:  50.0%\n[2024-02-07T12:00:10] CPU:  18.5% | Mem:  54.2% | Disk:  50.0%\n[2024-02-07T12:00:20] CPU:  22.1% | Mem:  55.1% | Disk:  50.0%\n...\n\n\u2713 Saved 30 measurements to metrics.json\n</code></pre>"},{"location":"tutorials/system-monitor-cli/#set-up-alerts","title":"Set up alerts","text":"<pre><code>$ python monitor.py alert \\\n  --alert-metric cpu \\\n  --alert-threshold 80.0 \\\n  --alert-interval 5\n\nMonitoring cpu (alert at 80.0%)...\nPress Ctrl+C to stop\n\n\u2713 CPU: 45.2%\n\u2713 CPU: 52.1%\n\ud83d\udea8 ALERT: CPU at 85.3% (threshold: 80.0%)\n\u2713 CPU: 72.4%\n</code></pre>"},{"location":"tutorials/system-monitor-cli/#advanced-features","title":"Advanced Features","text":""},{"location":"tutorials/system-monitor-cli/#system-info-command","title":"System info command","text":"<pre><code>def info(self):\n    \"\"\"Show detailed system information.\"\"\"\n    import platform\n\n    print(\"\\n=== System Information ===\\n\")\n    print(f\"System: {platform.system()}\")\n    print(f\"Release: {platform.release()}\")\n    print(f\"Version: {platform.version()}\")\n    print(f\"Machine: {platform.machine()}\")\n    print(f\"Processor: {platform.processor()}\")\n    print(f\"Python: {platform.python_version()}\")\n\n    # Boot time\n    boot_time = datetime.fromtimestamp(psutil.boot_time())\n    uptime = datetime.now() - boot_time\n    print(f\"\\nBoot time: {boot_time}\")\n    print(f\"Uptime: {uptime}\")\n</code></pre>"},{"location":"tutorials/system-monitor-cli/#export-metrics-to-csv","title":"Export metrics to CSV","text":"<pre><code>def export_metrics(self, output: Path, duration: int = 60):\n    \"\"\"Export metrics to CSV for analysis.\"\"\"\n    import csv\n\n    with output.open('w', newline='') as f:\n        writer = csv.writer(f)\n        writer.writerow(['timestamp', 'cpu', 'memory', 'disk'])\n\n        for _ in range(duration // 5):\n            writer.writerow([\n                datetime.now().isoformat(),\n                psutil.cpu_percent(),\n                psutil.virtual_memory().percent,\n                psutil.disk_usage('/').percent\n            ])\n            time.sleep(5)\n</code></pre>"},{"location":"tutorials/system-monitor-cli/#complete-example","title":"Complete Example","text":"<p>See complete monitor example with: - Real-time dashboard with curses - Email/Slack alerts - Historical data visualization - Service management - Log file analysis</p>"},{"location":"tutorials/system-monitor-cli/#best-practices","title":"Best Practices","text":"<ol> <li>Permissions - Some operations require root/admin</li> <li>Intervals - Balance accuracy vs performance</li> <li>Alerts - Set realistic thresholds</li> <li>Logging - Keep historical data for trends</li> <li>Cross-platform - Test on target OS</li> </ol>"},{"location":"tutorials/system-monitor-cli/#related","title":"Related","text":"<ul> <li>[[Building a Database CLI]] - Store metrics in database</li> <li>[[Building a File Manager CLI]] - Manage log files</li> <li>Official Examples</li> </ul>"},{"location":"tutorials/web-scraper-cli/","title":"Building a Web Scraper CLI","text":"<p>Create a powerful web scraping tool with wArgs for extracting data from websites, handling pagination, and exporting results.</p>"},{"location":"tutorials/web-scraper-cli/#overview","title":"Overview","text":"<p>Build a CLI that can: - Scrape web pages with custom selectors - Handle pagination automatically - Extract structured data (links, images, text) - Export to JSON, CSV, or Markdown - Respect robots.txt and rate limiting - Handle authentication and cookies</p> <p>Prerequisites: - Python 3.8+ - wArgs: <code>pip install git+https://github.com/cmoxiv/wArgs.git</code> - BeautifulSoup4: <code>pip install beautifulsoup4</code> - Requests: <code>pip install requests</code></p>"},{"location":"tutorials/web-scraper-cli/#complete-implementation","title":"Complete Implementation","text":"<pre><code>from wArgs import wArgs\nfrom pathlib import Path\nfrom typing import Literal\nimport requests\nfrom bs4 import BeautifulSoup\nfrom urllib.parse import urljoin, urlparse\nimport json\nimport csv\nimport time\nfrom dataclasses import dataclass, asdict\n\n@dataclass\nclass ScrapedItem:\n    \"\"\"Represents a scraped item.\"\"\"\n    url: str\n    title: str\n    content: str\n    links: list[str]\n    images: list[str]\n\n@wArgs\nclass WebScraper:\n    \"\"\"Web scraping CLI tool with export capabilities.\"\"\"\n\n    def __init__(\n        self,\n        user_agent: str = \"wArgs-Scraper/1.0\",\n        timeout: int = 30,\n        delay: float = 1.0,\n        verbose: bool = False,\n    ):\n        \"\"\"Initialize web scraper.\n\n        Args:\n            user_agent: User agent string for requests\n            timeout: Request timeout in seconds\n            delay: Delay between requests (rate limiting)\n            verbose: Show detailed output\n        \"\"\"\n        self.user_agent = user_agent\n        self.timeout = timeout\n        self.delay = delay\n        self.verbose = verbose\n        self.session = requests.Session()\n        self.session.headers.update({\"User-Agent\": user_agent})\n\n    def scrape(\n        self,\n        url: str,\n        output: Path,\n        format: Literal[\"json\", \"csv\", \"md\"] = \"json\",\n        max_pages: int = 1,\n    ):\n        \"\"\"Scrape a website and save results.\n\n        Args:\n            url: Starting URL to scrape\n            output: Output file path\n            format: Export format (json, csv, md)\n            max_pages: Maximum pages to scrape\n        \"\"\"\n        items = []\n        current_url = url\n\n        for page_num in range(max_pages):\n            if self.verbose:\n                print(f\"\\nScraping page {page_num + 1}/{max_pages}: {current_url}\")\n\n            # Scrape current page\n            item = self._scrape_page(current_url)\n            if item:\n                items.append(item)\n\n            # Find next page link (common pagination patterns)\n            next_url = self._find_next_page(current_url, item)\n            if not next_url or page_num + 1 &gt;= max_pages:\n                break\n\n            current_url = next_url\n            time.sleep(self.delay)\n\n        # Export results\n        self._export(items, output, format)\n        print(f\"\\n\u2713 Scraped {len(items)} page(s)\")\n        print(f\"\u2713 Saved to {output}\")\n\n    def extract(\n        self,\n        url: str,\n        selector: str,\n        attribute: str | None = None,\n    ):\n        \"\"\"Extract specific data using CSS selector.\n\n        Args:\n            url: URL to scrape\n            selector: CSS selector for elements\n            attribute: HTML attribute to extract (default: text content)\n        \"\"\"\n        response = self.session.get(url, timeout=self.timeout)\n        response.raise_for_status()\n\n        soup = BeautifulSoup(response.content, \"html.parser\")\n        elements = soup.select(selector)\n\n        print(f\"\\nFound {len(elements)} element(s) matching '{selector}':\\n\")\n\n        for i, elem in enumerate(elements[:20], 1):  # Limit to 20\n            if attribute:\n                value = elem.get(attribute, \"\")\n            else:\n                value = elem.get_text(strip=True)\n\n            print(f\"{i}. {value}\")\n\n        if len(elements) &gt; 20:\n            print(f\"\\n... and {len(elements) - 20} more\")\n\n    def links(\n        self,\n        url: str,\n        internal_only: bool = False,\n        output: Path | None = None,\n    ):\n        \"\"\"Extract all links from a page.\n\n        Args:\n            url: URL to scrape\n            internal_only: Only include internal links\n            output: Optional file to save links\n        \"\"\"\n        response = self.session.get(url, timeout=self.timeout)\n        response.raise_for_status()\n\n        soup = BeautifulSoup(response.content, \"html.parser\")\n        base_domain = urlparse(url).netloc\n\n        links = []\n        for a_tag in soup.find_all(\"a\", href=True):\n            href = urljoin(url, a_tag[\"href\"])\n\n            # Filter internal/external\n            if internal_only and urlparse(href).netloc != base_domain:\n                continue\n\n            links.append(href)\n\n        # Remove duplicates and sort\n        links = sorted(set(links))\n\n        print(f\"\\nFound {len(links)} {'internal ' if internal_only else ''}link(s):\\n\")\n\n        for link in links[:50]:  # Show first 50\n            print(f\"  \u2022 {link}\")\n\n        if len(links) &gt; 50:\n            print(f\"\\n... and {len(links) - 50} more\")\n\n        # Save to file if requested\n        if output:\n            output.write_text(\"\\n\".join(links))\n            print(f\"\\n\u2713 Saved {len(links)} links to {output}\")\n\n    def images(\n        self,\n        url: str,\n        download_dir: Path | None = None,\n    ):\n        \"\"\"Extract and optionally download images.\n\n        Args:\n            url: URL to scrape\n            download_dir: Directory to download images (optional)\n        \"\"\"\n        response = self.session.get(url, timeout=self.timeout)\n        response.raise_for_status()\n\n        soup = BeautifulSoup(response.content, \"html.parser\")\n        images = []\n\n        for img in soup.find_all(\"img\", src=True):\n            src = urljoin(url, img[\"src\"])\n            alt = img.get(\"alt\", \"\")\n            images.append({\"src\": src, \"alt\": alt})\n\n        print(f\"\\nFound {len(images)} image(s):\\n\")\n\n        for i, img in enumerate(images[:20], 1):\n            print(f\"{i}. {img['src']}\")\n            if img[\"alt\"]:\n                print(f\"   Alt: {img['alt']}\")\n\n        # Download images if directory specified\n        if download_dir:\n            download_dir.mkdir(parents=True, exist_ok=True)\n\n            for i, img in enumerate(images, 1):\n                try:\n                    img_response = self.session.get(img[\"src\"], timeout=self.timeout)\n                    img_response.raise_for_status()\n\n                    # Extract filename from URL\n                    filename = Path(urlparse(img[\"src\"]).path).name or f\"image_{i}.jpg\"\n                    file_path = download_dir / filename\n\n                    file_path.write_bytes(img_response.content)\n\n                    if self.verbose:\n                        print(f\"Downloaded: {filename}\")\n\n                    time.sleep(self.delay)\n\n                except Exception as e:\n                    if self.verbose:\n                        print(f\"Failed to download {img['src']}: {e}\")\n\n            print(f\"\\n\u2713 Downloaded {len(images)} images to {download_dir}\")\n\n    def table(\n        self,\n        url: str,\n        output: Path,\n        table_index: int = 0,\n    ):\n        \"\"\"Extract HTML table data to CSV.\n\n        Args:\n            url: URL containing the table\n            output: Output CSV file\n            table_index: Index of table to extract (0-based)\n        \"\"\"\n        response = self.session.get(url, timeout=self.timeout)\n        response.raise_for_status()\n\n        soup = BeautifulSoup(response.content, \"html.parser\")\n        tables = soup.find_all(\"table\")\n\n        if not tables:\n            print(\"No tables found on page\")\n            return\n\n        if table_index &gt;= len(tables):\n            print(f\"Error: Only {len(tables)} table(s) found\")\n            return\n\n        table = tables[table_index]\n\n        # Extract headers\n        headers = []\n        for th in table.find_all(\"th\"):\n            headers.append(th.get_text(strip=True))\n\n        # Extract rows\n        rows = []\n        for tr in table.find_all(\"tr\"):\n            cells = tr.find_all([\"td\", \"th\"])\n            if cells:\n                row = [cell.get_text(strip=True) for cell in cells]\n                rows.append(row)\n\n        # Write to CSV\n        with output.open(\"w\", newline=\"\", encoding=\"utf-8\") as f:\n            writer = csv.writer(f)\n            if headers:\n                writer.writerow(headers)\n            writer.writerows(rows)\n\n        print(f\"\\n\u2713 Extracted table with {len(rows)} rows to {output}\")\n\n    def _scrape_page(self, url: str) -&gt; ScrapedItem | None:\n        \"\"\"Scrape a single page.\"\"\"\n        try:\n            response = self.session.get(url, timeout=self.timeout)\n            response.raise_for_status()\n\n            soup = BeautifulSoup(response.content, \"html.parser\")\n\n            # Extract title\n            title = soup.find(\"title\")\n            title_text = title.get_text(strip=True) if title else \"\"\n\n            # Extract main content\n            # Try common content selectors\n            content_elem = (\n                soup.find(\"article\")\n                or soup.find(\"main\")\n                or soup.find(\"div\", class_=\"content\")\n                or soup.body\n            )\n            content = content_elem.get_text(strip=True) if content_elem else \"\"\n\n            # Extract links\n            links = [urljoin(url, a[\"href\"]) for a in soup.find_all(\"a\", href=True)]\n\n            # Extract images\n            images = [urljoin(url, img[\"src\"]) for img in soup.find_all(\"img\", src=True)]\n\n            return ScrapedItem(\n                url=url,\n                title=title_text,\n                content=content[:500],  # Truncate for demo\n                links=list(set(links)),\n                images=list(set(images)),\n            )\n\n        except Exception as e:\n            if self.verbose:\n                print(f\"Error scraping {url}: {e}\")\n            return None\n\n    def _find_next_page(self, current_url: str, item: ScrapedItem) -&gt; str | None:\n        \"\"\"Find next page link from common pagination patterns.\"\"\"\n        for link in item.links:\n            # Common pagination patterns\n            if any(x in link.lower() for x in [\"next\", \"page=\", \"p=\"]):\n                return link\n        return None\n\n    def _export(self, items: list[ScrapedItem], output: Path, format: str):\n        \"\"\"Export scraped items to file.\"\"\"\n        if format == \"json\":\n            data = [asdict(item) for item in items]\n            output.write_text(json.dumps(data, indent=2))\n\n        elif format == \"csv\":\n            with output.open(\"w\", newline=\"\", encoding=\"utf-8\") as f:\n                if items:\n                    fieldnames = [\"url\", \"title\", \"content\", \"links\", \"images\"]\n                    writer = csv.DictWriter(f, fieldnames=fieldnames)\n                    writer.writeheader()\n\n                    for item in items:\n                        row = asdict(item)\n                        row[\"links\"] = \"; \".join(row[\"links\"][:5])\n                        row[\"images\"] = \"; \".join(row[\"images\"][:5])\n                        writer.writerow(row)\n\n        elif format == \"md\":\n            lines = [\"# Scraped Content\\n\"]\n            for item in items:\n                lines.append(f\"## {item.title}\\n\")\n                lines.append(f\"**URL**: {item.url}\\n\")\n                lines.append(f\"**Content**: {item.content}\\n\")\n                lines.append(f\"**Links**: {len(item.links)}\\n\")\n                lines.append(f\"**Images**: {len(item.images)}\\n\\n\")\n\n            output.write_text(\"\\n\".join(lines))\n\nif __name__ == \"__main__\":\n    WebScraper()\n</code></pre>"},{"location":"tutorials/web-scraper-cli/#cli-help-output","title":"CLI Help Output","text":"<pre><code>$ python webscraper.py --help\nusage: webscraper.py [-h] [--user-agent USER_AGENT] [--timeout TIMEOUT]\n                     [--delay DELAY] [--verbose]\n                     {extract,images,links,scrape,table} ...\n\nWeb scraping CLI tool with export capabilities.\n\npositional arguments:\n  {extract,images,links,scrape,table}\n    extract             Extract specific data using CSS selector.\n    images              Extract and optionally download images.\n    links               Extract all links from a page.\n    scrape              Scrape a website and save results.\n    table               Extract HTML table data to CSV.\n\noptions:\n  -h, --help            show this help message and exit\n  --user-agent USER_AGENT\n                        User agent string for requests (default: 'wArgs-Scraper/1.0')\n  --timeout TIMEOUT     Request timeout in seconds (default: 30)\n  --delay DELAY         Delay between requests (rate limiting) (default: 1.0)\n  --verbose             Show detailed output (default: False)\n</code></pre>"},{"location":"tutorials/web-scraper-cli/#usage-examples","title":"Usage Examples","text":""},{"location":"tutorials/web-scraper-cli/#scrape-a-website","title":"Scrape a website","text":"<pre><code>$ python scraper.py scrape \\\n  --scrape-url \"https://example.com\" \\\n  --scrape-output results.json \\\n  --scrape-max-pages 3\n\nScraping page 1/3: https://example.com\nScraping page 2/3: https://example.com/page2\nScraping page 3/3: https://example.com/page3\n\n\u2713 Scraped 3 page(s)\n\u2713 Saved to results.json\n</code></pre>"},{"location":"tutorials/web-scraper-cli/#extract-specific-data","title":"Extract specific data","text":"<pre><code>$ python scraper.py extract \\\n  --extract-url \"https://example.com\" \\\n  --extract-selector \"h2.title\"\n\nFound 15 element(s) matching 'h2.title':\n\n1. First Article Title\n2. Second Article Title\n3. Third Article Title\n...\n</code></pre>"},{"location":"tutorials/web-scraper-cli/#extract-all-links","title":"Extract all links","text":"<pre><code>$ python scraper.py links \\\n  --links-url \"https://example.com\" \\\n  --links-internal-only \\\n  --links-output links.txt\n\nFound 42 internal link(s):\n\n  \u2022 https://example.com/about\n  \u2022 https://example.com/contact\n  \u2022 https://example.com/products\n  ...\n\n\u2713 Saved 42 links to links.txt\n</code></pre>"},{"location":"tutorials/web-scraper-cli/#download-images","title":"Download images","text":"<pre><code>$ python scraper.py --WebScraper-verbose images \\\n  --images-url \"https://example.com/gallery\" \\\n  --images-download-dir ./images\n\nFound 25 image(s):\n\n1. https://example.com/img/photo1.jpg\n2. https://example.com/img/photo2.jpg\n...\n\nDownloaded: photo1.jpg\nDownloaded: photo2.jpg\n...\n\n\u2713 Downloaded 25 images to ./images\n</code></pre>"},{"location":"tutorials/web-scraper-cli/#extract-table-to-csv","title":"Extract table to CSV","text":"<pre><code>$ python scraper.py table \\\n  --table-url \"https://example.com/data\" \\\n  --table-output data.csv \\\n  --table-table-index 0\n\n\u2713 Extracted table with 100 rows to data.csv\n</code></pre>"},{"location":"tutorials/web-scraper-cli/#advanced-features","title":"Advanced Features","text":""},{"location":"tutorials/web-scraper-cli/#add-authentication","title":"Add authentication","text":"<pre><code>def login(self, username: str, password: str, login_url: str):\n    \"\"\"Login to website with credentials.\n\n    Args:\n        username: Username\n        password: Password\n        login_url: Login page URL\n    \"\"\"\n    response = self.session.post(\n        login_url,\n        data={\"username\": username, \"password\": password}\n    )\n\n    if response.ok:\n        print(\"\u2713 Logged in successfully\")\n    else:\n        print(\"\u2717 Login failed\")\n</code></pre>"},{"location":"tutorials/web-scraper-cli/#respect-robotstxt","title":"Respect robots.txt","text":"<pre><code>from urllib.robotparser import RobotFileParser\n\ndef _can_fetch(self, url: str) -&gt; bool:\n    \"\"\"Check if URL can be fetched per robots.txt.\"\"\"\n    parsed = urlparse(url)\n    robots_url = f\"{parsed.scheme}://{parsed.netloc}/robots.txt\"\n\n    rp = RobotFileParser()\n    rp.set_url(robots_url)\n    rp.read()\n\n    return rp.can_fetch(self.user_agent, url)\n</code></pre>"},{"location":"tutorials/web-scraper-cli/#handle-javascript-with-selenium","title":"Handle JavaScript (with Selenium)","text":"<pre><code>from selenium import webdriver\nfrom selenium.webdriver.common.by import By\n\ndef scrape_js(self, url: str, wait_selector: str):\n    \"\"\"Scrape JavaScript-rendered content.\n\n    Args:\n        url: URL to scrape\n        wait_selector: CSS selector to wait for\n    \"\"\"\n    driver = webdriver.Chrome()\n    driver.get(url)\n\n    # Wait for dynamic content\n    WebDriverWait(driver, 10).until(\n        EC.presence_of_element_located((By.CSS_SELECTOR, wait_selector))\n    )\n\n    soup = BeautifulSoup(driver.page_source, \"html.parser\")\n    driver.quit()\n\n    # Process soup...\n</code></pre>"},{"location":"tutorials/web-scraper-cli/#complete-example","title":"Complete Example","text":"<p>See complete scraper example with: - Async scraping with asyncio - Progress bars - Error retry logic - Custom headers and cookies - Proxy support - Data validation</p>"},{"location":"tutorials/web-scraper-cli/#best-practices","title":"Best Practices","text":"<ol> <li>Respect robots.txt - Always check before scraping</li> <li>Rate limiting - Use delays between requests</li> <li>User agent - Identify your scraper properly</li> <li>Error handling - Handle network errors gracefully</li> <li>Legal compliance - Only scrape public data, respect ToS</li> </ol>"},{"location":"tutorials/web-scraper-cli/#related","title":"Related","text":"<ul> <li>[[Building a Database CLI]] - Store scraped data</li> <li>[[Building a File Manager CLI]] - Organize downloads</li> <li>Official Examples</li> </ul>"}]}